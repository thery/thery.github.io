<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>extra.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > div"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-centered alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect finmap.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</blockquote><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Set Implicit Arguments</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Unset Strict Implicit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*   Extra theorems and definitions                                           *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*   Extra theorems about lists                                               *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>


</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">rcons_injl</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span>: seq A) : injective (rcons a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>A</var><span class="hyp-type"><b>:</b><span><span class="kt">Type</span></span></span></div><div><var>a</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (rcons a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: a =&gt; /= [s1 s2 /= [] | b l IH s1 s2 [] /IH].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">rcons_injr</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span>: A) : injective (rcons ^~a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5</q><div><var>a</var><span class="hyp-type"><b>:</b><span>A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (rcons^~ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span> =&gt; [ [|b [|c]] //= | b s1 IH /= [/= [] -&gt; |c s2 [] -&gt; /IH-&gt; //]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5</q><div><var>a, b</var><span class="hyp-type"><b>:</b><span>A</span></span></div><div><var>s1</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">x2</span> : seq A,
rcons s1 a = rcons x2 a -&gt; s1 = x2</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rcons s1 a = [::] -&gt; a :: s1 = [::]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: (s1) =&gt; // [] [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">cat_injl</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span>: seq A) : injective (cat a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (cat a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>19</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: a =&gt; // b l IH s1 s2 /= [] /IH.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">cat_injr</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">a</span>: seq A) : injective (cat ^~a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (cat^~ a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: a =&gt; [s1 s2 |b l IH s1 s2]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !cats0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5</q><div><var>b</var><span class="hyp-type"><b>:</b><span>A</span></span></div><div><var>l</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span>injective (cat^~ l)</span></span></div><div><var>s1, s2</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s1 ++ b :: l = s2 ++ b :: l -&gt; s1 = s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -!cat_rcons =&gt; /IH; <span class="nb">apply</span>: rcons_injr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">in_split</span> (<span class="nv">A</span> : eqType) (<span class="nv">a</span> : A)  <span class="nv">l</span> :
  a \<span class="kr">in</span> l -&gt; <span class="kr">exists</span> <span class="nv">l1</span>, <span class="kr">exists</span> <span class="nv">l2</span>, l = l1 ++ a :: l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>A</var><span class="hyp-type"><b>:</b><span>eqType</span></span></div><q>d</q><div><var>l</var><span class="hyp-type"><b>:</b><span>seq_predType A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a \<span class="kr">in</span> l -&gt; <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : seq A, l = l1 ++ a :: l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: l =&gt; //= b l IH; <span class="nb">rewrite</span> inE =&gt; /orP[/eqP&lt;-|aIl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>27</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>a \<span class="kr">in</span> l -&gt;
<span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : seq A, l = l1 ++ a :: l2</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : seq A, a :: l = l1 ++ a :: l2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>27</q><q>37</q><div><var>aIl</var><span class="hyp-type"><b>:</b><span>a \<span class="kr">in</span> l</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : seq A, b :: l = l1 ++ a :: l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> [::]; <span class="kr">exists</span> <span class="nv">l</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b</q><span class="goal-separator"><hr></span><q>3d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (IH aIl) =&gt; l1 [l2 lE].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>27</q><q>37</q><q>3c</q><div><var>l1, l2</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><div><var>lE</var><span class="hyp-type"><b>:</b><span>l = l1 ++ a :: l2</span></span></div></div><span class="goal-separator"><hr></span><q>3d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">b</span> :: l1); <span class="kr">exists</span> <span class="nv">l2</span>; <span class="nb">rewrite</span> /= lE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">split_first</span> (<span class="nv">A</span> : eqType) (<span class="nv">l</span> : seq A) (<span class="nv">P</span> : pred A) :
  ~~ <span class="kp">all</span> [predC P] l -&gt; {bl1l2 : (A * seq A * seq A) |
    [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span> &amp;  
             l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>27</q><div><var>P</var><span class="hyp-type"><b>:</b><span>pred A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ <span class="kp">all</span> [predC P] l -&gt;
{bl1l2 : A * seq A * seq A
| [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>
    &amp; l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>48</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: l =&gt; //= b l IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>4b</q><q>26</q><q>27</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>~~ <span class="kp">all</span> [predC P] l -&gt;
{bl1l2 : A * seq A * seq A
| [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>
    &amp; l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ ((b \notin P) &amp;&amp; <span class="kp">all</span> [predC P] l) -&gt;
{bl1l2 : A * seq A * seq A
| [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>
    &amp; b :: l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> negb_and negbK; <span class="nb">case</span>: (boolP (b \<span class="kr">in</span> P)) =&gt;
      [bIP _| bNIP /= /IH [[[c l1] l2] [H1 H2 -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>4b</q><q>26</q><q>27</q><q>52</q><div><var>bIP</var><span class="hyp-type"><b>:</b><span>b \<span class="kr">in</span> P</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{bl1l2 : A * seq A * seq A
| [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>
    &amp; b :: l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>4b</q><q>26</q><q>27</q><q>52</q><div><var>bNIP</var><span class="hyp-type"><b>:</b><span>b \notin P</span></span></div><div><var>c</var><span class="hyp-type"><b>:</b><span>A</span></span></div><q>45</q><div><var>H1</var><span class="hyp-type"><b>:</b><span><span class="kp">all</span> [predC P] (c, l1, l2).<span class="mi">1</span>.<span class="mi">2</span></span></span></div><div><var>H2</var><span class="hyp-type"><b>:</b><span>P (c, l1, l2).<span class="mi">1</span>.<span class="mi">1</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">{bl1l2 : A * seq A * seq A
| [/\ <span class="kp">all</span> [predC P] bl1l2.<span class="mi">1</span>.<span class="mi">2</span>, P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>
    &amp; b
      :: (c, l1, l2).<span class="mi">1</span>.<span class="mi">2</span> ++
         (c, l1, l2).<span class="mi">1</span>.<span class="mi">1</span> :: (c, l1, l2).<span class="mi">2</span> =
      bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">b</span>, [::], l); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c</q><span class="goal-separator"><hr></span><q>61</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">c</span>, b :: l1, l2); <span class="nb">split</span>; <span class="nb">rewrite</span> /= <span class="nl">?bNIP</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">split_last</span> (<span class="nv">A</span> : eqType) (<span class="nv">l</span> : seq A) (<span class="nv">P</span> : pred A) :
  ~~ <span class="kp">all</span> [predC P] l  -&gt; 
  {bl1l2 | [/\  P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>, <span class="kp">all</span> [predC  P] bl1l2.<span class="mi">2</span> &amp;  
                l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ <span class="kp">all</span> [predC P] l -&gt;
{bl1l2 : A * seq A * seq A
| [/\ P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>, <span class="kp">all</span> [predC P] bl1l2.<span class="mi">2</span>
    &amp; l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>66</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; lA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>27</q><q>4b</q><div><var>lA</var><span class="hyp-type"><b>:</b><span>~~ <span class="kp">all</span> [predC P] l</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{bl1l2 : A * seq A * seq A
| [/\ P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>, <span class="kp">all</span> [predC P] bl1l2.<span class="mi">2</span>
    &amp; l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (@split_first _ (rev l) P); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> all_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6d</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A * seq A * seq A,
[/\ <span class="kp">all</span> [predC P] x.<span class="mi">1</span>.<span class="mi">2</span>, P x.<span class="mi">1</span>.<span class="mi">1</span>
  &amp; rev l = x.<span class="mi">1</span>.<span class="mi">2</span> ++ x.<span class="mi">1</span>.<span class="mi">1</span> :: x.<span class="mi">2</span>] -&gt;
{bl1l2 : A * seq A * seq A
| [/\ P bl1l2.<span class="mi">1</span>.<span class="mi">1</span>, <span class="kp">all</span> [predC P] bl1l2.<span class="mi">2</span>
    &amp; l = bl1l2.<span class="mi">1</span>.<span class="mi">2</span> ++ bl1l2.<span class="mi">1</span>.<span class="mi">1</span> :: bl1l2.<span class="mi">2</span>]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [[b l1] l2] [H1 H2 H3].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>27</q><q>4b</q><q>6e</q><q>26</q><q>45</q><div><var>H1</var><span class="hyp-type"><b>:</b><span><span class="kp">all</span> [predC P] (b, l1, l2).<span class="mi">1</span>.<span class="mi">2</span></span></span></div><div><var>H2</var><span class="hyp-type"><b>:</b><span>P (b, l1, l2).<span class="mi">1</span>.<span class="mi">1</span></span></span></div><div><var>H3</var><span class="hyp-type"><b>:</b><span>rev l =
(b, l1, l2).<span class="mi">1</span>.<span class="mi">2</span> ++
(b, l1, l2).<span class="mi">1</span>.<span class="mi">1</span> :: (b, l1, l2).<span class="mi">2</span></span></span></div></div><span class="goal-separator"><hr></span><q>6f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">b</span>, rev l2, rev l1); <span class="nb">split</span> =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> all_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>77</q><span class="goal-separator"><hr></span><div class="goal-conclusion">l =
(b, rev l2, rev l1).<span class="mi">1</span>.<span class="mi">2</span> ++
(b, rev l2, rev l1).<span class="mi">1</span>.<span class="mi">1</span> :: (b, rev l2, rev l1).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[l]revK H3 rev_cat /= rev_cons cat_rcons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">split_head</span> (<span class="nv">A</span> : eqType) (<span class="nv">a</span> <span class="nv">b</span> : A) <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> :
  l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
  [\/ [/\ l1 = l3, a = b &amp; l2 = l4],
      <span class="kr">exists</span> <span class="nv">l5</span>, l3 = l1 ++ a :: l5 |
      <span class="kr">exists</span> <span class="nv">l5</span>, l1 = l3 ++ b :: l5].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><div><var>l1, l2, l3, l4</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l3 = l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l1 = l3 ++ b :: l5]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>80</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: l1 l3 =&gt; /= [[[&lt;- &lt;-]|c l3 [&lt;- -&gt;]] /= | c l1 IH [[&lt;- &lt;-]|d l3 /= [&lt;-]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><div><var>l2, l4</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ [::] = [::], a = a &amp; l2 = l2],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = a :: l5]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>8a</q><q>5e</q><div><var>l3</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ [/\ [::] = a :: l3, a = b &amp; l3 ++ b :: l4 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, a :: l3 = a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = a :: l3 ++ b :: l5]</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>8a</q><q>5e</q><div><var>l1</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">l3</span> : seq A,
l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l3 = l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l1 = l3 ++ b :: l5]</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ [/\ c :: l1 = [::], a = c &amp; l2 = l1 ++ a :: l2],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = c :: l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l1 = [::] ++ c :: l5]</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>8a</q><q>5e</q><q>93</q><q>94</q><div><var>d</var><span class="hyp-type"><b>:</b><span>A</span></span></div><q>8f</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
[\/ [/\ c :: l1 = c :: l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l3 = c :: l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l1 = c :: l3 ++ b :: l5]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>87</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or31.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8e</q><span class="goal-separator"><hr></span><q>90</q></blockquote><div class="alectryon-extra-goals"><q>91</q><q>96</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>9c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or32; <span class="kr">exists</span> <span class="nv">l3</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>92</q><span class="goal-separator"><hr></span><q>95</q></blockquote><div class="alectryon-extra-goals"><q>96</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or33; <span class="kr">exists</span> <span class="nv">l1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>97</q><span class="goal-separator"><hr></span><q>99</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; /IH[[&lt;- &lt;- &lt;-]|[l5 -&gt;]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>97</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ c :: l1 = c :: l1, a = a &amp; l2 = l2],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l1 = c :: l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l1 = c :: l1 ++ a :: l5]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>8a</q><q>5e</q><q>93</q><q>94</q><q>98</q><div><var>l3, l5</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ [/\ c :: l1 = c :: l1 ++ a :: l5, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l6</span> : seq A,
      c :: l1 ++ a :: l5 = c :: l1 ++ a :: l6
  | <span class="kr">exists</span> <span class="nv">l6</span> : seq A,
      c :: l1 = c :: (l1 ++ a :: l5) ++ b :: l6]</div></blockquote><blockquote class="alectryon-goal"><q>97</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">exists</span> <span class="nv">l5</span> : seq A, l1 = l3 ++ b :: l5) -&gt;
[\/ [/\ c :: l1 = c :: l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l3 = c :: l1 ++ a :: l5
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, c :: l1 = c :: l3 ++ b :: l5]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>a9</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or31.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>ae</q><span class="goal-separator"><hr></span><q>b0</q></blockquote><div class="alectryon-extra-goals"><q>b1</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>b5</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or32; <span class="kr">exists</span> <span class="nv">l5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>97</q><span class="goal-separator"><hr></span><q>b2</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>=&gt; l5 -&gt;; <span class="nb">apply</span>: Or33; <span class="kr">exists</span> <span class="nv">l5</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">split_tail</span> (<span class="nv">A</span> : eqType) (<span class="nv">a</span> <span class="nv">b</span> : A) <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> :
  l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
  [\/ [/\ l1 = l3, a = b &amp; l2 = l4],
      <span class="kr">exists</span> <span class="nv">l5</span>, l4 = l5 ++ a :: l2 |
      <span class="kr">exists</span> <span class="nv">l5</span>, l2 = l5 ++ b :: l4].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>82</q><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l4 = l5 ++ a :: l2
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l2 = l5 ++ b :: l4]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>bd</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>/last_ind : l2 l4 =&gt; [l4|l2 c IH l4].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><div><var>l1, l3, l4</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ++ [:: a] = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; [::] = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l4 = l5 ++ [:: a]
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ b :: l4]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><div><var>l1, l3, l2</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><q>5e</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">l4</span> : seq A,
l1 ++ a :: l2 = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; l2 = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l4 = l5 ++ a :: l2
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l2 = l5 ++ b :: l4]</span></span></div><div><var>l4</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">l1 ++ a :: rcons l2 c = l3 ++ b :: l4 -&gt;
[\/ [/\ l1 = l3, a = b &amp; rcons l2 c = l4],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, l4 = l5 ++ a :: rcons l2 c
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, rcons l2 c = l5 ++ b :: l4]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (lastP l4) =&gt; /= [|l5 c].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ++ [:: a] = l3 ++ [:: b] -&gt;
[\/ [/\ l1 = l3, a = b &amp; [::] = [::]],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ [:: a]
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ [:: b]]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><div><var>l1, l3, l4, l5</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><q>5e</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">l1 ++ [:: a] = l3 ++ b :: rcons l5 c -&gt;
[\/ [/\ l1 = l3, a = b &amp; [::] = rcons l5 c],
    <span class="kr">exists</span> <span class="nv">l6</span> : seq A, rcons l5 c = l6 ++ [:: a]
  | <span class="kr">exists</span> <span class="nv">l6</span> : seq A, [::] = l6 ++ b :: rcons l5 c]</div></blockquote><q>c8</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> !cats1 =&gt; /rcons_inj[&lt;- &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ l1 = l1, a = a &amp; [::] = [::]],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ [:: a]
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ [:: a]]</div></blockquote><q>d2</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or31.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d4</q><span class="goal-separator"><hr></span><q>d6</q></blockquote><q>c7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> cats1 -rcons_cons -rcons_cat =&gt; /rcons_inj[-&gt; &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ l3 ++ b :: l5 = l3, a = b &amp; [::] = rcons l5 a],
    <span class="kr">exists</span> <span class="nv">l6</span> : seq A, rcons l5 a = l6 ++ [:: a]
  | <span class="kr">exists</span> <span class="nv">l6</span> : seq A, [::] = l6 ++ rcons (b :: l5) a]</div></blockquote><q>c7</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or32; <span class="kr">exists</span> <span class="nv">l5</span>; <span class="nb">rewrite</span> cats1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c9</q><span class="goal-separator"><hr></span><q>cd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (lastP l4) =&gt; /= [|l5 d].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ++ a :: rcons l2 c = l3 ++ [:: b] -&gt;
[\/ [/\ l1 = l3, a = b &amp; rcons l2 c = [::]],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ a :: rcons l2 c
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, rcons l2 c = l5 ++ [:: b]]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>ca</q><q>5e</q><q>cb</q><div><var>l4, l5</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div><q>98</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">l1 ++ a :: rcons l2 c = l3 ++ b :: rcons l5 d -&gt;
[\/ [/\ l1 = l3, a = b &amp; rcons l2 c = rcons l5 d],
    <span class="kr">exists</span> <span class="nv">l6</span> : seq A,
      rcons l5 d = l6 ++ a :: rcons l2 c
  | <span class="kr">exists</span> <span class="nv">l6</span> : seq A,
      rcons l2 c = l6 ++ b :: rcons l5 d]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> cats1 -rcons_cons -rcons_cat =&gt; /rcons_inj[&lt;- -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ l1 = l1 ++ a :: l2, a = b &amp; rcons l2 b = [::]],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A, [::] = l5 ++ rcons (a :: l2) b
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A, rcons l2 b = l5 ++ [:: b]]</div></blockquote><q>e9</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or33; <span class="kr">exists</span> <span class="nv">l2</span>; <span class="nb">rewrite</span> cats1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>eb</q><span class="goal-separator"><hr></span><q>ed</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -!rcons_cons -!rcons_cat =&gt; 
   /rcons_inj[/IH [[&lt;- &lt;- &lt;-]|[l6 -&gt;]|[l6 -&gt;]]] &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>eb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[\/ [/\ l1 = l1, a = a &amp; rcons l2 c = rcons l2 c],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A,
      rcons l2 c = l5 ++ rcons (a :: l2) c
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A,
      rcons l2 c = l5 ++ rcons (a :: l2) c]</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2f</q><q>14</q><q>ca</q><q>5e</q><q>cb</q><q>ec</q><q>98</q><div><var>l6</var><span class="hyp-type"><b>:</b><span>seq A</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ [/\ l1 = l3, a = b
      &amp; rcons l2 c = rcons (l6 ++ a :: l2) c],
    <span class="kr">exists</span> <span class="nv">l5</span> : seq A,
      rcons (l6 ++ a :: l2) c =
      l5 ++ rcons (a :: l2) c
  | <span class="kr">exists</span> <span class="nv">l5</span> : seq A,
      rcons l2 c = l5 ++ rcons (b :: l6 ++ a :: l2) c]</div></blockquote><blockquote class="alectryon-goal"><q>fb</q><label class="goal-separator"><hr></label><div class="goal-conclusion">[\/ [/\ l1 = l3, a = b
      &amp; rcons (l6 ++ b :: l5) c = rcons l5 c],
    <span class="kr">exists</span> <span class="nv">l7</span> : seq A,
      rcons l5 c = l7 ++ rcons (a :: l6 ++ b :: l5) c
  | <span class="kr">exists</span> <span class="nv">l7</span> : seq A,
      rcons (l6 ++ b :: l5) c =
      l7 ++ rcons (b :: l5) c]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>f6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or31.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fb</q><span class="goal-separator"><hr></span><q>fd</q></blockquote><div class="alectryon-extra-goals"><q>fe</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>102</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or32; <span class="kr">exists</span> <span class="nv">l6</span>; <span class="nb">rewrite</span> -rcons_cat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fb</q><span class="goal-separator"><hr></span><q>ff</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: Or33; <span class="kr">exists</span> <span class="nv">l6</span>; <span class="nb">rewrite</span> -rcons_cat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(* We develop a twisted version of split that fills &#39;I_{m + n} with           *)</span>
<span class="c">(* first the element of &#39;I_n (x -&gt; x) then the element of m (x -&gt; x + n)      *)</span>
<span class="c">(* This is mostly motivated to naturally get an element of &#39;I_n from &#39;I_n.+1  *)</span>
<span class="c">(* by removing max_ord                                                        *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tlshift_subproof</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_m) : i + n &lt; m + n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>m, n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>i</var><span class="hyp-type"><b>:</b><span>&#39;I_m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i + n &lt; m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>10a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltn_add2r.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trshift_subproof</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_n) : i &lt; m + n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q><div><var>i</var><span class="hyp-type"><b>:</b><span>&#39;I_n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>112</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans (valP i) _; <span class="nb">apply</span>: leq_addl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tlshift</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_m) := Ordinal (tlshift_subproof n i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trshift</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_n) := Ordinal (trshift_subproof m i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tlshift_inj</span> <span class="nv">m</span> <span class="nv">n</span> : injective (@tlshift m n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (tlshift n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>119</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? /(<span class="nb">f_equal</span> val) /addIn /val_inj.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trshift_inj</span> <span class="nv">m</span> <span class="nv">n</span> : injective (@trshift m n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">injective (trshift m (n:=n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>11f</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; ? ? /(<span class="nb">f_equal</span> val) /= /val_inj.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">trshift_lift</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_ n) : trshift <span class="mi">1</span> i = lift ord_max i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><q>115</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trshift <span class="mi">1</span> i = lift ord_max i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>124</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= /bump leqNgt ltn_ord.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tsplit_subproof</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_(m + n)) : i &gt;= n -&gt; i - n &lt; m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q><div><var>i</var><span class="hyp-type"><b>:</b><span>&#39;I_(m + n)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= i -&gt; i - n &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>12b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>/subSn &lt;-; <span class="nb">rewrite</span> leq_subLR [n + m]addnC.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tsplit</span> {<span class="nv">m</span> <span class="nv">n</span>} (<span class="nv">i</span> : &#39;I_(m + n)) : &#39;I_m + &#39;I_n :=
  <span class="kr">match</span> ltnP (i) n <span class="kr">with</span>
  | LtnNotGeq lt_i_n =&gt;  inr _ (Ordinal lt_i_n)
  | GeqNotLtn ge_i_n =&gt;  inl _ (Ordinal (tsplit_subproof ge_i_n))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variant</span> <span class="nf">tsplit_spec</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_(m + n)) : &#39;I_m + &#39;I_n -&gt; bool -&gt; <span class="kt">Type</span> :=
  | TSplitLo (j : &#39;I_n) of i = j :&gt; nat : tsplit_spec i (inr _ j) true
  | TSplitHi (k : &#39;I_m) of i = k + n :&gt; nat : tsplit_spec i (inl _ k) false.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tsplitP</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_(m + n)) : tsplit_spec i (tsplit i) (i &lt; n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>12d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">tsplit_spec i (tsplit i) (i &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>132</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">set</span> lt_i_n := i &lt; n; <span class="nb">rewrite</span> /tsplit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q><q>12e</q><div><var>lt_i_n</var><span><span class="hyp-body"><b>:=</b><span>i &lt; n</span></span><span class="hyp-type"><b>:</b><span>bool</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tsplit_spec i
  <span class="kr">match</span> ltnP i n <span class="kr">with</span>
  | LtnNotGeq lt_i_n =&gt;
      inr (Ordinal (n:=n) (m:=i) lt_i_n)
  | GeqNotLtn ge_i_n =&gt;
      inl
        (Ordinal (n:=m) (m:=i - n)
           (tsplit_subproof (m:=m) (n:=n) (i:=i)
              ge_i_n))
  <span class="kr">end</span> lt_i_n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: {-}_ lt_i_n / ltnP; [<span class="nb">left</span> |<span class="nb">right</span>; <span class="nb">rewrite</span> subnK].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tunsplit</span> {<span class="nv">m</span> <span class="nv">n</span>} (<span class="nv">jk</span> : &#39;I_m + &#39;I_n) :=
  <span class="kr">match</span> jk <span class="kr">with</span> inl j =&gt; tlshift n j | inr k =&gt; trshift m k <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">ltn_tunsplit</span> <span class="nv">m</span> <span class="nv">n</span> (<span class="nv">jk</span> : &#39;I_m + &#39;I_n) : (n &lt;= tunsplit jk) = jk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q><div><var>jk</var><span class="hyp-type"><b>:</b><span>(&#39;I_m + &#39;I_n)%type</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(n &lt;= tunsplit jk) = jk</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>13d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: jk =&gt; [j|k]; <span class="nb">rewrite</span> /= <span class="nl">?ltn_ord</span> <span class="nl">?leq_addl</span> // leqNgt ltn_ord.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tsplitK</span> {<span class="nv">m</span> <span class="nv">n</span>} : cancel (@tsplit m n) tunsplit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel tsplit tunsplit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>144</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">apply</span>: val_inj; <span class="nb">case</span>: tsplitP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tunsplitK</span> {<span class="nv">m</span> <span class="nv">n</span>} : cancel (@tunsplit m n) tsplit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">cancel tunsplit tsplit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>149</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; jk; <span class="nb">have</span>:= ltn_tunsplit jk; <span class="nb">rewrite</span> leqNgt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>13f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ (tunsplit jk &lt; n) = jk -&gt; tsplit (tunsplit jk) = jk</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">do</span> [<span class="nb">case</span>: tsplitP; <span class="nb">case</span>: jk =&gt; //= i j] =&gt; [|/addIn] =&gt; /ord_inj-&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*   Extra theorems about fset                                                *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> fset_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sint</span> <span class="nv">a</span> <span class="nv">b</span> : {fset nat} :=
   [fset @nat_of_ord _ i | i <span class="kr">in</span> &#39;I_b &amp; a &lt;= i].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_sint</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">i</span> : i \<span class="kr">in</span> sint a b = (a &lt;= i &lt; b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>a, b</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>i</var><span class="hyp-type"><b>:</b><span>nat_choiceType</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> sint a b) = (a &lt;= i &lt; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>152</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/idP =&gt; [[j /= aLj -&gt;]|/andP[aLi iLb]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><q>156</q><div><var>j</var><span class="hyp-type"><b>:</b><span>ordinal_choiceType b</span></span></div><div><var>aLj</var><span class="hyp-type"><b>:</b><span>j \<span class="kr">in</span> [pred x | a &lt;= x]</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt;= j &lt; b</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><q>156</q><div><var>aLi</var><span class="hyp-type"><b>:</b><span>a &lt;= i</span></span></div><div><var>iLb</var><span class="hyp-type"><b>:</b><span>i &lt; b</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> x : ordinal_choiceType b,
  in_mem x
    (mem_fin
       (subfinset_finpred (T:=ordinal_choiceType b)
          (mem_fin
             (fin_finpred
                (pT:=pred_finpredType
                       (ordinal_finType b)) &#39;I_b))
          (<span class="kr">fun</span> <span class="nv">i</span> : &#39;I_b =&gt; a &lt;= i))) &amp; i = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltn_ord andbT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>162</q><span class="goal-separator"><hr></span><q>165</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Ordinal</span> <span class="nv">iLb</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sint_sub</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : a &lt;= c -&gt;
   [fset i <span class="kr">in</span>  (sint a b) | c &lt;= i] = sint c b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>a, b, c</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &lt;= c -&gt; [fset i <span class="kr">in</span> sint a b | c &lt;= i] = sint c b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>16a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; aLc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16d</q><div><var>aLc</var><span class="hyp-type"><b>:</b><span>a &lt;= c</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[fset i <span class="kr">in</span> sint a b | c &lt;= i] = sint c b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16d</q><q>174</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> [fset i | i <span class="kr">in</span> sint a b &amp; c &lt;= i]) =
(i \<span class="kr">in</span> sint c b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> mem_sint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>179</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> [fset i | i <span class="kr">in</span> sint a b &amp; c &lt;= i]) =
(c &lt;= i &lt; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/idP =&gt; [[j /=]|/andP[cLi iLb]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16d</q><q>174</q><div><var>i, j</var><span class="hyp-type"><b>:</b><span>nat_choiceType</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j
  \<span class="kr">in</span> [pred x <span class="kr">in</span> [eta mem_seq (T:=nat_choiceType)
                        (sint a b)] |
        c &lt;= x] -&gt; i = j -&gt; c &lt;= i &lt; b</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16d</q><q>174</q><q>156</q><div><var>cLi</var><span class="hyp-type"><b>:</b><span>c &lt;= i</span></span></div><q>164</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> x : nat_choiceType,
  in_mem x
    (mem_fin
       (subfinset_finpred (T:=nat_choiceType)
          (mem_fin (fset_finpred (sint a b))) (leq c))) &amp;
  i = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> inE mem_sint =&gt; /andP[/andP[aLj jLb] cLj] -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>16d</q><q>174</q><q>183</q><div><var>aLj</var><span class="hyp-type"><b>:</b><span>a &lt;= j</span></span></div><div><var>jLb</var><span class="hyp-type"><b>:</b><span>j &lt; b</span></span></div><div><var>cLj</var><span class="hyp-type"><b>:</b><span>c &lt;= j</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c &lt;= j &lt; b</div></blockquote><q>185</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> cLj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>187</q><span class="goal-separator"><hr></span><q>189</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> //= inE mem_sint cLi iLb (leq_trans aLc).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sintSl</span> <span class="nv">a</span> <span class="nv">b</span> : sint a.+<span class="mi">1</span> b = sint a b `\ a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sint a.+<span class="mi">1</span> b = sint a b `\ a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>196</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; /= i; <span class="nb">rewrite</span> !inE !mem_sint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>a, b, i</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt; i &lt; b) = [&amp;&amp; i != a, a &lt;= i &amp; i &lt; b]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: ltngtP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sintSr</span> <span class="nv">a</span> <span class="nv">b</span> : sint a b.+<span class="mi">1</span> `\ b = sint a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>198</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sint a b.+<span class="mi">1</span> `\ b = sint a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; /= i; <span class="nb">rewrite</span> !inE !mem_sint ltnS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>19e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">[&amp;&amp; i != b, a &lt;= i &amp; i &lt;= b] = (a &lt;= i &lt; b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: ltngtP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sint_split</span> <span class="nv">a</span> <span class="nv">b</span> : sint a b = sint <span class="mi">0</span> b `\` sint <span class="mi">0</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>198</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sint a b = sint <span class="mi">0</span> b `\` sint <span class="mi">0</span> a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ab</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/fsetP =&gt; /= i; <span class="nb">rewrite</span> !inE !mem_sint /= -leqNgt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">card_sint</span> <span class="nv">a</span> <span class="nv">b</span> : #|`sint a b| = (b - a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>198</q><span class="goal-separator"><hr></span><div class="goal-conclusion">#|` sint a b| = b - a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: b =&gt; [|b IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>a</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#|` sint a <span class="mi">0</span>| = <span class="mi">0</span> - a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>#|` sint a b| = b - a</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">#|` sint a b.+<span class="mi">1</span>| = b.+<span class="mi">1</span> - a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> cardfs_eq0; <span class="nb">apply</span>/eqP/fsetP=&gt; i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1b8</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> sint a <span class="mi">0</span>) = (i \<span class="kr">in</span> fset0)</div></blockquote><q>1ba</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mem_sint andbF inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1bc</q><span class="goal-separator"><hr></span><q>1be</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [aLb|bLa] := leqP a b; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><q>1bd</q><div><var>bLa</var><span class="hyp-type"><b>:</b><span>b &lt; a</span></span></div></div><span class="goal-separator"><hr></span><q>1be</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><q>1bd</q><div><var>aLb</var><span class="hyp-type"><b>:</b><span>a &lt;= b</span></span></div></div><label class="goal-separator"><hr></label><q>1be</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (_ : _ - _ =  <span class="mi">0</span>); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1ca</q><span class="goal-separator"><hr></span><div class="goal-conclusion">b.+<span class="mi">1</span> - a = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1ca</q><label class="goal-separator"><hr></label><div class="goal-conclusion">#|` sint a b.+<span class="mi">1</span>| = <span class="mi">0</span></div></blockquote><q>1cd</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> subn_eq0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1ca</q><span class="goal-separator"><hr></span><q>1d6</q></blockquote><q>1cc</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> cardfs_eq0; <span class="nb">apply</span>/eqP/fsetP=&gt; i; <span class="nb">rewrite</span> mem_sint inE ltnS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>155</q><q>1bd</q><q>1cb</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a &lt;= i &lt;= b) = false</div></blockquote><q>1cc</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP =&gt; /andP[H1 /(leq_trans H1)]; <span class="nb">rewrite</span> leqNgt bLa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1ce</q><span class="goal-separator"><hr></span><q>1be</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (cardfsD1 b) (_ : _ \<span class="kr">in</span> _); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mem_sint aLb /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1ce</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(true + #|` sint a b.+<span class="mi">1</span> `\ b|)%N = b.+<span class="mi">1</span> - a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> sintSr IH subSn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;`[ n ]&quot;</span> := (sint <span class="mi">0</span> n) (<span class="kn">format</span> <span class="s2">&quot;`[ n ]&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sint0_set0</span> : `[<span class="mi">0</span>] = fset0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">`[<span class="mi">0</span>] = fset0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1e7</q></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/fsetP=&gt; i; <span class="nb">rewrite</span> mem_sint inE; <span class="nb">case</span>: ltngtP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">s2f</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) := [fset nat_of_ord i | i <span class="kr">in</span> s].</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_s2f</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) (<span class="nv">i</span> : &#39;I_n) : (i : nat) \<span class="kr">in</span> s2f s = (i \<span class="kr">in</span> s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><div><var>s</var><span class="hyp-type"><b>:</b><span>{<span class="nb">set</span> &#39;I_n}</span></span></div><q>115</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((i : nat) \<span class="kr">in</span> s2f (n:=n) s) = (i \<span class="kr">in</span> s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ec</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/idP =&gt; /= [[j jIs iEj]|iIs]; <span class="nb">last</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><div><var>i, j</var><span class="hyp-type"><b>:</b><span>&#39;I_n</span></span></div><div><var>jIs</var><span class="hyp-type"><b>:</b><span>j \<span class="kr">in</span> s</span></span></div><div><var>iEj</var><span class="hyp-type"><b>:</b><span>i = j</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i \<span class="kr">in</span> s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (_ : i = j) //; <span class="nb">apply</span>: val_inj.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2f_set0</span> <span class="nv">n</span> : s2f (set0 : {<span class="nb">set</span> &#39;I_n}) = fset0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (set0 : {<span class="nb">set</span> &#39;I_n}) = fset0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1fb</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; i; <span class="nb">rewrite</span> inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> s2f (n:=n) set0) = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/idP =&gt; /imfsetP[j /=]; <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2f_setT</span> <span class="nv">n</span> : s2f (setT : {<span class="nb">set</span> &#39;I_n}) = sint <span class="mi">0</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) ([<span class="nb">set</span>: ordinal_finType n] : {<span class="nb">set</span> &#39;I_n}) =
`[n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>206</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; i; <span class="nb">rewrite</span> mem_sint /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>203</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> s2f (n:=n) [<span class="nb">set</span>: &#39;I_n]) = (i &lt; n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/idP =&gt; /= [[j _ -&gt; //]| iLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>156</q><div><var>iLn</var><span class="hyp-type"><b>:</b><span>i &lt; n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> [<span class="nb">set</span>: &#39;I_n] &amp; i = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Ordinal</span> <span class="nv">iLn</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2fD</span> <span class="nv">n</span> (<span class="nv">s1</span> <span class="nv">s2</span> : {<span class="nb">set</span> &#39;I_n}) : s2f (s1 :\: s2)  = s2f s1 `\` s2f s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><div><var>s1, s2</var><span class="hyp-type"><b>:</b><span>{<span class="nb">set</span> &#39;I_n}</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (s1 :\: s2) =
s2f (n:=n) s1 `\` s2f (n:=n) s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>215</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; j; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>218</q><div><var>j</var><span class="hyp-type"><b>:</b><span>nat_choiceType</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(j \<span class="kr">in</span> s2f (n:=n) (s1 :\: s2)) =
(j \notin s2f (n:=n) s2) &amp;&amp; (j \<span class="kr">in</span> s2f (n:=n) s1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/andP =&gt; /= [[k]|[jDi /imfsetP[/= k kIs jEk]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>218</q><q>21f</q><div><var>k</var><span class="hyp-type"><b>:</b><span>&#39;I_n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k \<span class="kr">in</span> s1 :\: s2 -&gt;
j = k -&gt; j \notin s2f (n:=n) s2 /\ j \<span class="kr">in</span> s2f (n:=n) s1</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>218</q><q>21f</q><div><var>jDi</var><span class="hyp-type"><b>:</b><span>j \notin s2f (n:=n) s2</span></span></div><q>225</q><div><var>kIs</var><span class="hyp-type"><b>:</b><span>k \<span class="kr">in</span> s1</span></span></div><div><var>jEk</var><span class="hyp-type"><b>:</b><span>j = k</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> s1 :\: s2 &amp; j = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !inE -!mem_s2f =&gt; /andP[kDi kIs] -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>229</q><span class="goal-separator"><hr></span><q>22d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span> =&gt; //; <span class="nb">rewrite</span> !inE kIs -mem_s2f -jEk jDi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2fU</span> <span class="nv">n</span> (<span class="nv">s1</span> <span class="nv">s2</span> : {<span class="nb">set</span> &#39;I_n}) : s2f (s1 :|: s2)  = s2f s1 `|` s2f s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>217</q><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (s1 :|: s2) =
s2f (n:=n) s1 `|` s2f (n:=n) s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>232</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; j; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(j \<span class="kr">in</span> s2f (n:=n) (s1 :|: s2)) =
(j \<span class="kr">in</span> s2f (n:=n) s1) || (j \<span class="kr">in</span> s2f (n:=n) s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/orP =&gt; /= [[k]|[] /imfsetP[/= k]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>224</q><span class="goal-separator"><hr></span><div class="goal-conclusion">k \<span class="kr">in</span> s1 :|: s2 -&gt;
j = k -&gt; j \<span class="kr">in</span> s2f (n:=n) s1 \/ j \<span class="kr">in</span> s2f (n:=n) s2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>224</q><label class="goal-separator"><hr></label><div class="goal-conclusion">k \<span class="kr">in</span> s1 -&gt;
j = k -&gt; <span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> s1 :|: s2 &amp; j = x</div></blockquote><blockquote class="alectryon-goal"><q>224</q><label class="goal-separator"><hr></label><div class="goal-conclusion">k \<span class="kr">in</span> s2 -&gt;
j = k -&gt; <span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> s1 :|: s2 &amp; j = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>23b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !inE -!mem_s2f =&gt; /orP[] kIs -&gt;; [<span class="nb">left</span>|<span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>224</q><span class="goal-separator"><hr></span><q>240</q></blockquote><div class="alectryon-extra-goals"><q>241</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>245</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span> =&gt; kIs1 -&gt;; <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">rewrite</span> // inE kIs1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>224</q><span class="goal-separator"><hr></span><q>242</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span> =&gt; kIs2 -&gt;; <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">rewrite</span> // inE kIs2 orbT.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2fI</span> <span class="nv">n</span> (<span class="nv">s1</span> <span class="nv">s2</span> : {<span class="nb">set</span> &#39;I_n}) : s2f (s1 :&amp;: s2)  = s2f s1 `&amp;` s2f s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>217</q><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (s1 :&amp;: s2) =
s2f (n:=n) s1 `&amp;` s2f (n:=n) s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>24d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; j; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>21e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(j \<span class="kr">in</span> s2f (n:=n) (s1 :&amp;: s2)) =
(j \<span class="kr">in</span> s2f (n:=n) s1) &amp;&amp; (j \<span class="kr">in</span> s2f (n:=n) s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/andP =&gt; /= [[k]|[jDi /imfsetP[/= k kIs jEk]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>224</q><span class="goal-separator"><hr></span><div class="goal-conclusion">k \<span class="kr">in</span> s1 :&amp;: s2 -&gt;
j = k -&gt; j \<span class="kr">in</span> s2f (n:=n) s1 /\ j \<span class="kr">in</span> s2f (n:=n) s2</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>218</q><q>21f</q><div><var>jDi</var><span class="hyp-type"><b>:</b><span>j \<span class="kr">in</span> s2f (n:=n) s1</span></span></div><q>225</q><div><var>kIs</var><span class="hyp-type"><b>:</b><span>k \<span class="kr">in</span> s2</span></span></div><q>22c</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> s1 :&amp;: s2 &amp; j = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !inE -!mem_s2f =&gt; /andP[kDi kIs] -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>25b</q><span class="goal-separator"><hr></span><q>25e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span> =&gt; //; <span class="nb">rewrite</span> !inE kIs -mem_s2f -jEk jDi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2f1</span> <span class="nv">n</span> (<span class="nv">i</span> : &#39;I_n) : s2f [<span class="nb">set</span> i] = [fset (nat_of_ord i)].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>126</q><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) [<span class="nb">set</span> i] = [fset i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>263</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; j; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>115</q><q>21f</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(j \<span class="kr">in</span> s2f (n:=n) [<span class="nb">set</span> i]) = (j == i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/eqP =&gt; /= [[k]|-&gt;]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; /eqP -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>26a</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> [<span class="nb">set</span> i] &amp; i = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">i</span>; <span class="nb">rewrite</span> <span class="nl">?inE</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2f_pred</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) (<span class="nv">P</span> : pred nat) : 
   s2f [<span class="nb">set</span> i <span class="kr">in</span> s | P i] = [fset i <span class="kr">in</span> (s2f s) | P i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><div><var>P</var><span class="hyp-type"><b>:</b><span>pred nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) [<span class="nb">set</span> i <span class="kr">in</span> s | P i] =
[fset i <span class="kr">in</span> s2f (n:=n) s | P i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>271</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP=&gt; i; <span class="nb">rewrite</span> !inE /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>274</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> s2f (n:=n) [<span class="nb">set</span> i <span class="kr">in</span> s | P i]) =
(i
   \<span class="kr">in</span> [eta mem_seq (T:=nat_choiceType) (s2f (n:=n) s)]) &amp;&amp;
P i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/andP =&gt; /= [[j]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>274</q><q>156</q><div><var>j</var><span class="hyp-type"><b>:</b><span>&#39;I_n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j \<span class="kr">in</span> [<span class="nb">set</span> i <span class="kr">in</span> s | P i] -&gt;
i = j -&gt;
i \<span class="kr">in</span> [eta mem_seq (T:=nat_choiceType) (s2f (n:=n) s)] /\
P i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>27a</q><label class="goal-separator"><hr></label><div class="goal-conclusion">i \<span class="kr">in</span> [eta mem_seq (T:=nat_choiceType) (s2f (n:=n) s)] /\
P i -&gt;
<span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> [<span class="nb">set</span> i <span class="kr">in</span> s | P i] &amp; i = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> !inE =&gt; /andP[jIs jP] -&gt;; <span class="nb">split</span> =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>274</q><q>156</q><q>280</q><q>1f7</q><div><var>jP</var><span class="hyp-type"><b>:</b><span>P j</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j \<span class="kr">in</span> [eta mem_seq (T:=nat_choiceType) (s2f (n:=n) s)]</div></blockquote><q>282</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/imfsetP; <span class="kr">exists</span> <span class="nv">j</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>27a</q><span class="goal-separator"><hr></span><q>284</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [/imfsetP[/= j jIs -&gt;] jP]; <span class="kr">exists</span> <span class="nv">j</span> =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>288</q><span class="goal-separator"><hr></span><div class="goal-conclusion">j \<span class="kr">in</span> [<span class="nb">set</span> i <span class="kr">in</span> s | P i]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE jIs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2fD1</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) <span class="nv">i</span> : s2f (s :\ i) = s2f s `\ (nat_of_ord i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><div><var>i</var><span class="hyp-type"><b>:</b><span>ordinal_finType n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (s :\ i) = s2f (n:=n) s `\ i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>293</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> s2fD s2f1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">card_s2f</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) : #|` s2f s| = #|s|.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">#|` s2f (n:=n) s| = #|s|</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>29a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [m sLm] := ubnP #|s|; <span class="nb">elim</span>: m =&gt; // m IH s sLm <span class="kr">in</span> s sLm *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>n, m</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n},
#|s| &lt; m -&gt; #|` s2f (n:=n) s| = #|s|</span></span></div><q>1ef</q><div><var>sLm</var><span class="hyp-type"><b>:</b><span>#|s| &lt; m.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><q>29d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (set_0Vmem s) =&gt; [-&gt;|[i iIs]]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> s2f_set0 cards0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2a3</q><q>2a4</q><q>1ef</q><q>2a5</q><q>296</q><div><var>iIs</var><span class="hyp-type"><b>:</b><span>i \<span class="kr">in</span> s</span></span></div></div><span class="goal-separator"><hr></span><q>29d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (cardsD1 i) iIs /= -IH //; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">#|s :\ i| &lt; m</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>2a9</q><label class="goal-separator"><hr></label><div class="goal-conclusion">#|` s2f (n:=n) s| = (<span class="mi">1</span> + #|` s2f (n:=n) (s :\ i)|)%N</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: sLm; <span class="nb">rewrite</span> (cardsD1 i) iIs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a9</q><span class="goal-separator"><hr></span><q>2b1</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> [LHS](cardfsD1 (nat_of_ord i)) (_ : _ \<span class="kr">in</span> _); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a9</q><span class="goal-separator"><hr></span><div class="goal-conclusion">i \<span class="kr">in</span> s2f (n:=n) s</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>2a9</q><label class="goal-separator"><hr></label><div class="goal-conclusion">(true + #|` s2f (n:=n) s `\ i|)%N =
(<span class="mi">1</span> + #|` s2f (n:=n) (s :\ i)|)%N</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mem_s2f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a9</q><span class="goal-separator"><hr></span><q>2bb</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> s2fD1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* initial section of an ordinal *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isO</span> <span class="nv">n</span> <span class="nv">t</span> := [<span class="nb">set</span> i | (i : &#39;I_n) &lt; t].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">isOE</span> <span class="nv">n</span> <span class="nv">t</span> : t &lt;= n -&gt; s2f (isO n t) = sint <span class="mi">0</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>n, t</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t &lt;= n -&gt; s2f (n:=n) (isO n t) = `[t]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; tLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><div><var>tLn</var><span class="hyp-type"><b>:</b><span>t &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (isO n t) = `[t]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; i; <span class="nb">rewrite</span> mem_sint.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>2ca</q><q>156</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> s2f (n:=n) (isO n t)) = (<span class="mi">0</span> &lt;= i &lt; t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/idP =&gt; /= [[j]|iLt]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inE =&gt; jLt -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>2ca</q><q>156</q><div><var>iLt</var><span class="hyp-type"><b>:</b><span>i &lt; t</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> isO n t &amp; i = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> iLn : i &lt; n <span class="bp">by</span> <span class="nb">apply</span>: leq_trans tLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>2ca</q><q>156</q><q>2d5</q><q>212</q></div><span class="goal-separator"><hr></span><q>2d6</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Ordinal</span> <span class="nv">iLn</span>); <span class="nb">rewrite</span> // inE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mem_isO</span> <span class="nv">n</span> <span class="nv">t</span> <span class="nv">i</span> : (i \<span class="kr">in</span> isO n t) = (i &lt; t).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>296</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i \<span class="kr">in</span> isO n t) = (i &lt; t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2dc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">isOE_ge</span> <span class="nv">n</span> <span class="nv">t</span> : n &lt;= t -&gt; isO n t = setT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2c2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= t -&gt; isO n t = [<span class="nb">set</span>: ordinal_finType n]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2e2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; nLt; <span class="nb">apply</span>/setP =&gt; √≠; <span class="nb">rewrite</span> !inE (leq_trans _ nLt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">isOE_le</span> <span class="nv">n</span> <span class="nv">t</span> : t &lt; n.+<span class="mi">1</span> -&gt; isO n.+<span class="mi">1</span> t = [<span class="nb">set</span> inord i | i : &#39;I_t].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2c2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">t &lt; n.+<span class="mi">1</span> -&gt; isO n.+<span class="mi">1</span> t = [<span class="nb">set</span> inord i | i : &#39;I_t]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2e7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; tLn; <span class="nb">apply</span>/setP=&gt; i; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><div><var>tLn</var><span class="hyp-type"><b>:</b><span>t &lt; n.+<span class="mi">1</span></span></span></div><div><var>i</var><span class="hyp-type"><b>:</b><span>ordinal_finType n.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i &lt; t) = (i \<span class="kr">in</span> [<span class="nb">set</span> inord i | i : &#39;I_t])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/idP/imsetP =&gt; [iLt| [j _ -&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>2ef</q><q>2f0</q><q>2d5</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> x : ordinal_finType t,
  x \<span class="kr">in</span> &#39;I_t &amp; i = inord x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><q>2ef</q><q>2f0</q><div><var>j</var><span class="hyp-type"><b>:</b><span>ordinal_finType t</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">inord j &lt; t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Ordinal</span> <span class="nv">iLt</span>); <span class="nb">rewrite</span> //=; <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2f9</q><span class="goal-separator"><hr></span><q>2fb</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> inordK // (leq_trans _ tLn) // ltnS // ltnW.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">card_isO</span> <span class="nv">n</span> <span class="nv">t</span> : #|isO n t| = minn n t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2c2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">#|isO n t| = minn n t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>300</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/sym_equal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2c2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">minn n t = #|isO n t|</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (leqP n t) =&gt; [nLt|tLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><div><var>nLt</var><span class="hyp-type"><b>:</b><span>n &lt;= t</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n = #|isO n t|</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2c3</q><div><var>tLn</var><span class="hyp-type"><b>:</b><span>t &lt; n</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">t = #|isO n t|</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> isOE_ge //= cardsT card_ord.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>310</q><span class="goal-separator"><hr></span><q>312</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: n tLn =&gt; // n tLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>t, n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><q>2ef</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t = #|isO n.+<span class="mi">1</span> t|</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> isOE_le // card_imset // =&gt; [|i j /val_eqP/eqP /=].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>319</q><span class="goal-separator"><hr></span><div class="goal-conclusion">t = #|&#39;I_t|</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>31a</q><q>2ef</q><div><var>i, j</var><span class="hyp-type"><b>:</b><span>ordinal_finType t</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">inord i = inord j -&gt; i = j</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> card_ord.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>322</q><span class="goal-separator"><hr></span><q>324</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !inordK ?(leq_trans _ tLn) <span class="nl">?ltnS</span> <span class="mi">1</span><span class="nl">?ltnW</span> // =&gt; /eqP/val_eqP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">s2fD_isO</span> <span class="nv">n</span> (<span class="nv">s</span> : {<span class="nb">set</span> &#39;I_n}) <span class="nv">t</span> : s2f (s :\: isO n t)  = s2f s `\` sint <span class="mi">0</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><div><var>t</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s2f (n:=n) (s :\: isO n t) = s2f (n:=n) s `\` `[t]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>329</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/fsetP =&gt; j; <span class="nb">rewrite</span> !inE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>32c</q><q>21f</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(j \<span class="kr">in</span> s2f (n:=n) (s :\: isO n t)) =
(j \notin `[t]) &amp;&amp; (j \<span class="kr">in</span> s2f (n:=n) s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/imfsetP/andP =&gt; /= [[k]|[jDi /imfsetP[/= k kIs jEk]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>32c</q><q>21f</q><q>225</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k \<span class="kr">in</span> s :\: isO n t -&gt;
j = k -&gt; j \notin `[t] /\ j \<span class="kr">in</span> s2f (n:=n) s</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>32c</q><q>21f</q><div><var>jDi</var><span class="hyp-type"><b>:</b><span>j \notin `[t]</span></span></div><q>225</q><div><var>kIs</var><span class="hyp-type"><b>:</b><span>k \<span class="kr">in</span> s</span></span></div><q>22c</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> x : &#39;I_n, x \<span class="kr">in</span> s :\: isO n t &amp; j = x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !inE -!mem_s2f mem_sint /= =&gt; /andP[kDi kIs] -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>33b</q><span class="goal-separator"><hr></span><q>33e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: jDi; <span class="nb">rewrite</span> mem_sint /= -leqNgt =&gt; jDi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><q>1ef</q><q>32c</q><q>21f</q><q>225</q><q>33d</q><q>22c</q><div><var>jDi</var><span class="hyp-type"><b>:</b><span>t &lt;= j</span></span></div></div><span class="goal-separator"><hr></span><q>33e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">rewrite</span> // !inE -leqNgt kIs -jEk jDi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*              Specific theorems for shanoi                                  *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> nat_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">codom_subC</span> (<span class="nv">A</span> : finType) (<span class="nv">B</span> : finType) (<span class="nv">f</span> : {ffun A -&gt; B}) 
          (<span class="nv">p1</span> <span class="nv">p2</span> : B) : 
  (codom f \subset [:: p1; p2]) = (codom f \subset [:: p2; p1]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>A, B</var><span class="hyp-type"><b>:</b><span>finType</span></span></div><div><var>f</var><span class="hyp-type"><b>:</b><span>{ffun A -&gt; B}</span></span></div><div><var>p1, p2</var><span class="hyp-type"><b>:</b><span>B</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(codom f \subset [:: p1; p2]) =
(codom f \subset [:: p2; p1])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>348</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/subsetP/subsetP; <span class="nb">move</span> =&gt; sB i /sB; <span class="nb">rewrite</span> !inE orbC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">inord_eq0</span> <span class="nv">n</span> <span class="nv">k</span> : k = <span class="mi">0</span> -&gt; inord k = ord0 :&gt; &#39;I_n.+<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>n, k</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k = <span class="mi">0</span> -&gt; inord k = ord0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>351</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt; /=; <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mod3_0</span> <span class="nv">a</span> : (<span class="mi">3</span> * a) %% <span class="mi">3</span> = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a) %% <span class="mi">3</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>358</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> modnMr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mod3_1</span> <span class="nv">a</span> : (<span class="mi">3</span> * a).+<span class="mi">1</span> %% <span class="mi">3</span> = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a).+<span class="mi">1</span> %% <span class="mi">3</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>35d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulnC -addn1 modnMDl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">mod3_2</span> <span class="nv">a</span> : (<span class="mi">3</span> * a).+<span class="mi">2</span> %% <span class="mi">3</span> = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a).+<span class="mi">2</span> %% <span class="mi">3</span> = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>362</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulnC -addn2 modnMDl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mod3E</span> := (mod3_0, mod3_1, mod3_2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">div3_0</span> <span class="nv">a</span> : (<span class="mi">3</span> * a) %/ <span class="mi">3</span> = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a) %/ <span class="mi">3</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>367</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulKn.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">div3_1</span> <span class="nv">a</span> : (<span class="mi">3</span> * a).+<span class="mi">1</span> %/ <span class="mi">3</span> = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a).+<span class="mi">1</span> %/ <span class="mi">3</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>36c</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulnC -addn1 divnMDl // divn_small // addn0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">div3_2</span> <span class="nv">a</span> : (<span class="mi">3</span> * a).+<span class="mi">2</span> %/ <span class="mi">3</span> = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1b7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">3</span> * a).+<span class="mi">2</span> %/ <span class="mi">3</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>371</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulnC -addn2 divnMDl // divn_small // addn0.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">div3E</span> := (div3_0, div3_1, div3_2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum3E</span> <span class="nv">n</span> (<span class="nv">f</span> : nat -&gt; nat) : 
  \sum_(i &lt; <span class="mi">3</span> * n) f i =
  \sum_(i &lt; n) (f (<span class="mi">3</span> * i) + f (<span class="mi">3</span> * i).+<span class="mi">1</span> + f (<span class="mi">3</span> * i).+<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><div><var>f</var><span class="hyp-type"><b>:</b><span>nat -&gt; nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(i &lt; <span class="mi">3</span> * n) f i =
\sum_(i &lt; n) (f (<span class="mi">3</span> * i) + f (<span class="mi">3</span> * i).+<span class="mi">1</span> + f (<span class="mi">3</span> * i).+<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>376</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n =&gt; [|n IH]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !big_ord0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>\sum_(i &lt; <span class="mi">3</span> * n) f i =
\sum_(i &lt; n)
   (f (<span class="mi">3</span> * i) + f (<span class="mi">3</span> * i).+<span class="mi">1</span> + f (<span class="mi">3</span> * i).+<span class="mi">2</span>)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(i &lt; <span class="mi">3</span> * n.+<span class="mi">1</span>) f i =
\sum_(i &lt; n.+<span class="mi">1</span>)
   (f (<span class="mi">3</span> * i) + f (<span class="mi">3</span> * i).+<span class="mi">1</span> + f (<span class="mi">3</span> * i).+<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> mulnS !big_ord_recr /= IH !addnA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Ival_eq</span> <span class="nv">n</span> (<span class="nv">x</span> <span class="nv">y</span> : &#39;I_n) : (x == y) = (val x == val y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>127</q><div><var>x, y</var><span class="hyp-type"><b>:</b><span>&#39;I_n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x == y) = (val x == val y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>383</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/eqP/val_eqP.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">oddS</span> <span class="nv">n</span> : odd n.+<span class="mi">1</span> = ~~ odd n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">odd n.+<span class="mi">1</span> = ~~ odd n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>38a</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">even_halfMl</span> <span class="nv">k</span> <span class="nv">m</span> : 
  ~~ odd m -&gt; (k * m)./<span class="mi">2</span> = k * m./<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>k, m</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ odd m -&gt; (k * m)./<span class="mi">2</span> = k * m./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>38f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>392</q><div><var>mE</var><span class="hyp-type"><b>:</b><span>~~ odd m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(k * m)./<span class="mi">2</span> = k * m./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half m; <span class="nb">rewrite</span> (negPf mE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>398</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(k * (m./<span class="mi">2</span>).*<span class="mi">2</span>)./<span class="mi">2</span> = k * m./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -doubleMr doubleK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">even_halfMr</span> <span class="nv">k</span> <span class="nv">m</span> : 
  ~~ odd m -&gt; (m * k)./<span class="mi">2</span> = m./<span class="mi">2</span> * k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>391</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ odd m -&gt; (m * k)./<span class="mi">2</span> = m./<span class="mi">2</span> * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3a0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>398</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(m * k)./<span class="mi">2</span> = m./<span class="mi">2</span> * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half m; <span class="nb">rewrite</span> (negPf mE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>398</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((m./<span class="mi">2</span>).*<span class="mi">2</span> * k)./<span class="mi">2</span> = m./<span class="mi">2</span> * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -doubleMl doubleK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">even_halfD</span> <span class="nv">m</span> <span class="nv">n</span> : 
  ~~ odd m -&gt; ~~ odd n -&gt; (m + n)./<span class="mi">2</span> = (m./<span class="mi">2</span> + n./<span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ odd m -&gt; ~~ odd n -&gt; (m + n)./<span class="mi">2</span> = m./<span class="mi">2</span> + n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ad</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mE nE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>10d</q><q>399</q><div><var>nE</var><span class="hyp-type"><b>:</b><span>~~ odd n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(m + n)./<span class="mi">2</span> = m./<span class="mi">2</span> + n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half m; <span class="nb">rewrite</span> (negPf mE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((m./<span class="mi">2</span>).*<span class="mi">2</span> + n)./<span class="mi">2</span> = m./<span class="mi">2</span> + n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half n; <span class="nb">rewrite</span> (negPf nE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((m./<span class="mi">2</span>).*<span class="mi">2</span> + (n./<span class="mi">2</span>).*<span class="mi">2</span>)./<span class="mi">2</span> = m./<span class="mi">2</span> + n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -doubleD doubleK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">even_halfB</span> <span class="nv">m</span> <span class="nv">n</span> : 
  ~~ odd m -&gt; ~~ odd n -&gt; (m - n)./<span class="mi">2</span> = m./<span class="mi">2</span> - n./<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">~~ odd m -&gt; ~~ odd n -&gt; (m - n)./<span class="mi">2</span> = m./<span class="mi">2</span> - n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3c0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mE nE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(m - n)./<span class="mi">2</span> = m./<span class="mi">2</span> - n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half m; <span class="nb">rewrite</span> (negPf mE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((m./<span class="mi">2</span>).*<span class="mi">2</span> - n)./<span class="mi">2</span> = m./<span class="mi">2</span> - n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := odd_double_half n; <span class="nb">rewrite</span> (negPf nE) add0n =&gt; {<span class="mi">1</span>}&lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3b4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">((m./<span class="mi">2</span>).*<span class="mi">2</span> - (n./<span class="mi">2</span>).*<span class="mi">2</span>)./<span class="mi">2</span> = m./<span class="mi">2</span> - n./<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -doubleB doubleK.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">leq_pred2</span> <span class="nv">m</span> <span class="nv">n</span> : m &lt;= n -&gt; m.-<span class="mi">1</span> &lt;= n.-<span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= n -&gt; m.-<span class="mi">1</span> &lt;= n.-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: m; <span class="nb">case</span>: n =&gt; //=.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subn_minr</span> : left_distributive subn minn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">left_distributive subn minn</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; m n p; <span class="nb">rewrite</span> /minn; <span class="nb">case</span>: leqP =&gt; [nLm|mLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>m, n, p</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>nLm</var><span class="hyp-type"><b>:</b><span>n &lt;= m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n - p = (<span class="kr">if</span> m - p &lt; n - p <span class="kr">then</span> m - p <span class="kr">else</span> n - p)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><div><var>mLn</var><span class="hyp-type"><b>:</b><span>m &lt; n</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">m - p = (<span class="kr">if</span> m - p &lt; n - p <span class="kr">then</span> m - p <span class="kr">else</span> n - p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnNge leq_sub2r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e3</q><span class="goal-separator"><hr></span><q>3e5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [nLp|pLn] := leqP n p; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltn_sub2r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><q>3e4</q><div><var>nLp</var><span class="hyp-type"><b>:</b><span>n &lt;= p</span></span></div></div><span class="goal-separator"><hr></span><q>3e5</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">move</span>: (nLp); <span class="nb">rewrite</span> -subn_eq0 =&gt; /eqP-&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m - p == (<span class="kr">if</span> m - p &lt; <span class="mi">0</span> <span class="kr">then</span> m - p <span class="kr">else</span> <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnNge //= subn_eq0 (leq_trans (ltnW mLn)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">subn_maxr</span> : left_distributive subn maxn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">left_distributive subn maxn</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3f3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; m n p; <span class="nb">rewrite</span> /maxn; <span class="nb">case</span>: leqP =&gt; [nLm|mLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3dd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m - p = (<span class="kr">if</span> m - p &lt; n - p <span class="kr">then</span> n - p <span class="kr">else</span> m - p)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3e3</q><label class="goal-separator"><hr></label><div class="goal-conclusion">n - p = (<span class="kr">if</span> m - p &lt; n - p <span class="kr">then</span> n - p <span class="kr">else</span> m - p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnNge leq_sub2r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e3</q><span class="goal-separator"><hr></span><q>3fd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> [nLp|pLn] := leqP n p; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltn_sub2r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><q>3fd</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">move</span>: (nLp); <span class="nb">rewrite</span> -subn_eq0 =&gt; /eqP-&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3ec</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> == (<span class="kr">if</span> m - p &lt; <span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> m - p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnNge //= eq_sym subn_eq0 (leq_trans (ltnW mLn)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">leq_minn2r</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">p</span> : m &lt;= n -&gt; minn m p &lt;= minn n p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= n -&gt; minn m p &lt;= minn n p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>409</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mLn; <span class="nb">rewrite</span> /minn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><div><var>mLn</var><span class="hyp-type"><b>:</b><span>m &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> m &lt; p <span class="kr">then</span> m <span class="kr">else</span> p) &lt;= (<span class="kr">if</span> n &lt; p <span class="kr">then</span> n <span class="kr">else</span> p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: leqP =&gt; pLm; <span class="nb">case</span>: leqP =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><q>412</q><div><var>pLm</var><span class="hyp-type"><b>:</b><span>p &lt;= m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; p -&gt; p &lt;= n</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><q>412</q><div><var>pLm</var><span class="hyp-type"><b>:</b><span>m &lt; p</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">p &lt;= n -&gt; m &lt;= p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnNge (leq_trans pLm).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>41c</q><span class="goal-separator"><hr></span><q>41e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> ltnW.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">leq_minn2l</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">p</span> : m &lt;= n -&gt; minn p m &lt;= minn p n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>40b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= n -&gt; minn p m &lt;= minn p n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>423</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; mLn; <span class="nb">rewrite</span> /minn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>411</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> p &lt; m <span class="kr">then</span> p <span class="kr">else</span> m) &lt;= (<span class="kr">if</span> p &lt; n <span class="kr">then</span> p <span class="kr">else</span> n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: leqP =&gt; pLm; <span class="nb">case</span>: leqP =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3de</q><q>412</q><div><var>pLm</var><span class="hyp-type"><b>:</b><span>p &lt; m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= p -&gt; p &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; _; <span class="nb">rewrite</span> (leq_trans (ltnW pLm)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(******************************************************************************)</span>
<span class="c">(* Definiion of discrete convex and concave version                           *)</span>
<span class="c">(*  it contains just what is needed for shanoi4                               *)</span>
<span class="sd">(******************************************************************************)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Convex</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">increasing</span> (<span class="nv">f</span> : nat -&gt; nat) := <span class="kr">forall</span> <span class="nv">n</span>, f n &lt;= f n.+<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">decreasing</span> (<span class="nv">f</span> : nat -&gt; nat) := <span class="kr">forall</span> <span class="nv">n</span>, f n.+<span class="mi">1</span> &lt;= f n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">increasing_ext</span> <span class="nv">f1</span> <span class="nv">f2</span> : f1 =<span class="mi">1</span> f2 -&gt; increasing f1 -&gt; increasing f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>f1, f2</var><span class="hyp-type"><b>:</b><span>nat -&gt; nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 =<span class="mi">1</span> f2 -&gt; increasing f1 -&gt; increasing f2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>432</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fE fI i; <span class="nb">rewrite</span> -!fE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">increasingE</span> <span class="nv">f</span> <span class="nv">m</span> <span class="nv">n</span> : increasing f -&gt; m &lt;= n -&gt; f m &lt;= f n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt; m &lt;= n -&gt; f m &lt;= f n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>439</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI mLn; <span class="nb">rewrite</span> -(subnK mLn).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><div><var>fI</var><span class="hyp-type"><b>:</b><span>increasing f</span></span></div><q>412</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f m &lt;= f (n - m + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: (_ - _) =&gt; //= d fL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><q>442</q><q>412</q><div><var>d</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>fL</var><span class="hyp-type"><b>:</b><span>f m &lt;= f (d + m)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f m &lt;= f (d.+<span class="mi">1</span> + m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans (fI (d + m)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">decreasingE</span> <span class="nv">f</span> <span class="nv">m</span> <span class="nv">n</span> : decreasing f -&gt; m &lt;= n -&gt; f n &lt;= f m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>43b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">decreasing f -&gt; m &lt;= n -&gt; f n &lt;= f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>44c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI mLn; <span class="nb">rewrite</span> -(subnK mLn).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><div><var>fI</var><span class="hyp-type"><b>:</b><span>decreasing f</span></span></div><q>412</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (n - m + m) &lt;= f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: (_ - _) =&gt; //= d fL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><q>454</q><q>412</q><q>448</q><div><var>fL</var><span class="hyp-type"><b>:</b><span>f (d + m) &lt;= f m</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (d.+<span class="mi">1</span> + m) &lt;= f m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans (fI _) fL.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">delta</span> (<span class="nv">f</span> : nat -&gt; nat) <span class="nv">n</span> := f n.+<span class="mi">1</span> - f n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_ext</span> <span class="nv">f1</span> <span class="nv">f2</span> : f1 =<span class="mi">1</span> f2 -&gt; delta f1 =<span class="mi">1</span> delta f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>434</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 =<span class="mi">1</span> f2 -&gt; delta f1 =<span class="mi">1</span> delta f2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>45d</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fE i; <span class="nb">rewrite</span> /delta !fE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fnorm</span> (<span class="nv">f</span> : nat -&gt; nat) <span class="nv">n</span> := f n - f <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">increasing_fnorm</span> <span class="nv">f</span> : increasing f -&gt; increasing (fnorm f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt; increasing (fnorm f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>462</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fI n; <span class="nb">rewrite</span> leq_sub2r.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_fnorm</span> <span class="nv">f</span> <span class="nv">n</span> : increasing f -&gt; delta (fnorm f) n = delta f n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt; delta (fnorm f) n = delta f n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>468</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fI; <span class="nb">rewrite</span> /delta /fnorm -subnDA addnC subnK // increasingE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_delta</span> <span class="nv">f</span> <span class="nv">n</span> : 
increasing f -&gt; fnorm f n = \sum_(i &lt; n) delta (fnorm f) i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>46a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
fnorm f n = \sum_(i &lt; n) delta (fnorm f) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>46e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; iF.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q><div><var>iF</var><span class="hyp-type"><b>:</b><span>increasing f</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fnorm f n = \sum_(i &lt; n) delta (fnorm f) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n =&gt; [|n IH]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> [LHS]subnn big_ord0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>476</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>fnorm f n = \sum_(i &lt; n) delta (fnorm f) i</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fnorm f n.+<span class="mi">1</span> = \sum_(i &lt; n.+<span class="mi">1</span>) delta (fnorm f) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr /= -IH addnC subnK // increasing_fnorm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* we restrict this to increasing function because of the behavior -*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">convex</span> <span class="nv">f</span> :=
  increasing f /\ increasing (delta f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* we restrict this to increasing function because of the behavior -*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">concave</span> <span class="nv">f</span> :=
  increasing f /\ decreasing (delta f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">concaveE</span> <span class="nv">f</span> : 
  increasing f -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, f i + f i.+<span class="mi">2</span> &lt;= (f i.+<span class="mi">1</span>).*<span class="mi">2</span>) -&gt; concave f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>464</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
(<span class="kr">forall</span> <span class="nv">i</span> : nat, f i + f i.+<span class="mi">2</span> &lt;= (f i.+<span class="mi">1</span>).*<span class="mi">2</span>) -&gt;
concave f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>47f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI fH; <span class="nb">split</span> =&gt; // i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>442</q><div><var>fH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, f i + f i.+<span class="mi">2</span> &lt;= (f i.+<span class="mi">1</span>).*<span class="mi">2</span></span></span></div><div><var>i</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta f i.+<span class="mi">1</span> &lt;= delta f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>486</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i.+<span class="mi">2</span> - f i.+<span class="mi">1</span> &lt;= f i.+<span class="mi">1</span> - f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(leq_add2r (f i.+<span class="mi">1</span> + f i)) addnA subnK // addnCA subnK //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>486</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i.+<span class="mi">2</span> + f i &lt;= f i.+<span class="mi">1</span> + f i.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> addnn addnC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">concaveEk</span> <span class="nv">f</span> <span class="nv">i</span> <span class="nv">k</span> : 
  concave f -&gt; k &lt;= i -&gt; f (i - k) + f (i + k) &lt;= (f i).*<span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><div><var>i, k</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concave f -&gt;
k &lt;= i -&gt; f (i - k) + f (i + k) &lt;= (f i).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>493</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [fI dfD].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>496</q><q>442</q><div><var>dfD</var><span class="hyp-type"><b>:</b><span>decreasing (delta f)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt;= i -&gt; f (i - k) + f (i + k) &lt;= (f i).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: k =&gt; /= [kLi|k IH kLi]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subn0 addn0 addnn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>49d</q><div><var>k</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span>k &lt;= i -&gt; f (i - k) + f (i + k) &lt;= (f i).*<span class="mi">2</span></span></span></div><div><var>kLi</var><span class="hyp-type"><b>:</b><span>k &lt; i</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>) &lt;= (f i).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> H : i - k.+<span class="mi">1</span> &lt;= i + k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4a2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">i - k.+<span class="mi">1</span> &lt;= i + k</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>49d</q><q>4a3</q><q>4a4</q><q>4a5</q><div><var>H</var><span class="hyp-type"><b>:</b><span>i - k.+<span class="mi">1</span> &lt;= i + k</span></span></div></div><label class="goal-separator"><hr></label><q>4a6</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans (leq_subr _ _) (leq_addr _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4ad</q><span class="goal-separator"><hr></span><q>4a6</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> fk1Lfk : f (i - k.+<span class="mi">1</span>) &lt;= f (i - k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i - k.+<span class="mi">1</span>) &lt;= f (i - k)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>49d</q><q>4a3</q><q>4a4</q><q>4a5</q><q>4ae</q><div><var>fk1Lfk</var><span class="hyp-type"><b>:</b><span>f (i - k.+<span class="mi">1</span>) &lt;= f (i - k)</span></span></div></div><label class="goal-separator"><hr></label><q>4a6</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/(increasingE fI)/leq_sub2l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b8</q><span class="goal-separator"><hr></span><q>4a6</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := leq_add (decreasingE dfD H) (IH (ltnW kLi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">delta f (i + k) + (f (i - k) + f (i + k)) &lt;=
delta f (i - k.+<span class="mi">1</span>) + (f i).*<span class="mi">2</span> -&gt;
f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>) &lt;= (f i).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /delta [f (i - k) + _]addnC addnA subnK <span class="nl">?fU</span> // addnC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i - k) + f (i + k).+<span class="mi">1</span> &lt;=
f (i - k.+<span class="mi">1</span>).+<span class="mi">1</span> - f (i - k.+<span class="mi">1</span>) + (f i).*<span class="mi">2</span> -&gt;
f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>) &lt;= (f i).*<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -subSn // subSS addnBAC // leq_subRL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i - k.+<span class="mi">1</span>) + (f (i - k) + f (i + k).+<span class="mi">1</span>) &lt;=
f (i - k) + (f i).*<span class="mi">2</span> -&gt;
f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>) &lt;= (f i).*<span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4b8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f (i - k.+<span class="mi">1</span>) &lt;= f (i - k) + (f i).*<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> addnCA leq_add2l addnS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b8</q><span class="goal-separator"><hr></span><q>4cb</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans fk1Lfk (leq_addr _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">concaveEk1</span> (<span class="nv">f</span> : nat -&gt; nat) (<span class="nv">i</span> <span class="nv">k1</span> <span class="nv">k2</span> : nat) :
  concave f -&gt; f (i + k1 + k2) + f i &lt;= f (i + k2) + f (i + k1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><div><var>i, k1, k2</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">concave f -&gt;
f (i + k1 + k2) + f i &lt;= f (i + k2) + f (i + k1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4d0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fC; <span class="nb">have</span> [fI dfD] := fC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>4d3</q><div><var>fC</var><span class="hyp-type"><b>:</b><span>concave f</span></span></div><q>442</q><q>49d</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i + k1 + k2) + f i &lt;= f (i + k2) + f (i + k1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: k2 k1 i =&gt; [k1 i|k2 IHH k1 i]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> !addn0 addnC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>4da</q><q>442</q><q>49d</q><div><var>k2</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>IHH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">k1</span> <span class="nv">i</span> : nat, f (i + k1 + k2) + f i &lt;= f (i + k2) + f (i + k1)</span></span></div><div><var>k1, i</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i + k1 + k2.+<span class="mi">1</span>) + f i &lt;= f (i + k2.+<span class="mi">1</span>) + f (i + k1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> !addnS -(subnK (fI _)) -[X <span class="kr">in</span> _ &lt;= X + _](subnK (fI _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4df</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i + k1 + k2).+<span class="mi">1</span> - f (i + k1 + k2) + f (i + k1 + k2) +
f i &lt;=
f (i + k2).+<span class="mi">1</span> - f (i + k2) + f (i + k2) + f (i + k1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -addnA -[X <span class="kr">in</span> _ &lt;= X]addnA leq_add //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4df</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i + k1 + k2).+<span class="mi">1</span> - f (i + k1 + k2) &lt;=
f (i + k2).+<span class="mi">1</span> - f (i + k2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (decreasingE dfD); <span class="nb">rewrite</span> addnAC leq_addr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">convexE</span> <span class="nv">f</span> : 
  increasing f -&gt; (<span class="kr">forall</span> <span class="nv">i</span>, (f i.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= f i + f i.+<span class="mi">2</span>) -&gt; convex f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>464</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
(<span class="kr">forall</span> <span class="nv">i</span> : nat, (f i.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= f i + f i.+<span class="mi">2</span>) -&gt;
convex f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4ed</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI fH; <span class="nb">split</span> =&gt; // i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>442</q><div><var>fH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, (f i.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= f i + f i.+<span class="mi">2</span></span></span></div><q>488</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta f i &lt;= delta f i.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i.+<span class="mi">1</span> - f i &lt;= f i.+<span class="mi">2</span> - f i.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(leq_add2r (f i.+<span class="mi">1</span> + f i)) [_ + f i]addnC addnA subnK //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f4</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i.+<span class="mi">1</span> + f i.+<span class="mi">1</span> &lt;= f i.+<span class="mi">2</span> - f i.+<span class="mi">1</span> + (f i + f i.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> addnn [f i + _]addnC addnA subnK // addnC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">convexEk</span> <span class="nv">f</span> <span class="nv">i</span> <span class="nv">k</span> : 
  convex f -&gt; k &lt;= i -&gt; (f i).*<span class="mi">2</span> &lt;= f (i - k) + f (i + k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>495</q><span class="goal-separator"><hr></span><div class="goal-conclusion">convex f -&gt;
k &lt;= i -&gt; (f i).*<span class="mi">2</span> &lt;= f (i - k) + f (i + k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>500</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [fI dfI].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>496</q><q>442</q><div><var>dfI</var><span class="hyp-type"><b>:</b><span>increasing (delta f)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt;= i -&gt; (f i).*<span class="mi">2</span> &lt;= f (i - k) + f (i + k)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: k =&gt; /= [kLi|k IH kLi]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> subn0 addn0 addnn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>508</q><q>4a3</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>k &lt;= i -&gt; (f i).*<span class="mi">2</span> &lt;= f (i - k) + f (i + k)</span></span></div><q>4a5</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f i).*<span class="mi">2</span> &lt;= f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> H : i - k.+<span class="mi">1</span> &lt;= i + k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>50d</q><span class="goal-separator"><hr></span><q>4aa</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>508</q><q>4a3</q><q>50e</q><q>4a5</q><q>4ae</q></div><label class="goal-separator"><hr></label><q>50f</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_trans (leq_subr _ _) (leq_addr _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>515</q><span class="goal-separator"><hr></span><q>50f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> fk1Lfk : f (i - k.+<span class="mi">1</span>) &lt;= f (i - k).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>515</q><span class="goal-separator"><hr></span><q>4b5</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>488</q><q>442</q><q>508</q><q>4a3</q><q>50e</q><q>4a5</q><q>4ae</q><q>4b9</q></div><label class="goal-separator"><hr></label><q>50f</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/(increasingE fI)/leq_sub2l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>51e</q><span class="goal-separator"><hr></span><q>50f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span> := leq_add (increasingE dfI H) (IH (ltnW kLi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>51e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">delta f (i - k.+<span class="mi">1</span>) + (f i).*<span class="mi">2</span> &lt;=
delta f (i + k) + (f (i - k) + f (i + k)) -&gt;
(f i).*<span class="mi">2</span> &lt;= f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /delta [f (i - k) + _]addnC addnA subnK <span class="nl">?fU</span> // addnC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>51e</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(f i).*<span class="mi">2</span> + (f (i - k.+<span class="mi">1</span>).+<span class="mi">1</span> - f (i - k.+<span class="mi">1</span>)) &lt;=
f (i + k).+<span class="mi">1</span> + f (i - k) -&gt;
(f i).*<span class="mi">2</span> &lt;= f (i - k.+<span class="mi">1</span>) + f (i + k.+<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -subSn // subSS addnS addnBA // leq_subLR addnA leq_add2r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Ad-hoc bigmin operator *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bigmin</span> <span class="nv">f</span> <span class="nv">n</span> := 
 <span class="kr">if</span> n <span class="kr">is</span> n1.+<span class="mi">1</span> <span class="kr">then</span> minn (f n) (bigmin f n1)
 <span class="kr">else</span> f <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\min_ ( i &lt;= n ) F&quot;</span> := (bigmin (<span class="kr">fun</span> <span class="nv">i</span> =&gt; F) n)
 (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, n <span class="kn">at level</span> <span class="mi">50</span>,
  <span class="kn">format</span> <span class="s2">&quot;\min_ ( i  &lt;=  n )  F&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_constD</span>  <span class="nv">f</span> <span class="nv">n</span> <span class="nv">k</span> :
 \min_(i &lt;= n) (f i + k) =  (\min_(i &lt;= n) f i) + k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>354</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (f i + k) = \min_(i &lt;= n) f i + k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>52b</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: n =&gt; //=  n -&gt;; <span class="nb">rewrite</span> addn_minl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_constB</span>  <span class="nv">f</span> <span class="nv">n</span> <span class="nv">k</span> :
 \min_(i &lt;= n) (f i - k) =  (\min_(i &lt;= n) f i) - k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>52d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (f i - k) = \min_(i &lt;= n) f i - k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>531</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: n =&gt; //=  n -&gt;; <span class="nb">rewrite</span> subn_minr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">eq_bigmin</span> <span class="nv">f</span> <span class="nv">n</span> : {i0 : &#39;I_n.+<span class="mi">1</span> | \min_(i &lt;= n) f i = f i0}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>46a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">{i0 : &#39;I_n.+<span class="mi">1</span> | \min_(i &lt;= n) f i = f i0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>536</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n =&gt; /= [|n [i -&gt;]]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">ord0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q><div><var>i</var><span class="hyp-type"><b>:</b><span>&#39;I_n.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{i0 : &#39;I_n.+<span class="mi">2</span> | minn (f n.+<span class="mi">1</span>) (f i) = f i0}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /minn; <span class="nb">case</span>: leqP =&gt; H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q><q>53e</q><div><var>H</var><span class="hyp-type"><b>:</b><span>f i &lt;= f n.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{i0 : &#39;I_n.+<span class="mi">2</span> | f i = f i0}</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>127</q><q>53e</q><div><var>H</var><span class="hyp-type"><b>:</b><span>f n.+<span class="mi">1</span> &lt; f i</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">{i0 : &#39;I_n.+<span class="mi">2</span> | f n.+<span class="mi">1</span> = f i0}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">inord</span> <span class="nv">i</span>); <span class="nb">rewrite</span> inordK // (leq_trans (ltn_ord i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>548</q><span class="goal-separator"><hr></span><q>54a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">ord_max</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_leqP</span> <span class="nv">f</span> <span class="nv">n</span> <span class="nv">m</span> :
  reflect (<span class="kr">forall</span> <span class="nv">i</span>, i &lt;= n -&gt; m &lt;= f i) 
          (m &lt;= \min_(i &lt;= n) f i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>2a3</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n -&gt; m &lt;= f i)
  (m &lt;= \min_(i &lt;= n) f i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>54f</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n =&gt; /= [|n IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><div><var>m</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= <span class="mi">0</span> -&gt; m &lt;= f i)
  (m &lt;= f <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>reflect (<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n -&gt; m &lt;= f i)
  (m &lt;= \min_(i &lt;= n) f i)</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">reflect (<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n.+<span class="mi">1</span> -&gt; m &lt;= f i)
  (m &lt;= minn (f n.+<span class="mi">1</span>) (\min_(i &lt;= n) f i))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (iffP idP) =&gt; [mLf0 [|i] //|-&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>55c</q><span class="goal-separator"><hr></span><q>55e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: (iffP idP) =&gt; [|H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>55c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= minn (f n.+<span class="mi">1</span>) (\min_(i &lt;= n) f i) -&gt;
<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n.+<span class="mi">1</span> -&gt; m &lt;= f i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><q>55d</q><div><var>H</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n.+<span class="mi">1</span> -&gt; m &lt;= f i</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">m &lt;= minn (f n.+<span class="mi">1</span>) (\min_(i &lt;= n) f i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> leq_min =&gt; /andP[mLf mLmin] i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><q>55d</q><div><var>mLf</var><span class="hyp-type"><b>:</b><span>m &lt;= f n.+<span class="mi">1</span></span></span></div><div><var>mLmin</var><span class="hyp-type"><b>:</b><span>m &lt;= \min_(i &lt;= n) f i</span></span></div><q>488</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt;= n.+<span class="mi">1</span> -&gt; m &lt;= f i</div></blockquote><q>566</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: ltngtP =&gt; // [iLn _|-&gt; _ //].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>10d</q><q>55d</q><q>56f</q><q>570</q><q>488</q><div><var>iLn</var><span class="hyp-type"><b>:</b><span>i &lt; n.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= f i</div></blockquote><q>566</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ltnS <span class="kr">in</span> iLn; <span class="nb">move</span>: i iLn; <span class="nb">apply</span>/IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>568</q><span class="goal-separator"><hr></span><q>56a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> leq_min H //=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>568</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= \min_(i &lt;= n) f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>/IH =&gt; i iLn; <span class="nb">rewrite</span> H // (leq_trans iLn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_inf</span> <span class="nv">f</span> <span class="nv">n</span> <span class="nv">i0</span> <span class="nv">m</span> :
  i0 &lt;= n -&gt; f i0 &lt;= m -&gt; \min_(i &lt;= n) f i &lt;= m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><div><var>n, i0, m</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i0 &lt;= n -&gt; f i0 &lt;= m -&gt; \min_(i &lt;= n) f i &lt;= m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>580</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; i0Ln fi0Lm; <span class="nb">apply</span>: leq_trans fi0Lm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><q>583</q><div><var>i0Ln</var><span class="hyp-type"><b>:</b><span>i0 &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) f i &lt;= f i0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i0Ln =&gt; /= [|n IH]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: i0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>379</q><div><var>i0, m, n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>IH</var><span class="hyp-type"><b>:</b><span>i0 &lt;= n -&gt; \min_(i &lt;= n) f i &lt;= f i0</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i0 &lt;= n.+<span class="mi">1</span> -&gt;
minn (f n.+<span class="mi">1</span>) (\min_(i &lt;= n) f i) &lt;= f i0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: ltngtP =&gt; // [i0Ln _| -&gt; _]; <span class="nb">rewrite</span> geq_min <span class="nl">?leqnn</span> <span class="nl">?IH</span> <span class="nl">?orbT</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_fnorm</span> <span class="nv">f</span> <span class="nv">n</span> : \min_(i &lt;= n) fnorm f i = fnorm (bigmin f) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>46a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) fnorm f i = fnorm (bigmin f) n</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>594</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: n =&gt; //= n -&gt;; <span class="nb">rewrite</span> -subn_minr.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigmin_ext</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="nv">n</span> : 
  (<span class="kr">forall</span> <span class="nv">i</span>, i &lt;= n -&gt; f1 i = f2 i) -&gt; \min_(i &lt;= n) f1 i = \min_(i &lt;= n) f2 i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>435</q><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n -&gt; f1 i = f2 i) -&gt;
\min_(i &lt;= n) f1 i = \min_(i &lt;= n) f2 i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>599</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n =&gt; /= [-&gt;//|n IH H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>435</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span>(<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n -&gt; f1 i = f2 i) -&gt;
\min_(i &lt;= n) f1 i = \min_(i &lt;= n) f2 i</span></span></div><div><var>H</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt;= n.+<span class="mi">1</span> -&gt; f1 i = f2 i</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f1 n.+<span class="mi">1</span>) (\min_(i &lt;= n) f1 i) =
minn (f2 n.+<span class="mi">1</span>) (\min_(i &lt;= n) f2 i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> H // IH // =&gt; i iH; <span class="nb">rewrite</span> H // (leq_trans iH).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bigminMr</span>  <span class="nv">f</span> <span class="nv">n</span> <span class="nv">k</span> :
 \min_(i &lt;= n) (f i * k) =  (\min_(i &lt;= n) f i) * k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>52d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) f i * k = (\min_(i &lt;= n) f i) * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5a6</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">elim</span>: n =&gt; //= n -&gt;; <span class="nb">rewrite</span>  minnMl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Convolution *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">conv</span> (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; nat) <span class="nv">n</span> :=
  \min_(i &lt;= n) (f i + g (n - i)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">conv0</span> <span class="nv">f</span> <span class="nv">g</span> : conv f g <span class="mi">0</span> = f <span class="mi">0</span> + g <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>f, g</var><span class="hyp-type"><b>:</b><span>nat -&gt; nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g <span class="mi">0</span> = f <span class="mi">0</span> + g <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5ab</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">conv1</span> <span class="nv">f</span> <span class="nv">g</span> : 
  conv f g <span class="mi">1</span> = minn (f <span class="mi">1</span> + g <span class="mi">0</span>) (f <span class="mi">0</span> + g <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g <span class="mi">1</span> = minn (f <span class="mi">1</span> + g <span class="mi">0</span>) (f <span class="mi">0</span> + g <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5b2</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">conv_fnorm</span> <span class="nv">f</span> <span class="nv">g</span> : 
  increasing f -&gt; increasing g -&gt; 
  conv (fnorm f) (fnorm g) =<span class="mi">1</span> fnorm (conv f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
conv (fnorm f) (fnorm g) =<span class="mi">1</span> fnorm (conv f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5b7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><div><var>gI</var><span class="hyp-type"><b>:</b><span>increasing g</span></span></div><q>488</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conv (fnorm f) (fnorm g) i = fnorm (conv f g) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /fnorm /conv /= -bigmin_constB subnn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5be</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i0 &lt;= i) (f i0 - f <span class="mi">0</span> + (g (i - i0) - g <span class="mi">0</span>)) =
\min_(i0 &lt;= i) (f i0 + g (i - i0) - (f <span class="mi">0</span> + g <span class="mi">0</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: bigmin_ext =&gt; j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><div><var>i, j</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j &lt;= i -&gt;
f j - f <span class="mi">0</span> + (g (i - j) - g <span class="mi">0</span>) =
f j + g (i - j) - (f <span class="mi">0</span> + g <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> addnBA <span class="nl">?increasingE</span> // addnBAC <span class="nl">?increasingE</span> // subnDA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">conv_ext</span> <span class="nv">f1</span> <span class="nv">g1</span> <span class="nv">f2</span> <span class="nv">g2</span> : f1 =<span class="mi">1</span> f2 -&gt; g1 =<span class="mi">1</span> g2 -&gt; conv f1 g1 =<span class="mi">1</span> conv f2 g2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>f1, g1, f2, g2</var><span class="hyp-type"><b>:</b><span>nat -&gt; nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 =<span class="mi">1</span> f2 -&gt; g1 =<span class="mi">1</span> g2 -&gt; conv f1 g1 =<span class="mi">1</span> conv f2 g2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5cc</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fE gE i; <span class="nb">apply</span>: bigmin_ext =&gt; j; <span class="nb">rewrite</span> fE gE.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">convC</span> <span class="nv">f</span> <span class="nv">g</span> : conv f g =<span class="mi">1</span> conv g f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g =<span class="mi">1</span> conv g f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5d3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; n; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> /conv eqn_leq; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (f i + g (n - i)) &lt;=
\min_(i &lt;= n) (g i + f (n - i))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>5da</q><label class="goal-separator"><hr></label><div class="goal-conclusion">\min_(i &lt;= n) (g i + f (n - i)) &lt;=
\min_(i &lt;= n) (f i + g (n - i))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmin_leqP =&gt; i iLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><div><var>n, i</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>iLn</var><span class="hyp-type"><b>:</b><span>i &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (f i + g (n - i)) &lt;= g i + f (n - i)</div></blockquote><q>5dc</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -{<span class="mi">1</span>}(subKn iLn) addnC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (f i + g (n - i)) &lt;=
f (n - i) + g (n - (n - i))</div></blockquote><q>5dc</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: bigmin_inf (leq_subr _ _) (leqnn _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><q>5de</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmin_leqP =&gt; i iLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (g i + f (n - i)) &lt;= f i + g (n - i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -{<span class="mi">1</span>}(subKn iLn) addnC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5e2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\min_(i &lt;= n) (g i + f (n - i)) &lt;=
g (n - i) + f (n - (n - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: bigmin_inf (leq_subr _ _) (leqnn _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">increasing_conv</span> <span class="nv">f</span> <span class="nv">g</span> : 
  increasing f -&gt; increasing g -&gt; increasing (conv f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt; increasing g -&gt; increasing (conv f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>5f6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5be</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g i &lt;= conv f g i.+<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmin_leqP =&gt; j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">j &lt;= i.+<span class="mi">1</span> -&gt; conv f g i &lt;= f j + g (i.+<span class="mi">1</span> - j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: ltngtP =&gt; // [jLi | -&gt;] _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>5c9</q><div><var>jLi</var><span class="hyp-type"><b>:</b><span>j &lt; i.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g i &lt;= f j + g (i.+<span class="mi">1</span> - j)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>5c8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">conv f g i &lt;= f i.+<span class="mi">1</span> + g (i.+<span class="mi">1</span> - i.+<span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: bigmin_inf (_ : j &lt;= i) _; <span class="nb">rewrite</span> // leq_add2l subSn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><q>60a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv f g i &lt;= f i.+<span class="mi">1</span> + g <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: bigmin_inf (leqnn i) _; <span class="nb">rewrite</span> subnn leq_add2r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* merging increasing functions *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">fmerge_aux</span> (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; nat) <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> := 
 <span class="kr">if</span> n <span class="kr">is</span> n1.+<span class="mi">1</span> <span class="kr">then</span>
   <span class="kr">if</span> f i &lt; g j <span class="kr">then</span> fmerge_aux f g i.+<span class="mi">1</span> j n1 
   <span class="kr">else</span> fmerge_aux f g i j.+<span class="mi">1</span> n1
 <span class="kr">else</span> minn (f i) (g j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fmerge</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> := fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmerge_aux_ext</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="nv">g1</span> <span class="nv">g2</span> <span class="nv">i</span> <span class="nv">j</span> : f1 =<span class="mi">1</span> f2 -&gt; g1 =<span class="mi">1</span> g2 -&gt; 
  fmerge_aux f1 g1 i j =<span class="mi">1</span> fmerge_aux f2 g2 i j.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div><var>f1, f2, g1, g2</var><span class="hyp-type"><b>:</b><span>nat -&gt; nat</span></span></div><q>5c9</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 =<span class="mi">1</span> f2 -&gt;
g1 =<span class="mi">1</span> g2 -&gt;
fmerge_aux f1 g1 i j =<span class="mi">1</span> fmerge_aux f2 g2 i j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>613</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fE gE n; <span class="nb">elim</span>: n i j =&gt; /= [i1 j1|n IH i j]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> fE gE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>616</q><div><var>fE</var><span class="hyp-type"><b>:</b><span>f1 =<span class="mi">1</span> f2</span></span></div><div><var>gE</var><span class="hyp-type"><b>:</b><span>g1 =<span class="mi">1</span> g2</span></span></div><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
fmerge_aux f1 g1 i j n = fmerge_aux f2 g2 i j n</span></span></div><q>5c9</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> f1 i &lt; g1 j
 <span class="kr">then</span> fmerge_aux f1 g1 i.+<span class="mi">1</span> j n
 <span class="kr">else</span> fmerge_aux f1 g1 i j.+<span class="mi">1</span> n) =
(<span class="kr">if</span> f2 i &lt; g2 j
 <span class="kr">then</span> fmerge_aux f2 g2 i.+<span class="mi">1</span> j n
 <span class="kr">else</span> fmerge_aux f2 g2 i j.+<span class="mi">1</span> n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !(fE, gE, IH).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmerge_ext</span> <span class="nv">f1</span> <span class="nv">f2</span> <span class="nv">g1</span> <span class="nv">g2</span> : f1 =<span class="mi">1</span> f2 -&gt; g1 =<span class="mi">1</span> g2 -&gt; 
  fmerge f1 g1 =<span class="mi">1</span> fmerge f2 g2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>616</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 =<span class="mi">1</span> f2 -&gt; g1 =<span class="mi">1</span> g2 -&gt; fmerge f1 g1 =<span class="mi">1</span> fmerge f2 g2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>622</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; fE gE n; <span class="nb">apply</span>: fmerge_aux_ext.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmerge_aux_correct</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> :
  increasing f -&gt; increasing g -&gt; 
  (<span class="kr">forall</span> <span class="nv">k</span>, k &lt;= n -&gt;  
     minn (f (i + k)) (g (j + (n - k))) &lt;=  
     fmerge_aux f g i j n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><div><var>i, j, n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
<span class="kr">forall</span> <span class="nv">k</span> : nat,
k &lt;= n -&gt;
minn (f (i + k)) (g (j + (n - k))) &lt;=
fmerge_aux f g i j n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>628</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>62b</q><q>442</q><q>5bf</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : nat,
k &lt;= n -&gt;
minn (f (i + k)) (g (j + (n - k))) &lt;=
fmerge_aux f g i j n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i j =&gt; /= [i j [|] // _|n IH i j k kLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f (i + <span class="mi">0</span>)) (g (j + (<span class="mi">0</span> - <span class="mi">0</span>))) &lt;= minn (f i) (g j)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">k</span> : nat,
k &lt;= n -&gt;
minn (f (i + k)) (g (j + (n - k))) &lt;=
fmerge_aux f g i j n</span></span></div><div><var>i, j, k</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt;= n.+<span class="mi">1</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k))) &lt;=
(<span class="kr">if</span> f i &lt; g j
 <span class="kr">then</span> fmerge_aux f g i.+<span class="mi">1</span> j n
 <span class="kr">else</span> fmerge_aux f g i j.+<span class="mi">1</span> n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !addn0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>639</q><span class="goal-separator"><hr></span><q>63d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: leqP =&gt; [gLf|fLg].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>63b</q><q>63c</q><div><var>gLf</var><span class="hyp-type"><b>:</b><span>g j &lt;= f i</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k))) &lt;=
fmerge_aux f g i j.+<span class="mi">1</span> n</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>63b</q><q>63c</q><div><var>fLg</var><span class="hyp-type"><b>:</b><span>f i &lt; g j</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k))) &lt;=
fmerge_aux f g i.+<span class="mi">1</span> j n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: kLn; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP-&gt;|kLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>63b</q><q>645</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f (i + n.+<span class="mi">1</span>)) (g (j + (n.+<span class="mi">1</span> - n.+<span class="mi">1</span>))) &lt;=
fmerge_aux f g i j.+<span class="mi">1</span> n</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>63b</q><q>645</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt; n.+<span class="mi">1</span></span></span></div></div><label class="goal-separator"><hr></label><q>646</q></blockquote><q>648</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn addn0 (minn_idPr _); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j &lt;= f (i + n.+<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>64f</q><label class="goal-separator"><hr></label><div class="goal-conclusion">g j &lt;= fmerge_aux f g i j.+<span class="mi">1</span> n</div></blockquote><q>652</q><q>648</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans gLf) // increasingE // leq_addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64f</q><span class="goal-separator"><hr></span><q>65b</q></blockquote><q>651</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (IH _ _ _ (leqnn _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j &lt;= minn (f (i + n)) (g (j.+<span class="mi">1</span> + (n - n)))</div></blockquote><q>651</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn addn0 leq_min increasingE // andbT (leq_trans gLf) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>64f</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i &lt;= f (i + n)</div></blockquote><q>651</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> increasingE // leq_addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>653</q><span class="goal-separator"><hr></span><q>646</q></blockquote><q>647</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> subSn // -addSnnS IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>649</q><span class="goal-separator"><hr></span><q>64b</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: k kLn =&gt; [_ | k kLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>5c9</q><q>64a</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f (i + <span class="mi">0</span>)) (g (j + (n.+<span class="mi">1</span> - <span class="mi">0</span>))) &lt;=
fmerge_aux f g i.+<span class="mi">1</span> j n</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>63a</q><q>5c9</q><q>64a</q><q>4a3</q><q>654</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">minn (f (i + k.+<span class="mi">1</span>)) (g (j + (n.+<span class="mi">1</span> - k.+<span class="mi">1</span>))) &lt;=
fmerge_aux f g i.+<span class="mi">1</span> j n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> addn0 subn0 (minn_idPl _); <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>670</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i &lt;= g (j + n.+<span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>670</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f i &lt;= fmerge_aux f g i.+<span class="mi">1</span> j n</div></blockquote><q>673</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (ltnW fLg)) // increasingE // leq_addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>670</q><span class="goal-separator"><hr></span><q>67c</q></blockquote><q>672</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (IH i.+<span class="mi">1</span> j <span class="mi">0</span> isT).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>670</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i &lt;= minn (f (i.+<span class="mi">1</span> + <span class="mi">0</span>)) (g (j + (n - <span class="mi">0</span>)))</div></blockquote><q>672</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> addn0 leq_min increasingE //= (leq_trans (ltnW fLg)) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>670</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j &lt;= g (j + (n - <span class="mi">0</span>))</div></blockquote><q>672</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> increasingE // leq_addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>674</q><span class="goal-separator"><hr></span><q>675</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> subSS -addSnnS IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmerge_aux_exist</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> :
  <span class="kr">exists2</span> k, k &lt;= n &amp; fmerge_aux f g i j n = minn (f (i + k)) (g (j + (n - k))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>62a</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n &amp;
  fmerge_aux f g i j n =
  minn (f (i + k)) (g (j + (n - k)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>68c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i j =&gt; /= [i j | n IH i j]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">rewrite</span> //= !addn0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
<span class="kr">exists2</span> k : nat,
  k &lt;= n &amp;
  fmerge_aux f g i j n =
  minn (f (i + k)) (g (j + (n - k)))</span></span></div><q>5c9</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  (<span class="kr">if</span> f i &lt; g j
   <span class="kr">then</span> fmerge_aux f g i.+<span class="mi">1</span> j n
   <span class="kr">else</span> fmerge_aux f g i j.+<span class="mi">1</span> n) =
  minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (leqP (g j) (f i)) =&gt; [gLf|fLg]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>694</q><q>5c9</q><q>64a</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  fmerge_aux f g i.+<span class="mi">1</span> j n =
  minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k)))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>694</q><q>5c9</q><q>645</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  fmerge_aux f g i j.+<span class="mi">1</span> n =
  minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: (IH i.+<span class="mi">1</span> j) =&gt; k kLn -&gt;; <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span>; <span class="nb">rewrite</span> // addnS subSS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>69d</q><span class="goal-separator"><hr></span><q>69e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (IH i j.+<span class="mi">1</span>) =&gt; [] [|k] kLn -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>694</q><q>5c9</q><q>645</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span><span class="mi">0</span> &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  minn (f (i + <span class="mi">0</span>)) (g (j.+<span class="mi">1</span> + (n - <span class="mi">0</span>))) =
  minn (f (i + k)) (g (j + (n.+<span class="mi">1</span> - k)))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>694</q><q>5c9</q><q>645</q><q>4a3</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt; n</span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">ex2 (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt;= n.+<span class="mi">1</span>)
  (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt;
   minn (f (i + k.+<span class="mi">1</span>)) (g (j.+<span class="mi">1</span> + (n - k.+<span class="mi">1</span>))) =
   minn (f (i + k0)) (g (j + (n.+<span class="mi">1</span> - k0))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">rewrite</span> // addn0 !subn0 addnS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6aa</q><span class="goal-separator"><hr></span><q>6ac</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span>; <span class="nb">rewrite</span> ?(leq_trans kLn) // addSnnS -subSn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmergeE</span> (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; nat) <span class="nv">n</span> : 
 increasing f -&gt; increasing g -&gt;
 fmerge f g n = \max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
fmerge f g n = \max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6b1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>442</q><q>5bf</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fmerge f g n = \max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> /fmerge eqn_leq; <span class="nb">apply</span>/andP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n &lt;=
\max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>6b8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">\max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i)) &lt;=
fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (@fmerge_aux_exist f g <span class="mi">0</span> <span class="mi">0</span> n) =&gt; // i1 i1Ln -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>442</q><q>5bf</q><div><var>i1</var><span class="hyp-type"><b>:</b><span>nat</span></span></div><div><var>i1Ln</var><span class="hyp-type"><b>:</b><span>i1 &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f (<span class="mi">0</span> + i1)) (g (<span class="mi">0</span> + (n - i1))) &lt;=
\max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i))</div></blockquote><q>6be</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (@leq_bigmax_cond _ _ _ (Ordinal (i1Ln : i1 &lt; n.+<span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b8</q><span class="goal-separator"><hr></span><q>6c0</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmax_leqP =&gt; /= i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>442</q><q>5bf</q><q>53e</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f i) (g (n - i)) &lt;= fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: fmerge_aux_correct; <span class="nb">rewrite</span> -<span class="mi">1</span><span class="nl">?ltnS</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">increasing_fmerge</span> <span class="nv">f</span> <span class="nv">g</span> : 
  increasing f -&gt; increasing g -&gt; increasing (fmerge f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt; increasing (fmerge f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6d1</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI n; <span class="nb">rewrite</span> !fmergeE //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">\max_(i &lt; n.+<span class="mi">1</span>) minn (f i) (g (n - i)) &lt;=
\max_(i &lt; n.+<span class="mi">2</span>) minn (f i) (g (n.+<span class="mi">1</span> - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmax_leqP =&gt; /= i _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>53e</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f i) (g (n - i)) &lt;=
\max_(i &lt; n.+<span class="mi">2</span>) minn (f i) (g (n.+<span class="mi">1</span> - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (leq_bigmax_cond _ (isT : xpredT (inord i : &#39;I_n.+<span class="mi">2</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6dd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f i) (g (n - i)) &lt;=
minn (f (inord i)) (g (n.+<span class="mi">1</span> - inord i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> inordK ?(leq_trans (ltn_ord _)) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6dd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f i) (g (n - i)) &lt;= minn (f i) (g (n.+<span class="mi">1</span> - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> leq_min geq_minl /= (leq_trans (geq_minr _ _)) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6dd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g (n - i) &lt;= g (n.+<span class="mi">1</span> - i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: increasingE gI _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>127</q><q>53e</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n - i &lt;= n.+<span class="mi">1</span> - i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> leq_sub2r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">fmerge0</span> <span class="nv">f</span> <span class="nv">g</span> : fmerge f g <span class="mi">0</span> = minn (f <span class="mi">0</span>) (g <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">fmerge f g <span class="mi">0</span> = minn (f <span class="mi">0</span>) (g <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6f1</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">sum_fmerge_aux</span> (<span class="nv">f</span> <span class="nv">g</span> : nat -&gt; nat) <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> := 
 <span class="kr">if</span> n <span class="kr">is</span> n1.+<span class="mi">1</span> <span class="kr">then</span>
   <span class="kr">if</span> f i &lt; g j <span class="kr">then</span> f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n1 
   <span class="kr">else</span> g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n1
 <span class="kr">else</span> minn (f i) (g j).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sum_fmerge</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> := sum_fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_aux_correct</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> <span class="nv">i</span> <span class="nv">j</span> : 
  sum_fmerge_aux f g i j n = \sum_(k &lt; n.+<span class="mi">1</span>) fmerge_aux f g i j k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><div><var>n, i, j</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge_aux f g i j n =
\sum_(k &lt; n.+<span class="mi">1</span>) fmerge_aux f g i j k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>6f6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i j =&gt; //= [i j|n IH i j]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr big_ord0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
sum_fmerge_aux f g i j n =
\sum_(k &lt; n.+<span class="mi">1</span>) fmerge_aux f g i j k</span></span></div><q>5c9</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> f i &lt; g j
 <span class="kr">then</span> f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n
 <span class="kr">else</span> g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n) =
\sum_(k &lt; n.+<span class="mi">2</span>) fmerge_aux f g i j k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recl /= /minn; <span class="nb">case</span>: leqP; <span class="nb">rewrite</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_correct</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> : 
  sum_fmerge f g n = \sum_(k &lt; n.+<span class="mi">1</span>) fmerge f g k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge f g n = \sum_(k &lt; n.+<span class="mi">1</span>) fmerge f g k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>703</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: sum_fmerge_aux_correct.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_aux_conv_correct</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> :
  increasing f -&gt; increasing g -&gt; 
  (<span class="kr">forall</span> <span class="nv">k</span>, k &lt;= n.+<span class="mi">1</span> -&gt; 
    sum_fmerge_aux f g i j n &lt;= 
    \sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>62a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
<span class="kr">forall</span> <span class="nv">k</span> : nat,
k &lt;= n.+<span class="mi">1</span> -&gt;
sum_fmerge_aux f g i j n &lt;=
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>708</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>631</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : nat,
k &lt;= n.+<span class="mi">1</span> -&gt;
sum_fmerge_aux f g i j n &lt;=
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i j =&gt; /= [i j [_|[_|]]//|n IH i j k kLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">minn (f i) (g j) &lt;=
\sum_(l &lt; <span class="mi">0</span>) f (i + l) + \sum_(l &lt; <span class="mi">1</span> - <span class="mi">0</span>) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>5c8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">minn (f i) (g j) &lt;=
\sum_(l &lt; <span class="mi">1</span>) f (i + l) + \sum_(l &lt; <span class="mi">1</span> - <span class="mi">1</span>) g (j + l)</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">k</span> : nat,
k &lt;= n.+<span class="mi">1</span> -&gt;
sum_fmerge_aux f g i j n &lt;=
\sum_(l &lt; k) f (i + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</span></span></div><q>63b</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt;= n.+<span class="mi">2</span></span></span></div></div><label class="goal-separator"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> f i &lt; g j
 <span class="kr">then</span> f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n
 <span class="kr">else</span> g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n) &lt;=
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>711</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr !big_ord0 /= !addn0 !add0n geq_minr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5c8</q><span class="goal-separator"><hr></span><q>716</q></blockquote><div class="alectryon-extra-goals"><q>717</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>71e</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> big_ord_recr !big_ord0 /= !addn0 !add0n geq_minl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>718</q><span class="goal-separator"><hr></span><q>71b</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: leqP =&gt; [gLf|fLg].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>71a</q><q>645</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>71a</q><q>64a</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: kLn; <span class="nb">case</span>: ltngtP =&gt; // [kLn _ |-&gt; _]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>645</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
\sum_(l &lt; n.+<span class="mi">2</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">2</span> - n.+<span class="mi">2</span>) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>645</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt; n.+<span class="mi">2</span></span></span></div></div><label class="goal-separator"><hr></label><q>729</q></blockquote><q>72b</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn big_ord0 addn0 big_ord_recl addn0 /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>731</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
f i + \sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + bump <span class="mi">0</span> i0)</div></blockquote><q>733</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_add =&gt; //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>731</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
\sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + bump <span class="mi">0</span> i0)</div></blockquote><q>733</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /bump /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>731</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
\sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + (<span class="mi">1</span> + i0))</div></blockquote><q>733</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (IH _ _ _ (leqnn _)) _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>731</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(l &lt; n.+<span class="mi">1</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - n.+<span class="mi">1</span>) g (j.+<span class="mi">1</span> + l) &lt;=
\sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + (<span class="mi">1</span> + i0))</div></blockquote><q>733</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn big_ord0 addn0 leq_sum // =&gt; l _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>645</q><div><var>l</var><span class="hyp-type"><b>:</b><span>&#39;I_n.+<span class="mi">1</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i + l) &lt;= f (i + (<span class="mi">1</span> + l))</div></blockquote><q>733</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: increasingE; <span class="nb">rewrite</span> // addnCA leq_addl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>735</q><span class="goal-separator"><hr></span><q>729</q></blockquote><q>72a</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subSn // big_ord_recl addn0 addnCA leq_add2l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>735</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge_aux f g i j.+<span class="mi">1</span> n &lt;=
\sum_(l &lt; k) f (i + l) +
\sum_(i &lt; n.+<span class="mi">1</span> - k) g (j + lift ord0 i)</div></blockquote><q>72a</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (IH _ _ _ (kLn : k &lt;= n.+<span class="mi">1</span>)) _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>735</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(l &lt; k) f (i + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - k) g (j.+<span class="mi">1</span> + l) &lt;=
\sum_(l &lt; k) f (i + l) +
\sum_(i &lt; n.+<span class="mi">1</span> - k) g (j + lift ord0 i)</div></blockquote><q>72a</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> leq_add2l leq_sum // =&gt; l _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>645</q><q>736</q><div><var>l</var><span class="hyp-type"><b>:</b><span>&#39;I_(n.+<span class="mi">1</span> - k)</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (j.+<span class="mi">1</span> + l) &lt;= g (j + lift ord0 l)</div></blockquote><q>72a</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> increasingE //= /bump addnCA add1n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>72c</q><span class="goal-separator"><hr></span><q>72d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>: kLn; <span class="nb">case</span>: ltngtP =&gt; // [kLn _ |-&gt; _]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>64a</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; n.+<span class="mi">2</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">2</span> - n.+<span class="mi">2</span>) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>64a</q><q>736</q></div><label class="goal-separator"><hr></label><q>72d</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn big_ord0 addn0 big_ord_recl addn0 /= leq_add2l /bump /=.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>764</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + (<span class="mi">1</span> + i0))</div></blockquote><q>766</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (IH _ _ _ (leqnn _)) _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>764</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(l &lt; n.+<span class="mi">1</span>) f (i.+<span class="mi">1</span> + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - n.+<span class="mi">1</span>) g (j + l) &lt;=
\sum_(i0 &lt; n.+<span class="mi">1</span>) f (i + (<span class="mi">1</span> + i0))</div></blockquote><q>766</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subnn big_ord0 addn0 leq_sum // =&gt; l _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>63b</q><q>64a</q><q>74b</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i.+<span class="mi">1</span> + l) &lt;= f (i + (<span class="mi">1</span> + l))</div></blockquote><q>766</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> increasingE // addnCA add1n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>768</q><span class="goal-separator"><hr></span><q>72d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: k kLn =&gt; [_|k kLn]; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>5c9</q><q>64a</q><q>4a3</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k.+<span class="mi">1</span> &lt; n.+<span class="mi">2</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; k.+<span class="mi">1</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">2</span> - k.+<span class="mi">1</span>) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>5c9</q><q>64a</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; <span class="mi">0</span>) f (i + l) + \sum_(l &lt; n.+<span class="mi">2</span> - <span class="mi">0</span>) g (j + l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> subSS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>77c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; k.+<span class="mi">1</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</div></blockquote><q>77f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (leq_add  (leqnn _) (IH i.+<span class="mi">1</span> j k _)) _ .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>77c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt;= n.+<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>77c</q><label class="goal-separator"><hr></label><div class="goal-conclusion">f i +
(\sum_(l &lt; k) f (i.+<span class="mi">1</span> + l) +
 \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)) &lt;=
\sum_(l &lt; k.+<span class="mi">1</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</div></blockquote><q>780</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> -ltnS ltnW.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>77c</q><span class="goal-separator"><hr></span><q>78d</q></blockquote><q>77f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> addnA leq_add2r big_ord_recl addn0 leq_add2l leq_sum // =&gt; l _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>5bf</q><q>127</q><q>719</q><q>5c9</q><q>64a</q><q>4a3</q><q>77d</q><div><var>l</var><span class="hyp-type"><b>:</b><span>&#39;I_k</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (i.+<span class="mi">1</span> + l) &lt;= f (i + lift ord0 l)</div></blockquote><q>77f</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> addnCA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>781</q><span class="goal-separator"><hr></span><q>782</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> big_ord0 add0n subn0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>781</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n &lt;=
\sum_(l &lt; n.+<span class="mi">2</span>) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (leq_add  (leqnn _) (IH i.+<span class="mi">1</span> j <span class="mi">0</span> isT)) _ .</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>781</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i +
(\sum_(l &lt; <span class="mi">0</span>) f (i.+<span class="mi">1</span> + l) +
 \sum_(l &lt; n.+<span class="mi">1</span> - <span class="mi">0</span>) g (j + l)) &lt;=
\sum_(l &lt; n.+<span class="mi">2</span>) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> big_ord0 add0n subn0 [X <span class="kr">in</span> _ &lt;= X]big_ord_recr addnC leq_add //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>781</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i &lt;= g (j + ord_max)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: leq_trans (ltnW fLg) _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>781</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j &lt;= g (j + ord_max)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> increasingE // leq_addr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">leq_sum_fmerge_conv</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">k</span> <span class="nv">n</span> :
  increasing f -&gt; increasing g -&gt; k &lt;= n -&gt; 
  \sum_(i &lt; n) fmerge f g i &lt;= \sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><div><var>k, n</var><span class="hyp-type"><b>:</b><span>nat</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
k &lt;= n -&gt;
\sum_(i &lt; n) fmerge f g i &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7ab</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI; <span class="nb">case</span>: n =&gt; [|n kLn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>4a3</q><q>442</q><q>5bf</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k &lt;= <span class="mi">0</span> -&gt;
\sum_(i &lt; <span class="mi">0</span>) fmerge f g i &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; <span class="mi">0</span> - k) g i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>4a3</q><q>442</q><q>5bf</q><q>127</q><q>63c</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion">\sum_(i &lt; n.+<span class="mi">1</span>) fmerge f g i &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; n.+<span class="mi">1</span> - k) g i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span>: k; <span class="nb">rewrite</span> // !big_ord0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7b8</q><span class="goal-separator"><hr></span><q>7b9</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -sum_fmerge_correct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_fmerge f g n &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; n.+<span class="mi">1</span> - k) g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span>: (sum_fmerge_aux_conv_correct <span class="mi">0</span> <span class="mi">0</span> fI gI kLn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_aux_exist</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">n</span> :
  <span class="kr">exists2</span> k, k &lt;= n.+<span class="mi">1</span> &amp; 
  sum_fmerge_aux f g i j n =     
  \sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>62a</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  sum_fmerge_aux f g i j n =
  \sum_(l &lt; k) f (i + l) +
  \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>7c2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">elim</span>: n i j =&gt; /= [i j | n IH i j].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>5c9</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= <span class="mi">1</span> &amp;
  minn (f i) (g j) =
  \sum_(l &lt; k) f (i + l) + \sum_(l &lt; <span class="mi">1</span> - k) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><div><var>IH</var><span class="hyp-type"><b>:</b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
<span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  sum_fmerge_aux f g i j n =
  \sum_(l &lt; k) f (i + l) +
  \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)</span></span></div><q>5c9</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">2</span> &amp;
  (<span class="kr">if</span> f i &lt; g j
   <span class="kr">then</span> f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n
   <span class="kr">else</span> g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n) =
  \sum_(l &lt; k) f (i + l) +
  \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /minn; <span class="nb">case</span>: leqP =&gt; [gLf|fLg].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>5c9</q><q>645</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= <span class="mi">1</span> &amp;
  g j =
  \sum_(l &lt; k) f (i + l) + \sum_(l &lt; <span class="mi">1</span> - k) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>5c9</q><q>64a</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= <span class="mi">1</span> &amp;
  f i =
  \sum_(l &lt; k) f (i + l) + \sum_(l &lt; <span class="mi">1</span> - k) g (j + l)</div></blockquote><q>7cc</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">rewrite</span> // big_ord_recl !big_ord0 !(add0n, addn0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7d7</q><span class="goal-separator"><hr></span><q>7d8</q></blockquote><q>7cb</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="mi">1</span>; <span class="nb">rewrite</span> // subnn big_ord_recl !big_ord0 !(add0n, addn0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7cd</q><span class="goal-separator"><hr></span><q>7cf</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (leqP (g j) (f i)) =&gt; [gLf|fLg].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>7ce</q><q>5c9</q><q>645</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">2</span> &amp;
  g j + sum_fmerge_aux f g i j.+<span class="mi">1</span> n =
  \sum_(l &lt; k) f (i + l) +
  \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>7ce</q><q>5c9</q><q>64a</q></div><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">2</span> &amp;
  f i + sum_fmerge_aux f g i.+<span class="mi">1</span> j n =
  \sum_(l &lt; k) f (i + l) +
  \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (IH i j.+<span class="mi">1</span>) =&gt; k kLn -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>7ce</q><q>5c9</q><q>645</q><q>4a3</q><q>63c</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ex2 (<span class="kr">fun</span> <span class="nv">k</span> : nat =&gt; k &lt;= n.+<span class="mi">2</span>)
  (<span class="kr">fun</span> <span class="nv">k0</span> : nat =&gt;
   g j +
   (\sum_(l &lt; k) f (i + l) +
    \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j.+<span class="mi">1</span> + l)) =
   \sum_(l &lt; k0) f (i + l) +
   \sum_(l &lt; n.+<span class="mi">2</span> - k0) g (j + l))</div></blockquote><q>7e4</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> <span class="nv">k</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: leq_trans kLn _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7eb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">g j +
(\sum_(l &lt; k) f (i + l) +
 \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j.+<span class="mi">1</span> + l)) =
\sum_(l &lt; k) f (i + l) + \sum_(l &lt; n.+<span class="mi">2</span> - k) g (j + l)</div></blockquote><q>7e4</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> (subSn kLn) big_ord_recl addn0 addnCA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7eb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(l &lt; k) f (i + l) +
(g j + \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j.+<span class="mi">1</span> + l)) =
\sum_(l &lt; k) f (i + l) +
(g j + \sum_(i &lt; n.+<span class="mi">1</span> - k) g (j + lift ord0 i))</div></blockquote><q>7e4</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">congr</span> (_ + (_ + _)); <span class="nb">apply</span>: eq_bigr =&gt; l _; <span class="nb">rewrite</span> addnCA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7e6</q><span class="goal-separator"><hr></span><q>7e7</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (IH i.+<span class="mi">1</span> j) =&gt; k kLn -&gt;; <span class="kr">exists</span> <span class="nv">k</span>.+<span class="mi">1</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: leq_trans kLn _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>7ce</q><q>5c9</q><q>64a</q><q>4a3</q><q>63c</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i +
(\sum_(l &lt; k) f (i.+<span class="mi">1</span> + l) +
 \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)) =
\sum_(l &lt; k.+<span class="mi">1</span>) f (i + l) +
\sum_(l &lt; n.+<span class="mi">2</span> - k.+<span class="mi">1</span>) g (j + l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> big_ord_recl addn0 subSS -addnA.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>7fb</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f i +
(\sum_(l &lt; k) f (i.+<span class="mi">1</span> + l) +
 \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l)) =
f i +
(\sum_(i0 &lt; k) f (i + lift ord0 i0) +
 \sum_(l &lt; n.+<span class="mi">1</span> - k) g (j + l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">congr</span> (_ + (_ + _)); <span class="nb">apply</span>: eq_bigr =&gt; l _; <span class="nb">rewrite</span> addnCA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_exist</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> :
  <span class="kr">exists2</span> k, k &lt;= n &amp; 
  \sum_(i &lt; n) fmerge f g i = \sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n &amp;
  \sum_(i &lt; n) fmerge f g i =
  \sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>802</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: n =&gt; [|n]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> <span class="mi">0</span>; <span class="nb">rewrite</span> // !big_ord0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists2</span> k : nat,
  k &lt;= n.+<span class="mi">1</span> &amp;
  \sum_(i &lt; n.+<span class="mi">1</span>) fmerge f g i =
  \sum_(i &lt; k) f i + \sum_(i &lt; n.+<span class="mi">1</span> - k) g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (sum_fmerge_aux_exist f g <span class="mi">0</span> <span class="mi">0</span> n) =&gt; k kLn sE.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>354</q><q>63c</q><div><var>sE</var><span class="hyp-type"><b>:</b><span>sum_fmerge_aux f g <span class="mi">0</span> <span class="mi">0</span> n =
\sum_(l &lt; k) f (<span class="mi">0</span> + l) +
\sum_(l &lt; n.+<span class="mi">1</span> - k) g (<span class="mi">0</span> + l)</span></span></div></div><span class="goal-separator"><hr></span><q>809</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">k</span>; <span class="nb">rewrite</span> // -sum_fmerge_correct [LHS]sE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_fmerge_conv</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">n</span> : 
  increasing f -&gt; increasing g -&gt;
  \sum_(i &lt; n) (fmerge f g) i  =
     conv (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) f i) (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) g i) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5da</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing f -&gt;
increasing g -&gt;
\sum_(i &lt; n) fmerge f g i =
conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) f i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) g i) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>810</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; fI gI.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(i &lt; n) fmerge f g i =
conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) f i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) g i) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqn_leq; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b8</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) f i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) g i) n &lt;=
\sum_(i &lt; n) fmerge f g i</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>6b8</q><label class="goal-separator"><hr></label><div class="goal-conclusion">\sum_(i &lt; n) fmerge f g i &lt;=
conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) f i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) g i) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">case</span>: (sum_fmerge_exist f g n) =&gt; k kLn -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>127</q><q>442</q><q>5bf</q><q>4a3</q><div><var>kLn</var><span class="hyp-type"><b>:</b><span>k &lt;= n</span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion">conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) f i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) g i) n &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i</div></blockquote><q>81c</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: (bigmin_inf _ (leqnn _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>6b8</q><span class="goal-separator"><hr></span><q>81e</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>/bigmin_leqP =&gt; k kLn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>822</q><span class="goal-separator"><hr></span><div class="goal-conclusion">\sum_(i &lt; n) fmerge f g i &lt;=
\sum_(i &lt; k) f i + \sum_(i &lt; n - k) g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: leq_sum_fmerge_conv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* This is 3.2 *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">delta_conv</span> <span class="nv">f</span> <span class="nv">g</span> : 
  convex f -&gt; convex g -&gt; delta (conv f g) =<span class="mi">1</span> fmerge (delta f) (delta g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">convex f -&gt;
convex g -&gt;
delta (conv f g) =<span class="mi">1</span> fmerge (delta f) (delta g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>82d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [fI dfI] [gI dgI] n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>508</q><q>5bf</q><div><var>dgI</var><span class="hyp-type"><b>:</b><span>increasing (delta g)</span></span></div><q>127</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (conv f g) n = fmerge (delta f) (delta g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -delta_fnorm; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: increasing_conv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fnorm (conv f g)) n =
fmerge (delta f) (delta g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> -(delta_ext (conv_fnorm _ _)) //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (conv (fnorm f) (fnorm g)) n =
fmerge (delta f) (delta g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span>/delta_ext-&gt; : conv (fnorm f) (fnorm g) =<span class="mi">1</span>
         conv (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) (delta (fnorm f)) i) 
              (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) (delta (fnorm g)) i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv (fnorm f) (fnorm g) =<span class="mi">1</span>
conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm f) i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm g) i)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>834</q><label class="goal-separator"><hr></label><div class="goal-conclusion">delta
  (conv
     (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm f) i)
     (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm g) i))
  n = fmerge (delta f) (delta g) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: conv_ext =&gt; i; <span class="nb">apply</span>: sum_delta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><q>845</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">have</span>/delta_ext-&gt; :
  (conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm f) i)
        (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm g) i)) =<span class="mi">1</span>
  (<span class="kr">fun</span> <span class="nv">n</span> =&gt; \sum_(i &lt; n) (fmerge (delta (fnorm f)) (delta (fnorm g))) i).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><div class="goal-conclusion">conv (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm f) i)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; \sum_(i &lt; n) delta (fnorm g) i) =<span class="mi">1</span>
(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
 \sum_(i &lt; n)
    fmerge (delta (fnorm f)) (delta (fnorm g)) i)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>834</q><label class="goal-separator"><hr></label><div class="goal-conclusion">delta
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   \sum_(i &lt; n)
      fmerge (delta (fnorm f)) (delta (fnorm g)) i) n =
fmerge (delta f) (delta g) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; k; <span class="nb">rewrite</span> -sum_fmerge_conv //.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>508</q><q>5bf</q><q>835</q><q>354</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing (delta (fnorm f))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>853</q><label class="goal-separator"><hr></label><div class="goal-conclusion">increasing (delta (fnorm g))</div></blockquote><q>84e</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: increasing_ext dfI =&gt; i; <span class="nb">rewrite</span> delta_fnorm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>853</q><span class="goal-separator"><hr></span><q>857</q></blockquote><q>84d</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: increasing_ext dgI =&gt; i; <span class="nb">rewrite</span> delta_fnorm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><q>84f</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> /delta big_ord_recr /= addnC addnK.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>834</q><span class="goal-separator"><hr></span><div class="goal-conclusion">fmerge (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; fnorm f n.+<span class="mi">1</span> - fnorm f n)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; fnorm g n.+<span class="mi">1</span> - fnorm g n) n =
fmerge (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; f n.+<span class="mi">1</span> - f n)
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; g n.+<span class="mi">1</span> - g n) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: fmerge_aux_ext =&gt; i; <span class="nb">apply</span>: delta_fnorm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">convex_conv</span> <span class="nv">f</span> <span class="nv">g</span> : convex f -&gt; convex g -&gt; convex (conv f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5ad</q><span class="goal-separator"><hr></span><div class="goal-conclusion">convex f -&gt; convex g -&gt; convex (conv f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>863</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">move</span>=&gt; [fI dfI] [gI dgI]; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: increasing_conv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>5ae</q><q>442</q><q>508</q><q>5bf</q><q>835</q></div><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing (delta (conv f g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span>: increasing_ext =&gt; [i|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/sym_equal/delta_conv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>86a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">increasing (fmerge (delta f) (delta g))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span>: increasing_fmerge.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Convex</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;\min_ ( i &lt;= n ) F&quot;</span> := (bigmin (<span class="kr">fun</span> <span class="nv">i</span> =&gt; F) n)
 (<span class="kn">at level</span> <span class="mi">41</span>, F <span class="kn">at level</span> <span class="mi">41</span>, i, n <span class="kn">at level</span> <span class="mi">50</span>,
  <span class="kn">format</span> <span class="s2">&quot;\min_ ( i  &lt;=  n )  F&quot;</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="c">(* Mimic AC match for leq_trans *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">is_num</span> term :=
 <span class="kr">match</span> term <span class="kr">with</span> 
 | <span class="mi">0</span> =&gt; true 
 | S <span class="nl">?X</span> =&gt; is_num X
 | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">split_term</span> term :=
 <span class="kr">match</span> term <span class="kr">with</span> 
 | <span class="nl">?X</span> * <span class="nl">?Y</span> =&gt; <span class="kr">match</span> is_num X <span class="kr">with</span> true =&gt;  <span class="kp">constr</span>:((X, Y))
              | false =&gt; 
              <span class="kr">let</span> <span class="nv">v</span> := <span class="kp">once</span> (split_term X) <span class="kr">in</span> <span class="kp">constr</span>:((fst v, snd v * Y)) 
              <span class="kr">end</span>
 | <span class="nl">?X</span> =&gt; <span class="kr">match</span> is_num X <span class="kr">with</span> true =&gt; <span class="kp">constr</span>:((X, <span class="mi">1</span>)) 
                             | _ =&gt; <span class="kp">constr</span>:((<span class="mi">1</span>, X)) <span class="kr">end</span>
 | _ =&gt; false
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">delta_term</span> n1 n2 t2 :=
  <span class="kr">let</span> <span class="nv">n</span> :=  <span class="kp">constr</span>:(n1 - n2) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">n1</span> := <span class="kp">eval</span> <span class="nb">compute</span> <span class="kr">in</span> n <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">vt2</span> := <span class="kp">eval</span> <span class="nb">lazy</span> delta [fst snd] iota beta <span class="kr">in</span> t2 <span class="kr">in</span> 
  <span class="kr">let</span> <span class="nv">r</span> :=
    <span class="kr">match</span> n1 <span class="kr">with</span> 
    | <span class="mi">0</span> =&gt; <span class="kp">constr</span>:(<span class="mi">0</span>) 
    | <span class="mi">1</span> =&gt; <span class="kp">constr</span>:(t2) 
    | <span class="nl">?X</span>  =&gt; 
    <span class="kr">match</span> vt2 <span class="kr">with</span> | <span class="mi">1</span> =&gt; X | _ =&gt; <span class="kp">constr</span>:(X * vt2) <span class="kr">end</span>
    <span class="kr">end</span> <span class="kr">in</span>
   <span class="kp">eval</span> <span class="nb">lazy</span> delta [fst snd] iota beta <span class="kr">in</span> r.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">delta_lterm2</span> n1 t1 lt2 :=
 <span class="kr">match</span> lt2 <span class="kr">with</span> 
 |  <span class="nl">?X2</span> + <span class="nl">?Y2</span> =&gt;
     <span class="kr">let</span> <span class="nv">v2</span> := split_term Y2 <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">n2</span> := <span class="kp">constr</span>:(fst v2) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">t2</span> := <span class="kp">constr</span>:(snd v2) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">t</span> := <span class="kp">constr</span>:((t1, t2)) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">vt</span> := <span class="kp">eval</span> <span class="nb">lazy</span> delta [fst snd] iota beta <span class="kr">in</span> t <span class="kr">in</span> 
     <span class="kr">match</span> vt <span class="kr">with</span> 
     | (<span class="nl">?X</span>, <span class="nl">?X</span>) =&gt; delta_term n1 n2 t2
     |  _  =&gt; delta_lterm2 n1 t1 X2
     <span class="kr">end</span>
 |   <span class="nl">?Y2</span> =&gt;
     <span class="kr">let</span> <span class="nv">v2</span> := split_term Y2 <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">n2</span> := <span class="kp">constr</span>:(fst v2) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">t2</span> := <span class="kp">constr</span>:(snd v2) <span class="kr">in</span> 
     <span class="kr">let</span> <span class="nv">t</span> := <span class="kp">constr</span>:((t1, t2)) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">vt</span> := <span class="kp">eval</span> <span class="nb">lazy</span> delta [fst snd] iota beta <span class="kr">in</span> t <span class="kr">in</span> 
     <span class="kr">match</span> vt <span class="kr">with</span> 
     | (<span class="nl">?X</span>, <span class="nl">?X</span>) =&gt; delta_term n1 n2 t2
     |  _  =&gt; delta_term n1 <span class="mi">0</span> t1
     <span class="kr">end</span>
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">make_sum</span> t1 t2 :=
  <span class="kr">match</span> t1 <span class="kr">with</span> <span class="mi">0</span> =&gt; t2 | _ =&gt; 
  <span class="kr">match</span> t2 <span class="kr">with</span> <span class="mi">0</span> =&gt; t1 | _ =&gt; <span class="kp">constr</span>:(t1 + t2) <span class="kr">end</span> <span class="kr">end</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">delta_lterm1</span> lt1 lt2 :=
 <span class="kr">match</span> lt1 <span class="kr">with</span> 
 |  <span class="nl">?X1</span> + <span class="nl">?Y1</span> =&gt;
     <span class="kr">let</span> <span class="nv">v1</span> := split_term Y1 <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">n1</span> := <span class="kp">constr</span>:(fst v1) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">t1</span> := <span class="kp">constr</span>:(snd v1) <span class="kr">in</span> 
     <span class="kr">let</span> <span class="nv">r1</span> := delta_lterm1 X1 lt2 <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">r2</span> := delta_lterm2 n1 t1 lt2 <span class="kr">in</span> make_sum r1 r2

 |   <span class="nl">?Y1</span> =&gt;
     <span class="kr">let</span> <span class="nv">v1</span> := split_term Y1 <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">n1</span> := <span class="kp">constr</span>:(fst v1) <span class="kr">in</span>
     <span class="kr">let</span> <span class="nv">t1</span> := <span class="kp">constr</span>:(snd v1) <span class="kr">in</span> delta_lterm2 n1 t1 lt2
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">test</span> t1 t2 := <span class="kr">let</span> <span class="nv">xx</span> := delta_lterm1 t1 t2 <span class="kr">in</span> <span class="nb">pose</span> kk := xx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applyr</span> H :=
  <span class="nb">rewrite</span> -<span class="nl">?mul2n</span> <span class="kr">in</span> H |- *;
  <span class="kr">match goal with</span> 
  H: is_true (leq _ <span class="nl">?X</span>) |- is_true (leq _ <span class="nl">?Y</span>) =&gt;
    <span class="nb">ring_simplify</span> X Y <span class="kr">in</span> H;
    <span class="nb">ring_simplify</span> X Y; <span class="nb">rewrite</span> ?[nat_of_bin _]/= <span class="kr">in</span> H |- *
  <span class="kr">end</span>;
  <span class="kr">let</span> <span class="nv">Z</span> := <span class="kp">fresh</span> <span class="s2">&quot;Z&quot;</span> <span class="kr">in</span>
  <span class="kr">match goal with</span> 
  H: is_true (leq _ <span class="nl">?X1</span>) |- is_true (leq _ <span class="nl">?Y1</span>) =&gt;
    <span class="kr">let</span> <span class="nv">v</span> := delta_lterm1 Y1 X1 <span class="kr">in</span>
    (<span class="kp">try</span> (<span class="nb">rewrite</span> [Z <span class="kr">in</span> _ &lt;= Z](_ : _ = v + X1))); 
    [ <span class="nb">apply</span>: leq_trans (leq_add (leqnn _) H); <span class="nb">rewrite</span> {H}// ?(add0n,addn0) 
     | <span class="bp">ring</span>]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">applyl</span> H :=
  <span class="nb">rewrite</span> -<span class="nl">?mul2n</span> <span class="kr">in</span> H |- *;
  <span class="kr">match goal with</span> 
  H: is_true (leq <span class="nl">?X</span> _) |- is_true (leq <span class="nl">?Y</span> _) =&gt;
    <span class="nb">ring_simplify</span> X Y; <span class="nb">ring_simplify</span> X Y <span class="kr">in</span> H;
    <span class="nb">rewrite</span> ?[nat_of_bin _]/= <span class="kr">in</span> H |- *
  <span class="kr">end</span>;
  <span class="kr">let</span> <span class="nv">Z</span> := <span class="kp">fresh</span> <span class="s2">&quot;Z&quot;</span> <span class="kr">in</span>
  <span class="kr">match goal with</span> 
  H: is_true (leq <span class="nl">?X1</span> _) |- is_true (leq <span class="nl">?Y1</span> _) =&gt;
    <span class="kr">let</span> <span class="nv">v</span> := delta_lterm1 Y1 X1 <span class="kr">in</span>
    (<span class="kp">try</span> <span class="nb">rewrite</span> [Z <span class="kr">in</span> Z &lt;= _](_ : Y1 = v + X1));
    [<span class="nb">apply</span>: leq_trans (leq_add (leqnn _) H) _;
     <span class="nb">rewrite</span> {H}// ?(add0n,addn0) | <span class="bp">ring</span>]
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">gsimpl</span> :=
  <span class="nb">rewrite</span> -<span class="nl">?mul2n</span> <span class="kr">in</span> |- *;
  <span class="kr">match goal with</span> 
  |- is_true (leq <span class="nl">?X</span> <span class="nl">?Y</span>) =&gt;
    <span class="nb">ring_simplify</span> X Y; <span class="nb">rewrite</span> ?[nat_of_bin _]/=
  <span class="kr">end</span>;
  <span class="kr">let</span> <span class="nv">Z</span> := <span class="kp">fresh</span> <span class="s2">&quot;Z&quot;</span> <span class="kr">in</span>
  <span class="kr">match goal with</span> 
    |- is_true (leq <span class="nl">?X1</span> <span class="nl">?Y1</span>) =&gt;
    <span class="kr">let</span> <span class="nv">v</span> := delta_lterm1 Y1 X1 <span class="kr">in</span>
    <span class="kr">match</span> v <span class="kr">with</span> 
    | <span class="mi">0</span> =&gt; 
    <span class="kr">let</span> <span class="nv">v</span> := delta_lterm1 X1 Y1 <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">v1</span> := delta_lterm1 X1 v <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">v2</span> := delta_lterm1 Y1 v1 <span class="kr">in</span>
    (<span class="kp">try</span> (<span class="nb">rewrite</span> [Z <span class="kr">in</span> _ &lt;= Z](_ : Y1 = v2 + v1); <span class="nb">last</span> <span class="bp">by</span> <span class="bp">ring</span>));
    (<span class="kp">try</span> (<span class="nb">rewrite</span> [Z <span class="kr">in</span> Z &lt;= _](_ : X1 = v + v1); <span class="nb">last</span> <span class="bp">by</span> <span class="bp">ring</span>));
    <span class="nb">rewrite</span> <span class="nl">?leq_add2r</span>
    | _ =&gt; 
    <span class="kr">let</span> <span class="nv">v1</span> := delta_lterm1 Y1 v <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">v2</span> := delta_lterm1 X1 v1 <span class="kr">in</span>
    (<span class="kp">try</span> (<span class="nb">rewrite</span> [Z <span class="kr">in</span> _ &lt;= Z](_ : Y1 = v + v1); <span class="nb">last</span> <span class="bp">by</span> <span class="bp">ring</span>));
    (<span class="kp">try</span> (<span class="nb">rewrite</span> [Z <span class="kr">in</span> Z &lt;= _](_ : X1 = v2 + v1); <span class="nb">last</span> <span class="bp">by</span> <span class="bp">ring</span>));
    <span class="nb">rewrite</span> <span class="nl">?leq_add2r</span>
  <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">sring</span> := <span class="nb">rewrite</span> -!mul2n; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">changel</span> t :=
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> 
  <span class="nb">rewrite</span> [X <span class="kr">in</span> X &lt;= _](_ : _ = t); <span class="nb">last</span> <span class="bp">by</span> (<span class="bp">ring</span> || sring).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">changer</span> t := 
  <span class="kr">let</span> <span class="nv">X</span> := <span class="kp">fresh</span> <span class="s2">&quot;X&quot;</span> <span class="kr">in</span> 
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X](_ : _ = t); <span class="nb">last</span> <span class="bp">by</span> (<span class="bp">ring</span> || sring).</span><span class="alectryon-wsp">
</span></span></pre></article></body></html>