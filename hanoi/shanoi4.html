<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>shanoi4.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-centered alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="shanoi4-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="shanoi4-v-chk0"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> all_ssreflect finmap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="kn">From</span> hanoi <span class="kn">Require Import</span> extra star gdist lhanoi3 ghanoi ghanoi4 shanoi.

<span class="kn">Open Scope</span> nat_scope.

<span class="kn">Set Implicit Arguments</span>.
<span class="kn">Unset Strict Implicit</span>.

<span class="sd">(******************************************************************************)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*  This file proves the formula that gives the distance between two perfect  *)</span>
<span class="c">(*  configurations for the star puzzle. It follows the proof given by Thierry *)</span>
<span class="c">(*  Bousch in  La tour de Stockmeyer                                          *)</span>
<span class="c">(*                                                                            *)</span>
<span class="c">(*                                                                            *)</span>
<span class="sd">(******************************************************************************)</span>

<span class="kn">Section</span> <span class="nf">sHanoi4</span>.

<span class="kn">Local Notation</span> <span class="s2">&quot;c1 `--&gt;_s c2&quot;</span> := (smove c1 c2)
    (<span class="kn">format</span> <span class="s2">&quot;c1  `--&gt;_s  c2&quot;</span>, <span class="kn">at level</span> <span class="mi">60</span>).
<span class="kn">Local Notation</span> <span class="s2">&quot;c1 `--&gt;*_s c2&quot;</span> := (connect smove c1 c2) 
    (<span class="kn">format</span> <span class="s2">&quot;c1  `--&gt;*_s  c2&quot;</span>, <span class="kn">at level</span> <span class="mi">60</span>).

<span class="c">(* the peg at the center is 0 *)</span>
<span class="kn">Let</span> <span class="nf">p0</span> : peg <span class="mi">4</span> := ord0.

<span class="c">(* specialize version *)</span>
<span class="kn">Lemma</span> <span class="nf">pE4</span> (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : peg <span class="mi">4</span>) <span class="nv">p</span> : 
   p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt; 
   p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt;
  [\/ p = p0, p = p1, p = p2 | p = p3].
<span class="kn">Proof</span>. 
<span class="nb">rewrite</span> /p0.
<span class="bp">by</span> <span class="nb">case</span>: (peg4E p1) =&gt; -&gt;; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> //; 
   <span class="nb">case</span>: (peg4E p2) =&gt; -&gt;; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> //; 
   <span class="nb">case</span>: (peg4E p3) =&gt; -&gt;; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> //; 
   <span class="nb">case</span>: (peg4E p) =&gt; -&gt;; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> // =&gt; *; 
   <span class="kp">try</span> ((<span class="bp">by</span> <span class="nb">apply</span>: Or41) || (<span class="bp">by</span> <span class="nb">apply</span>: Or42) || 
        (<span class="bp">by</span> <span class="nb">apply</span>: Or43) || (<span class="bp">by</span> <span class="nb">apply</span>: Or44)).
<span class="kn">Qed</span>.

<span class="c">(* Lifting lhanoi3 to shanoi4 *)</span>

<span class="kn">Section</span> <span class="nf">lift</span>.

<span class="kn">Variable</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : peg <span class="mi">4</span>.

<span class="kn">Hypothesis</span> <span class="nv">p1Dp0</span> : p1 != p0.
<span class="kn">Hypothesis</span> <span class="nv">p2Dp0</span> : p2 != p0.
<span class="kn">Hypothesis</span> <span class="nv">p3Dp0</span> : p3 != p0.
<span class="kn">Hypothesis</span> <span class="nv">p1Dp2</span> : p1 != p2.
<span class="kn">Hypothesis</span> <span class="nv">p1Dp3</span> : p1 != p3.
<span class="kn">Hypothesis</span> <span class="nv">p2Dp3</span> : p2 != p3.

<span class="kn">Variable</span> <span class="nv">n</span> <span class="nv">m</span> : nat.

<span class="kn">Definition</span> <span class="nf">clmap</span> (<span class="nv">c</span> : configuration <span class="mi">3</span> n) : configuration <span class="mi">4</span> n :=
 [ffun i =&gt;
    <span class="kr">if</span> c i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> p1
    <span class="kr">else</span> <span class="kr">if</span> c i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> p0 <span class="kr">else</span> p2].

<span class="kn">Definition</span> <span class="nf">clmerge</span> (<span class="nv">c</span> : configuration <span class="mi">3</span> n) : configuration <span class="mi">4</span> (n + m) :=
  cmerge (clmap c) `c[p3].

<span class="kn">Lemma</span> <span class="nf">on_top_clmerge</span> <span class="nv">x</span> <span class="nv">c</span> : on_top x c -&gt; on_top (tlshift m x) (clmerge c).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /on_topP oH; <span class="nb">apply</span>/on_topP =&gt; d.
<span class="nb">rewrite</span> !ffunE tsplit_tlshift /=.
<span class="nb">case</span>: tsplitP =&gt; y; <span class="nb">rewrite</span> !ffunE =&gt; -&gt;.
  <span class="nb">case</span>: (_ == _) =&gt; [/eqP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> (negPf p1Dp3).
  <span class="nb">case</span>: (_ == _) =&gt; /eqP; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym (negPf p3Dp0).
  <span class="bp">by</span> <span class="nb">rewrite</span> (negPf p2Dp3).
<span class="nb">case</span>: eqP =&gt; [cxE0|cxD0].
  <span class="nb">case</span>: eqP =&gt; [cyE0 _| _].
    <span class="bp">by</span> <span class="nb">rewrite</span> leq_add2r oH //; <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= cyE0.
  <span class="bp">by</span> <span class="nb">case</span>: (_ == _) =&gt; /eqP; <span class="nb">rewrite</span> (negPf p1Dp0, negPf p1Dp2).
<span class="nb">case</span>: eqP =&gt; [cxE1|cxD1].
  <span class="nb">case</span>: (_ == _) =&gt; [/eqP|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym (negPf p1Dp0).
  <span class="nb">case</span>: eqP =&gt; [cyE1 _|_ /eqP].
    <span class="bp">by</span> <span class="nb">rewrite</span> leq_add2r oH //; <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= cyE1.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym (negPf p2Dp0).
<span class="nb">have</span> cxE2 : c x = <span class="mi">2</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (c x) cxD0 cxD1 =&gt; [] [|[|[]]].
<span class="nb">case</span>: eqP =&gt; [_ /eqP|cyD0].
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym (negPf p1Dp2).
<span class="nb">case</span>: eqP =&gt; [_ /eqP|cyD1 _].
  <span class="bp">by</span> <span class="nb">rewrite</span> (negPf p2Dp0).
<span class="nb">have</span> cyE2 : c y = <span class="mi">2</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (c y) cyD0 cyD1 =&gt; [] [|[|[]]].
<span class="bp">by</span> <span class="nb">rewrite</span> leq_add2r oH //; <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= cyE2.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">move_clmerge</span> <span class="nv">c1</span> <span class="nv">c2</span> : lmove c1 c2 -&gt;  clmerge c1 `--&gt;_s clmerge c2.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; /moveP [d1 [H1d1 H2d1 H3d1 H4d1]].
<span class="nb">apply</span>/moveP; <span class="kr">exists</span> (<span class="nv">tlshift</span> <span class="nv">m</span> <span class="nv">d1</span>); <span class="nb">split</span> =&gt; //.
- <span class="nb">move</span>: H1d1; <span class="nb">rewrite</span> !ffunE tsplit_tlshift !ffunE.
  <span class="nb">rewrite</span> /lrel /= /srel /ghanoi.srel /=.
  <span class="nb">case</span>: (c1 d1) =&gt; [] [|[|[|]]] //=.
  - <span class="nb">case</span>: (c2 d1) =&gt; [] [|[|[|]]] //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> p1Dp0 muln0.
  - <span class="nb">case</span>: (c2 d1) =&gt; [] [|[|[|]]] //= _ _ _.
      <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym p1Dp0.
    <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym p2Dp0.
  <span class="nb">case</span>: (c2 d1) =&gt; [] [|[|[|]]] //= _ _ _.
  <span class="bp">by</span> <span class="nb">rewrite</span> p2Dp0 muln0.
- <span class="nb">move</span>=&gt; d2; <span class="nb">rewrite</span> !ffunE; <span class="nb">case</span>: tsplitP =&gt; j; <span class="nb">rewrite</span> !ffunE //.
  <span class="nb">move</span>=&gt; d2E /eqP/val_eqP.
  <span class="nb">rewrite</span> /= d2E eqn_add2r =&gt; H.
  <span class="bp">by</span> <span class="nb">rewrite</span> (@H2d1 j).
- <span class="bp">by</span> <span class="nb">apply</span>: on_top_clmerge.
<span class="bp">by</span> <span class="nb">apply</span>: on_top_clmerge.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">path_clmerge</span> <span class="nv">c</span> <span class="nv">cs</span> :
  path (<span class="nb">move</span> (@lrel <span class="mi">3</span>)) c cs -&gt;
  path smove (clmerge c) [seq clmerge c | c &lt;- cs].
<span class="kn">Proof</span>.
<span class="nb">elim</span>: cs c =&gt; //= c1 cs IH c2 /andP[mH pH].
<span class="bp">by</span> <span class="nb">rewrite</span> move_clmerge // IH.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">gdist_clmerge</span> <span class="nv">c1</span> <span class="nv">c2</span> :
  `d[clmerge c1, clmerge c2]_smove &lt;= `d[c1, c2]_(<span class="nb">move</span> (@lrel <span class="mi">3</span>)).
<span class="kn">Proof</span>.
<span class="nb">have</span> /gpath_connect[pa1 pa1H] := move_lconnect3 c1 c2.
<span class="nb">rewrite</span> (gpath_dist pa1H) -(size_map clmerge).
<span class="nb">apply</span>: gdist_path_le; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> path_clmerge // (gpath_path pa1H).
<span class="bp">by</span> <span class="nb">rewrite</span> [LHS]last_map (gpath_last pa1H).
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">lift</span>.


<span class="c">(* We first prove the lower bound *)</span>

<span class="kn">Lemma</span> <span class="nf">leq_shanoi4</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> :
   p1 != p0 -&gt; p2 != p0 -&gt; p1 != p2 -&gt; 
   `d[`c[p1, n],`c[p2, n]]_smove &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
<span class="kn">Proof</span>.
<span class="nb">elim</span>/ltn_ind : n p1 p2 =&gt; [] [|n] IH p1 p2 p1Dp0 p2Dp0 p1Dp2.
  <span class="nb">rewrite</span> alphaS_small double0.
  <span class="nb">rewrite</span> (_ : `c[p1] = `c[p2]) <span class="nl">?gdist0</span> //.
  <span class="bp">by</span> <span class="nb">apply</span>/ffunP=&gt; [] [].
<span class="nb">rewrite</span> S1E S1_bigmin -muln2 -bigminMr.
<span class="nb">apply</span>/bigmin_leqP =&gt; i iLn.
<span class="nb">have</span> iLn1 : i &lt;= n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: leq_trans iLn _.
<span class="nb">rewrite</span> -{-<span class="mi">5</span>}(subnK iLn1).
<span class="nb">rewrite</span> eq_sym <span class="kr">in</span> p2Dp0.
<span class="nb">have</span> [p3 [[p3Dp2 p3Dp0 p3Dp1] _]] := peg4comp3 p1Dp0 p1Dp2 p2Dp0.
<span class="nb">rewrite</span> eq_sym <span class="kr">in</span> p2Dp0.
<span class="nb">pose</span> p1n := `c[p1, n.+<span class="mi">1</span> - i].
<span class="nb">pose</span> p2n := `c[p2, n.+<span class="mi">1</span> - i].
<span class="nb">pose</span> p3n := `c[p3, n.+<span class="mi">1</span> - i].
<span class="nb">pose</span> p1i := `c[p1, i].
<span class="nb">pose</span> p2i := `c[p2, i].
<span class="nb">pose</span> p3i := `c[p3, i].
<span class="nb">pose</span> c1 := cmerge p1n p1i.
<span class="nb">pose</span> c2 := cmerge p1n p3i.
<span class="nb">pose</span> c3 := cmerge p2n p3i.
<span class="nb">pose</span> c4 := cmerge p2n p2i.
<span class="nb">have</span> &lt;- : c1 = `c[p1].
  <span class="nb">apply</span>/ffunP =&gt; j; <span class="nb">rewrite</span> /c1 !ffunE.
  <span class="bp">by</span> <span class="nb">case</span>: tsplitP =&gt; k; <span class="nb">rewrite</span> !ffunE.
<span class="nb">have</span> &lt;- : c4 = `c[p2].
  <span class="nb">apply</span>/ffunP =&gt; j; <span class="nb">rewrite</span> /c1 !ffunE.
  <span class="bp">by</span> <span class="nb">case</span>: tsplitP =&gt; k; <span class="nb">rewrite</span> !ffunE.
<span class="nb">apply</span>: leq_trans 
   (_ : _ &lt;= `d[c1, c2]_smove + `d[c2, c3]_smove + `d[c3, c4]_smove) _.
  <span class="nb">apply</span>: leq_trans (leq_add (gdist_triangular  _ _ _ _) (leqnn _)).
  <span class="nb">apply</span>: gdist_triangular.
<span class="nb">rewrite</span> -addnn !mulnDl [X <span class="kr">in</span> _ &lt;= X]addnAC !muln2.
<span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="kp">first</span> <span class="mi">2</span> <span class="nb">last</span>.
- <span class="nb">apply</span>: leq_trans (gdist_merger _ _ _) _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: sirr.
    <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
  <span class="bp">by</span> <span class="nb">rewrite</span> -S1E; <span class="nb">apply</span>: IH.
- <span class="nb">apply</span>: leq_trans (gdist_merger _ _ _) _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>: sirr.
    <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
  <span class="bp">by</span> <span class="nb">rewrite</span> -S1E; <span class="nb">apply</span>: IH =&gt; //; <span class="nb">rewrite</span> eq_sym.
<span class="nb">rewrite</span> div2K; <span class="nb">last first</span>.
  <span class="nb">rewrite</span> -subn1 oddB <span class="nl">?expn_gt0</span> // addbT.
  <span class="bp">by</span> <span class="nb">rewrite</span> oddX orbT.
<span class="nb">have</span> -&gt; : c2 = clmerge p1 p2 p3 _ `c[ord0].
  <span class="nb">apply</span>/ffunP=&gt; x; <span class="nb">rewrite</span> !ffunE.
  <span class="bp">by</span> <span class="nb">case</span>: tsplitP =&gt; // j; <span class="nb">rewrite</span> !ffunE /=.
<span class="nb">have</span> -&gt; : c3 = clmerge p1 p2 p3 _ `c[inord <span class="mi">2</span>].
  <span class="nb">apply</span>/ffunP=&gt; x; <span class="nb">rewrite</span> !ffunE.
  <span class="bp">by</span> <span class="nb">case</span>: tsplitP =&gt; // j; <span class="nb">rewrite</span> !ffunE /= inordK.
<span class="nb">apply</span>: leq_trans (gdist_clmerge _ _ _ _ _ _ _ _ _) _ =&gt; //; 
  <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
<span class="nb">rewrite</span> gdist_lhanoi3p /lrel /= inordK //=.
<span class="nb">case</span>: eqP=&gt; [/val_eqP/=|]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
<span class="bp">by</span> <span class="nb">rewrite</span> muln1.
<span class="kn">Qed</span>.

<span class="c">(* *)</span>
<span class="c">(* Distance for a list *)</span>
<span class="kn">Fixpoint</span> <span class="nf">distanceL</span> <span class="nv">n</span> (<span class="nv">l</span> : seq (configuration <span class="mi">4</span> n)) : nat := 
  <span class="kr">if</span> l <span class="kr">is</span> a :: l1 <span class="kr">then</span>
    <span class="kr">if</span> l1 <span class="kr">is</span> b :: _ <span class="kr">then</span> `d[a, b]_smove + distanceL l1
    <span class="kr">else</span> <span class="mi">0</span>
  <span class="kr">else</span> <span class="mi">0</span>.

<span class="kn">Notation</span> <span class="s2">&quot; D[ l ] &quot;</span> := (distanceL l)
  (<span class="kn">format</span> <span class="s2">&quot; D[ l ]&quot;</span>).

<span class="c">(* Alternating peg : depending on the parity of n it is p1 or p2 *)</span>
<span class="kn">Definition</span> <span class="nf">apeg</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : peg <span class="mi">4</span> := <span class="kr">if</span> odd n <span class="kr">then</span> p2 <span class="kr">else</span> p1.
<span class="kn">Notation</span> <span class="s2">&quot; a[ p1 , p2 ] &quot;</span> := (apeg p1 p2)
  (<span class="kn">format</span> <span class="s2">&quot; a[ p1 ,  p2 ]&quot;</span>).
 
<span class="kn">Lemma</span> <span class="nf">apeg32E</span> <span class="nv">a</span> <span class="nv">p1</span> <span class="nv">p2</span> : a[p1, p2] (<span class="mi">3</span> * a).-<span class="mi">2</span> = a[p1, p2] a.
<span class="kn">Proof</span>.
<span class="nb">case</span>: a =&gt; // a.
<span class="nb">rewrite</span> /apeg -subn2 oddB; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> mulnS.
<span class="bp">by</span> <span class="nb">rewrite</span> oddM /=; <span class="nb">case</span>: odd.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apeg0</span> <span class="nv">p1</span> <span class="nv">p2</span> : a[p1, p2] <span class="mi">0</span> = p1.
<span class="kn">Proof</span>. <span class="bp">by</span> []. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apegS</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : a[p1, p2] n.+<span class="mi">1</span> = a[p2, p1] n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg /=; <span class="nb">case</span>: odd. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apegO</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : a[p1, p2] n = a[p2, p1] (~~ (odd n)).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg /=; <span class="nb">case</span>: odd. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apeg_double</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : a[p1, p2] (n.*<span class="mi">2</span>) = p1.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> apegO odd_double. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apeg_neq</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> <span class="nv">n</span> : p1 != p3 -&gt; p2 != p3 -&gt; a[p1, p2] n != p3.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg /=; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apeg_eqC</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : (a[p1, p2] n == a[p2, p1] n) = (p1 == p2).
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg /=; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apegD</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">m</span> <span class="nv">n</span> : a[p1, p2] (m + n) = a[ a[p1, p2] n, a[p2, p1] n] m.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg oddD; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: odd. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">apegMr</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">m</span> <span class="nv">n</span> : odd m -&gt; a[p1, p2] (m * n) = a[p1, p2] n.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">rewrite</span> oddM =&gt; -&gt;. <span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">codom_apeg</span> (<span class="nv">A</span> : finType) (<span class="nv">f</span> : {ffun A -&gt; _}) <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> : 
  (codom f \subset [::  a[p1, p2] n;  a[p2, p1] n]) =
  (codom f \subset [:: p1; p2]). 
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // codom_subC. <span class="kn">Qed</span>.

<span class="c">(* This is lemma 2.1 *)</span>
<span class="kn">Lemma</span> <span class="nf">sgdist_pair</span> <span class="nv">n</span> (<span class="nv">p2</span> : peg <span class="mi">4</span>) (<span class="nv">u</span> <span class="nv">v</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) 
    (<span class="nv">p1</span> := u ldisk) (<span class="nv">p3</span> := v ldisk): 
   {st : (configuration <span class="mi">4</span> n * configuration <span class="mi">4</span> n) |
    p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt; 
    p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt;
     [/\ codom st.<span class="mi">1</span> \subset [:: p2; p3], codom st.<span class="mi">2</span> \subset [:: p1; p2] &amp; 
         `d[u, v]_smove = D[[:: ‚Üì[u]; st.<span class="mi">1</span>; st.<span class="mi">2</span>; ‚Üì[v]]].+<span class="mi">2</span>]}.
<span class="kn">Proof</span>.
<span class="nb">case</span>: eqP =&gt; [_|/eqP p1Dp2]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">case</span>: eqP =&gt; [_|/eqP p1Dp3]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">case</span>: eqP =&gt; [_|/eqP p2Dp3]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">case</span>: eqP =&gt; [_|/eqP p1Dp0]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">case</span>: eqP =&gt; [_|/eqP p2Dp0]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">case</span>: eqP =&gt; [_|/eqP p3Dp0]; <span class="kp">first</span> <span class="bp">by</span> <span class="kr">exists</span> (‚Üì[u], ‚Üì[v]).
<span class="nb">have</span> pE p : [\/ p = p0, p = p1, p = p2 | p = p3] <span class="bp">by</span> <span class="nb">apply</span>: pE4.
<span class="nb">have</span> [cs /= csH] := gpath_connect (shanoi_connect u v).
<span class="nb">have</span> vIcs : v \<span class="kr">in</span> cs.
  <span class="nb">have</span> := mem_last u cs; <span class="nb">rewrite</span> (gpath_last csH).
  <span class="nb">rewrite</span> inE; <span class="nb">case</span>: eqP =&gt; //  vEu.
  <span class="bp">by</span> <span class="nb">case</span>/eqP : p1Dp3; <span class="nb">rewrite</span> /p3 vEu.
<span class="nb">case</span>: (@split_first _ cs (<span class="kr">fun</span> <span class="nv">c</span> =&gt; c ldisk != p1)) =&gt; [|[[sp cs1] cs2]].
  <span class="nb">apply</span>/negP=&gt; /allP /(_ _ vIcs).
  <span class="nb">rewrite</span> /= -topredE /= negbK.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym (negPf p1Dp3).
<span class="nb">case</span>=&gt; /allP spH spLE csE.
<span class="nb">pose</span> s := <span class="nb">last</span> u cs1.
<span class="nb">have</span> sMsp : s `--&gt;_s sp.
  <span class="bp">by</span> <span class="nb">have</span> := gpath_path csH; <span class="nb">rewrite</span> csE cat_path =&gt; /and3P[].
<span class="nb">have</span> sLp1 : s ldisk = p1.
  <span class="nb">move</span>: (spH s); <span class="nb">rewrite</span> /s; <span class="nb">case</span>: (cs1) =&gt; //= c cs3 /(_ (mem_last _ _)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -topredE negbK =&gt; /eqP.
<span class="nb">have</span> spLp0 : sp ldisk = p0.
  <span class="nb">apply</span>/eqP.
  <span class="nb">have</span> /(_ ldisk) := move_diskr sMsp.
  <span class="nb">rewrite</span> eq_sym sLp1 =&gt; /(_ spLE) /andP[].
  <span class="nb">case</span>: (_ =P p0) =&gt; // /val_eqP /=.
  <span class="nb">have</span> /eqP/val_eqP/= := p1Dp0.
  <span class="bp">by</span> <span class="nb">case</span>: (p1 : nat) =&gt; // k; <span class="nb">case</span>: (sp _ : nat).
<span class="nb">have</span> sCd : codom (‚Üì[s]) \subset [:: p2; p3].
  <span class="nb">apply</span>/subsetP=&gt; i; <span class="nb">rewrite</span> !inE =&gt; /codomP[j] -&gt;.
  <span class="nb">case</span>: (pE (‚Üì[s] j)) =&gt; [||-&gt;|-&gt;]; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> <span class="nl">?orbT</span> //.
    <span class="nb">rewrite</span> ffunE trshift_lift /=.
    <span class="nb">move</span>/eqP; <span class="nb">rewrite</span> -spLp0 -[_ == _]negbK; <span class="nb">case</span>/negP.
    <span class="nb">apply</span>: move_on_toplDr sMsp _ _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> sLp1 spLp0.
    <span class="bp">by</span> <span class="nb">rewrite</span> /= /bump [n &lt;= j]leqNgt ltn_ord add0n ltnW.
  <span class="nb">rewrite</span> ffunE trshift_lift /=.
  <span class="nb">move</span>/eqP; <span class="nb">rewrite</span> -sLp1 -[_ == _]negbK; <span class="nb">case</span>/negP.
  <span class="nb">apply</span>: move_on_toplDl sMsp _ _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> sLp1 spLp0.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= /bump [n &lt;= j]leqNgt ltn_ord add0n.
<span class="nb">have</span> vIcs2 : v \<span class="kr">in</span> cs2.
  <span class="nb">move</span>: vIcs; <span class="nb">rewrite</span> csE !(inE, mem_cat) =&gt; /or3P[|/eqP vEs|] //.
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /spH; <span class="nb">rewrite</span> /= -topredE negbK eq_sym (negPf p1Dp3).
  <span class="bp">by</span> <span class="nb">case</span>/eqP : p3Dp0; <span class="nb">rewrite</span> /p3 vEs.
<span class="nb">case</span>: (@split_last _ (sp :: cs2) (<span class="kr">fun</span> <span class="nv">c</span> =&gt; c ldisk != p3)) =&gt; 
     [|/= [[t cs3] cs4]/=].
  <span class="nb">apply</span>/negP=&gt; /allP /(_ _ (mem_head _ _)).
  <span class="bp">by</span> <span class="nb">rewrite</span> /= -topredE /= negbK spLp0 eq_sym (negPf p3Dp0).
<span class="nb">case</span>=&gt; // tLE tH scs2E.
<span class="nb">have</span> vIcs4 : v \<span class="kr">in</span> cs4.
  <span class="nb">have</span> := gpath_last csH; <span class="nb">rewrite</span> csE scs2E !last_cat /=.
  <span class="nb">case</span>: (cs4) =&gt; /= [tEv|c1 cs5 &lt;-]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: mem_last.
  <span class="bp">by</span> <span class="nb">case</span>/eqP: tLE; <span class="nb">rewrite</span> tEv.
  <span class="nb">case</span>: cs4 tH scs2E vIcs4 =&gt; // tp cs4 /allP tH scs2E vItpcs4.
<span class="nb">have</span> tMtp : t `--&gt;_s tp.
  <span class="bp">by</span> <span class="nb">have</span> := gpath_path csH; <span class="nb">rewrite</span> csE scs2E !cat_path /= =&gt; /and5P[].
<span class="nb">have</span> tpLp3 : tp ldisk = p3.
  <span class="bp">by</span> <span class="nb">move</span>: (tH _ (mem_head _ _)); <span class="nb">rewrite</span> /= -topredE negbK =&gt; /eqP.
<span class="nb">have</span> tLp0 : t ldisk = p0.
  <span class="nb">apply</span>/eqP.
  <span class="nb">have</span> /(_ ldisk) := move_diskr tMtp.
  <span class="nb">rewrite</span> tpLp3 =&gt; /(_ tLE) /andP[].
  <span class="nb">case</span>: (_ =P p0) =&gt; // /val_eqP /=.
  <span class="nb">have</span> /eqP/val_eqP/= := p3Dp0.
  <span class="bp">by</span> <span class="nb">case</span>: (p3 : nat) =&gt; // k; <span class="nb">case</span>: (t _ : nat).
<span class="nb">have</span> tCd : codom (‚Üì[t]) \subset [:: p1; p2].
  <span class="nb">apply</span>/subsetP=&gt; i; <span class="nb">rewrite</span> !inE =&gt; /codomP[j] -&gt;.
  <span class="nb">case</span>: (pE (‚Üì[t] j)) =&gt; [|-&gt;|-&gt;|]; <span class="nb">rewrite</span> <span class="nl">?eqxx</span> <span class="nl">?orbT</span> //.
    <span class="nb">rewrite</span> ffunE trshift_lift /=.
    <span class="nb">move</span>/eqP; <span class="nb">rewrite</span> -tLp0 -[_ == _]negbK; <span class="nb">case</span>/negP.
    <span class="nb">apply</span>: move_on_toplDl tMtp _ _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> tpLp3 tLp0 eq_sym.
    <span class="bp">by</span> <span class="nb">rewrite</span> /= /bump [n &lt;= j]leqNgt ltn_ord add0n.
  <span class="nb">rewrite</span> ffunE trshift_lift /=.
  <span class="nb">move</span>/eqP; <span class="nb">rewrite</span> -tpLp3 -[_ == _]negbK; <span class="nb">case</span>/negP.
  <span class="nb">apply</span>: move_on_toplDr tMtp _ _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> tpLp3 tLp0 eq_sym.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= /bump [n &lt;= j]leqNgt ltn_ord add0n ltnW.
<span class="kr">exists</span> (‚Üì[s], ‚Üì[t]); <span class="nb">split</span> =&gt; //=.
<span class="nb">rewrite</span> addn0.
<span class="nb">move</span>: csH; <span class="nb">rewrite</span> csE =&gt; csH.
<span class="nb">rewrite</span> (gdist_cat csH) -/s.
<span class="nb">move</span>: csH =&gt; /gpath_catr; <span class="nb">rewrite</span> -/s =&gt; csH.
<span class="nb">rewrite</span> gdist_cunlift_eq //; <span class="kp">try</span> <span class="nb">apply</span>: sirr; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
<span class="nb">rewrite</span> -!addnS.
<span class="nb">congr</span> (_ + _).
<span class="nb">have</span> -&gt;: ‚Üì[s] = ‚Üì[sp].
  <span class="nb">have</span> sLDspL : s ldisk != sp ldisk <span class="bp">by</span> <span class="nb">rewrite</span> sLp1 spLp0.
  <span class="nb">apply</span>/ffunP =&gt; i; <span class="nb">rewrite</span> !ffunE.
  <span class="nb">apply</span>: move_disk1 sMsp sLDspL _.
  <span class="bp">by</span> <span class="nb">apply</span>/negP =&gt; /eqP/val_eqP /=; <span class="nb">rewrite</span> eqn_leq leqNgt ltn_ord.
<span class="nb">rewrite</span> (gdist_cons csH) addnS; <span class="nb">congr</span> (_).+<span class="mi">1</span>.
<span class="nb">move</span>: csH =&gt; /gpath_consr csH.
<span class="nb">have</span> ctEctp : ‚Üì[t] = ‚Üì[tp].
  <span class="nb">have</span> tLDtpL : t ldisk != tp ldisk <span class="bp">by</span> <span class="nb">rewrite</span> tLp0 tpLp3 eq_sym.
  <span class="nb">apply</span>/ffunP =&gt; i; <span class="nb">rewrite</span> !ffunE.
  <span class="nb">apply</span>: move_disk1 tMtp tLDtpL _.
  <span class="bp">by</span> <span class="nb">apply</span>/negP =&gt; /eqP/val_eqP /=; <span class="nb">rewrite</span> eqn_leq leqNgt ltn_ord.
<span class="nb">case</span>: cs3 scs2E =&gt; [[spEt cs2E]|c3 cs3 /= [spE cs2E]].
  <span class="nb">move</span>: csH; <span class="nb">rewrite</span> spEt cs2E =&gt; csH.
  <span class="nb">rewrite</span> gdist0 add0n (gdist_cons csH) ctEctp.
  <span class="nb">move</span>: csH =&gt; /gpath_consr csH.
  <span class="nb">rewrite</span> gdist_cunlift_eq //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">apply</span>: sirr.
  <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
<span class="nb">move</span>: csH; <span class="nb">rewrite</span> cs2E -cat_rcons =&gt; csH.
<span class="nb">rewrite</span> (gdist_cat csH) last_rcons.
<span class="nb">rewrite</span> gdist_cunlift_eq //; <span class="kp">try</span> <span class="nb">apply</span>: sirr; <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
- <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
- <span class="bp">by</span> <span class="nb">rewrite</span> tLp0.
<span class="nb">congr</span> (_ + _).
<span class="nb">move</span>: csH =&gt; /gpath_catr; <span class="nb">rewrite</span> last_rcons =&gt; csH.
<span class="nb">rewrite</span> (gdist_cons csH); <span class="nb">congr</span> (_).+<span class="mi">1</span>.
<span class="nb">move</span>: csH =&gt; /gpath_consr csH.
<span class="nb">rewrite</span> ctEctp gdist_cunlift_eq //; <span class="kp">try</span> <span class="nb">apply</span>: sirr.
<span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
<span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">sgdist1</span> <span class="nv">n</span> (<span class="nv">p2</span> : peg <span class="mi">4</span>) (<span class="nv">u</span> <span class="nv">v</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) :=
 <span class="kr">let</span>: (exist (x, _) _) := sgdist_pair p2 u v <span class="kr">in</span> x.

<span class="kn">Definition</span> <span class="nf">sgdist2</span> <span class="nv">n</span> (<span class="nv">p2</span> : peg <span class="mi">4</span>) (<span class="nv">u</span> <span class="nv">v</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) :=
 <span class="kr">let</span>: (exist (_, x) _) := sgdist_pair p2 u v <span class="kr">in</span> x.

<span class="kn">Lemma</span> <span class="nf">sgdistE</span> <span class="nv">n</span> (<span class="nv">p2</span> : peg <span class="mi">4</span>) (<span class="nv">u</span> <span class="nv">v</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) 
    (<span class="nv">p1</span> := u ldisk) (<span class="nv">p3</span> := v ldisk): 
    p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt; 
    p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt; 
   [/\ codom (sgdist1 p2 u v) \subset [:: p2; p3], 
       codom (sgdist2 p2 u v) \subset [:: p1; p2] &amp; 
       `d[u, v]_smove = D[[:: ‚Üì[u]; sgdist1 p2 u v; sgdist2 p2 u v; ‚Üì[v]]].+<span class="mi">2</span>].
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0.
<span class="bp">by</span> <span class="nb">rewrite</span> /sgdist1 /sgdist2; <span class="nb">case</span>: sgdist_pair  =&gt; [] [x y] [].
<span class="kn">Qed</span>.

<span class="c">(* The beta function *)</span>
<span class="kn">Definition</span> <span class="nf">beta</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">k</span> := 
  <span class="kr">if</span> ((<span class="mi">1</span> &lt; l) &amp;&amp; (k == n.-<span class="mi">1</span>)) <span class="kr">then</span> Œ±_[l] k <span class="kr">else</span> (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>.

<span class="kn">Local Notation</span> <span class="s2">&quot;Œ≤_[ n , l ]&quot;</span> := (beta n l) (<span class="kn">format</span> <span class="s2">&quot;Œ≤_[ n ,  l ]&quot;</span> ).

<span class="kn">Lemma</span> <span class="nf">leq_beta</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">k</span> : Œ±_[l] k &lt;= Œ≤_[n, l] k.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /beta; <span class="nb">case</span>: (_ &lt; _) =&gt; /=; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: bound_alphaL.
<span class="bp">by</span> <span class="nb">case</span>: (_ == _) =&gt; //=; <span class="nb">apply</span>: bound_alphaL.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">geq_beta</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">k</span> : Œ≤_[n, l] k &lt;= (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>.
<span class="kn">Proof</span>.
<span class="nb">rewrite</span> /beta; <span class="nb">case</span>: (_ &lt; _) =&gt; //=.
<span class="bp">by</span> <span class="nb">case</span>: (_ == _) =&gt; //=; <span class="nb">apply</span>: bound_alphaL.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">beta1E</span> <span class="nv">n</span> <span class="nv">k</span> : Œ≤_[n, <span class="mi">1</span>] k = (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /beta ltnn. <span class="kn">Qed</span>.

<span class="kn">Definition</span> <span class="nf">sp</span> <span class="nv">n</span> (<span class="nv">a</span> : configuration <span class="mi">4</span> n) <span class="nv">l</span> <span class="nv">p</span> := 
  \sum_(k &lt; n) (a k != p) * Œ≤_[n, l] k.
 
<span class="kn">Lemma</span> <span class="nf">sum_beta_S</span> <span class="nv">n</span> <span class="nv">l</span> (<span class="nv">a</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) <span class="nv">p</span> : <span class="mi">1</span> &lt; l -&gt;
  sp a l p =
  \sum_(k &lt; n) ((‚Üì[a] k  != p) * (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>) + (a ord_max != p) * Œ±_[l] n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; l_gt1; <span class="nb">rewrite</span> /sp.
<span class="nb">rewrite</span> big_ord_recr /= /beta l_gt1 eqxx /=; <span class="nb">congr</span> (_ + _).
<span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE; <span class="nb">congr</span> ((a _ != _) * _).
  <span class="bp">by</span> <span class="nb">apply</span>: val_inj.
<span class="bp">by</span> <span class="nb">rewrite</span> eqn_leq [_ &lt;= i]leqNgt ltn_ord andbF.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">leq_sum_beta</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">a</span> : 
  \sum_(k &lt; n) a k * Œ≤_[n, l] k &lt;= \sum_(k &lt; n) a k * (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>.
<span class="kn">Proof</span>.
<span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> leq_mul2l geq_beta orbT.
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">sum_alpha_diffE</span> <span class="nv">n</span> (<span class="nv">f</span> : configuration <span class="mi">4</span> n.+<span class="mi">1</span>) (<span class="nv">p1</span> <span class="nv">p2</span> : peg <span class="mi">4</span>) <span class="nv">v1</span> <span class="nv">v2</span> :
  <span class="mi">1</span> &lt; v1 -&gt; <span class="mi">1</span> &lt; v2 -&gt; p1 != p2 -&gt; codom f \subset [:: p1; p2] -&gt;
  sp f v1 p1 + sp f v2 p2 &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn v1 v2] n.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; v1_gt1 v2_gt1 p1Dp2 cH.
<span class="nb">rewrite</span> !sum_beta_S //.
<span class="nb">rewrite</span> -addnA -addnCA addnC !addnA -addnA leq_add //.
  <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
  <span class="nb">rewrite</span> -addnn !dsum_alphaLE -!big_split /=; <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">rewrite</span> !ffunE; <span class="nb">set</span> v := trshift _ _.
  <span class="nb">have</span> /subsetP := cH =&gt; /(_ (f v) (codom_f _ _)).
  <span class="nb">rewrite</span> !inE addnn.
  <span class="nb">case</span>: eqP =&gt; /= x1; <span class="nb">case</span>: eqP =&gt; /= x2; <span class="nb">rewrite</span> ?(mul1n, add0n, addn0) //.
  <span class="bp">by</span> <span class="nb">move</span>/eqP: x2; <span class="nb">rewrite</span> x1 (negPf p1Dp2).
  <span class="nb">have</span> /subsetP/(_ (f ord_max) (codom_f _ _)) := cH.
<span class="nb">rewrite</span> !inE.
<span class="nb">case</span>: eqP =&gt; /= x1; <span class="nb">case</span>: eqP =&gt; /= x2 // _; <span class="nb">rewrite</span> ?(mul1n, add0n, addn0) //;
     <span class="nb">apply</span>: (increasingE (increasing_alphaL_l _)).
  <span class="bp">by</span> <span class="nb">apply</span>: leq_maxr.
<span class="bp">by</span> <span class="nb">apply</span>: leq_maxl.
<span class="kn">Qed</span>.

<span class="c">(* This corresponds to 4.1 *)</span>
<span class="kn">Section</span> <span class="nf">Case1</span>.

<span class="kn">Definition</span> <span class="nf">sd</span> <span class="nv">n</span> <span class="nv">l</span> (<span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">1</span> -&gt; configuration <span class="mi">4</span> n}) :=
    \sum_(i &lt; l) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.

<span class="kn">Variable</span> <span class="nv">n</span> : nat.
<span class="kn">Hypothesis</span> <span class="nv">IH</span>: 
     <span class="kr">forall</span> (<span class="nv">l</span> : nat) (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : ordinal_eqType <span class="mi">4</span>)
       (<span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">1</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}),
     p1 != p2 -&gt;
     p1 != p3 -&gt;
     p2 != p3 -&gt;
     p1 != p0 -&gt;
     p2 != p0 -&gt;
     p3 != p0 -&gt;
     (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">1</span>,
      <span class="mi">0</span> &lt; k &lt; l -&gt; codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
     (S_[l] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u + 
                     sp (u ord0) l (a[p1, p3] <span class="mi">0</span>) + 
                     sp (u ord_max) l (a[p1, p3] l).
 
<span class="kn">Variable</span> <span class="nv">l</span> : nat.
<span class="kn">Variables</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span>: peg <span class="mi">4</span>.
<span class="kn">Variable</span> <span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">2</span>}.
<span class="kn">Hypothesis</span> <span class="nv">p1Dp2</span> : p1 != p2.
<span class="kn">Hypothesis</span> <span class="nv">p1Dp3</span> : p1 != p3.
<span class="kn">Hypothesis</span> <span class="nv">p2Dp3</span> : p2 != p3.
<span class="kn">Hypothesis</span> <span class="nv">p1Dp0</span> : p1 != p0.
<span class="kn">Hypothesis</span> <span class="nv">p2Dp0</span> : p2 != p0.
<span class="kn">Hypothesis</span> <span class="nv">p3Dp0</span> : p3 != p0.
<span class="kn">Hypothesis</span> <span class="nv">cH</span> : <span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
     <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u k) \subset [:: p2; a[p1, p3] k].

<span class="kn">Let</span> <span class="nf">u&#39;</span>:= ([ffun i =&gt; ‚Üì[u i]] : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>})
 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}.

<span class="kn">Let</span> <span class="nf">H</span>: <span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
    <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u&#39; k) \subset [:: p2; a[p1, p3] k].
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">move</span>=&gt; k kH; <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>/codom_liftr/cH. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">apeg13D2</span> <span class="nv">a</span> : a[p1, p3] a != p2.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym. <span class="kn">Qed</span>.

<span class="kn">Let</span> <span class="nf">apeg13D0</span> <span class="nv">a</span> : a[p1, p3] a != p0.
<span class="kn">Proof</span>. <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym. <span class="kn">Qed</span>.

<span class="kn">Hypothesis</span> <span class="nv">KH1</span> : u ord0 ord_max = p1.
<span class="kn">Hypothesis</span> <span class="nv">KH2</span> : u ord_max ord_max != a[p3, p1] l.
<span class="kn">Hypothesis</span> <span class="nv">l_gt0</span> : l != <span class="mi">0</span>.

<span class="kn">Lemma</span> <span class="nf">case1</span> :
  (S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span>).*<span class="mi">2</span> &lt;= 
  sd u + sp (u ord0) l.+<span class="mi">1</span> p1 + 
         sp (u ord_max) l.+<span class="mi">1</span> (a[p3, p1] l).
<span class="kn">Proof</span>.
<span class="nb">have</span> il1E : inord l.+<span class="mi">1</span> = ord_max :&gt; &#39;I_l.+<span class="mi">2</span>
  <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> iE : <span class="kr">exists</span> <span class="nv">i</span>, u (inord i) ord_max != a[p1, p3] i.
  <span class="bp">by</span> <span class="kr">exists</span> <span class="nv">l</span>.+<span class="mi">1</span>; <span class="nb">rewrite</span> apegS il1E.
<span class="nb">case</span>: (@ex_minnP _ iE) =&gt; a aH aMin.
<span class="nb">have</span> aMin1 i : i &lt; a -&gt; u (inord i) ord_max = a[p1, p3] i.
  <span class="bp">by</span> <span class="nb">case</span>: (u (inord i) ord_max =P a[p1, p3] i) =&gt; // /eqP /aMin; <span class="nb">case</span>: leqP.
<span class="nb">have</span> aLld1 : a &lt;= l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: aMin; <span class="nb">rewrite</span> apegS il1E.
<span class="nb">have</span> a_gt0 : <span class="mi">0</span> &lt; a <span class="bp">by</span> <span class="nb">case</span>: (a) aH; <span class="nb">rewrite</span> // apeg0 -KH1 inord_eq0 //= eqxx.
<span class="nb">pose</span> ai : &#39;I_l.+<span class="mi">2</span> := inord a.
<span class="nb">have</span> aiE : ai = a :&gt; nat <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
<span class="nb">pose</span> b := l.+<span class="mi">1</span> - a.
<span class="nb">pose</span> bi : &#39;I_l.+<span class="mi">2</span> := inord b.
<span class="nb">have</span> biE : bi = b :&gt; nat <span class="bp">by</span> <span class="nb">rewrite</span> inordK // /b ltn_subLR // leq_addl.
<span class="nb">have</span> l_ggt0 : <span class="mi">0</span> &lt; l <span class="bp">by</span> <span class="nb">case</span>: l l_gt0.
<span class="nb">have</span> [/andP[a_gt1 aLlm1]|] := boolP (<span class="mi">2</span> &lt;= a &lt;= l.-<span class="mi">1</span>).
  <span class="nb">have</span> aLl : a &lt;= l <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans aLlm1) // -subn1 leq_subr.
  <span class="nb">have</span> b_gt1 : <span class="mi">1</span> &lt; b <span class="bp">by</span> <span class="nb">rewrite</span> leq_subRL // addn2 ltnS -[l]prednK.
  <span class="nb">have</span> uaiLEp2 : u ai ldisk = p2.
    <span class="nb">have</span> /cH/subsetP/(_ (u ai ldisk) (codom_f _ _)) : <span class="mi">0</span> &lt; ai &lt; l.+<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> aiE (leq_trans _ a_gt1) //= ltnS (leq_trans aLl1)
                 // ssrnat.leq_pred.
    <span class="bp">by</span> <span class="nb">rewrite</span> !inE aiE (negPf aH) orbF =&gt; /eqP.
  <span class="nb">pose</span> si i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist1 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
  <span class="nb">pose</span> ti i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist2 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
  <span class="nb">have</span> sitiH i : i &lt; a.-<span class="mi">1</span> -&gt;
     [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
         codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
         `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
           D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
    <span class="nb">move</span>=&gt; iLa.
    <span class="nb">have</span> iLa1 : i &lt; a <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans iLa) // ssrnat.leq_pred.
    <span class="nb">apply</span>: sgdistE =&gt; //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1.
    - <span class="nb">rewrite</span> !aMin1 //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK.
      <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="mi">1</span><span class="nl">?eq_sym</span> // -[a]prednK.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1.
    <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // -[a]prednK.
  <span class="nb">pose</span> sam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist1 (a[p1, p3] a) (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
  <span class="nb">pose</span> tam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist2 (a[p1, p3] a) (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
  <span class="nb">have</span> [sam1C tam1C duam1ua1E] : 
     [/\ codom sam1 \subset [:: a[p1, p3] a; u (inord a) ldisk ], 
         codom tam1 \subset [:: u (inord a.-<span class="mi">1</span>) ldisk; a[p1, p3] a] &amp; 
         `d[u (inord a.-<span class="mi">1</span>), u (inord a)]_smove = 
           D[[:: ‚Üì[u (inord a.-<span class="mi">1</span>)]; sam1; tam1; ‚Üì[u (inord a)]]].+<span class="mi">2</span>].
    <span class="nb">apply</span>: sgdistE =&gt; //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="nl">?prednK</span> // -{<span class="mi">2</span>}[a]prednK //= apegS apeg_eqC.
    - <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2 aMin1 <span class="nl">?prednK</span>.
    - <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="nl">?prednK</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2. 
  <span class="nb">have</span> {}tam1C : codom tam1 \subset [:: p1; p3].
    <span class="nb">move</span>: tam1C; <span class="nb">rewrite</span> aMin1; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK.
    <span class="nb">rewrite</span> -subn1 apegO oddB //= [a[_, _]a]apegO; <span class="nb">case</span>: odd =&gt; //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
  <span class="nb">pose</span> u1 := 
    [ffun i =&gt;
    <span class="kr">if</span> ((i : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span>) == <span class="mi">3</span> * a.-<span class="mi">1</span> :&gt;nat) <span class="kr">then</span> ‚Üì[u (inord a.-<span class="mi">1</span>)] 
    <span class="kr">else</span> <span class="kr">if</span> (i == (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span> :&gt;nat) <span class="kr">then</span> sam1
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (i %/ <span class="mi">3</span>))]
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> si (i %/ <span class="mi">3</span>)
    <span class="kr">else</span> ti (i %/ <span class="mi">3</span>)].
  <span class="nb">have</span> u10E : u1 ord0 = ‚Üì[u ord0].
    <span class="nb">rewrite</span> ffunE /= ifN <span class="nl">?inord_eq0</span> //.
    <span class="bp">by</span> <span class="nb">rewrite</span> neq_ltn muln_gt0 /= -ltnS prednK //= a_gt1.
  <span class="nb">have</span> uiME : u1 ord_max = sam1.
    <span class="nb">rewrite</span> ffunE /= eqn_leq leqNgt -{<span class="mi">2</span>}[a]prednK // mulnS.
    <span class="nb">rewrite</span> addSn add2n ltnS leqnn /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS eqxx.
  <span class="nb">pose</span> u2 :=  [ffun i  : &#39;I_3 =&gt;  
    <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> sam1 <span class="kr">else</span>
    <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span> ‚Üì[u ai]].
  <span class="nb">pose</span> u3 := [ffun i =&gt; ‚Üì[u (inord ((i : &#39;I_b.+<span class="mi">1</span>) + a))]].
  <span class="nb">have</span> P1 : a.*<span class="mi">2</span> + sd u1 + sd u2 + sd u3 &lt;= sd u. 
    <span class="nb">have</span> G b1 : b1 = a -&gt;  
      \sum_(i &lt; (<span class="mi">3</span> * b1).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove =
      \sum_(i &lt; (<span class="mi">3</span> * a.-<span class="mi">1</span>)) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove +
      `d[‚Üì[u (inord a.-<span class="mi">1</span>)], sam1]_smove.
      <span class="nb">move</span>=&gt; b1Ea.
      <span class="nb">have</span> ta2E : (<span class="mi">3</span> * b1).-<span class="mi">2</span> = (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> b1Ea -{<span class="mi">1</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> ta2E big_ord_recr /=; <span class="nb">congr</span> (_ + `d[_,_]_smove).
        <span class="bp">by</span> <span class="nb">rewrite</span> ffunE ifT// inordK // -{<span class="mi">2</span>}b1Ea <span class="nl">?ta2E</span>.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}b1Ea <span class="nl">?ta2E</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> eqn_leq ltnn /= eqxx.
    <span class="nb">rewrite</span> {}[sd u1]G //.
    <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove).
    <span class="nb">have</span> -&gt; : a.*<span class="mi">2</span> = <span class="mi">2</span> + \sum_(i &lt; a.-<span class="mi">1</span>) <span class="mi">2</span>.
      <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord.
      <span class="bp">by</span> <span class="nb">rewrite</span> muln2 -(doubleD <span class="mi">1</span>) add1n prednK.
    <span class="nb">rewrite</span> !addnA -[<span class="mi">2</span> + _ + _]addnA -big_split /=.
    <span class="nb">rewrite</span> [<span class="mi">2</span> + _]addnC -!addnA <span class="mi">2</span>![X <span class="kr">in</span> _ + X &lt;= _]addnA addnA.
    <span class="nb">have</span> -&gt; : sd u =
      \sum_(i &lt; a.-<span class="mi">1</span>) (`d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove) + 
      `d[u (inord a.-<span class="mi">1</span>), u ai]_smove +
      \sum_(i &lt; b) `d[u (inord (a +i)), u (inord (a + i.+<span class="mi">1</span>))]_smove.
      <span class="nb">have</span> F := big_mkord xpredT 
                    (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove).
      <span class="nb">rewrite</span> -{}[sd u]F.
      <span class="nb">rewrite</span> (big_cat_nat _ _ _ (_ : _ &lt;= (a.-<span class="mi">1</span>).+<span class="mi">1</span>)) //=; <span class="nb">last first</span>.
         <span class="bp">by</span> <span class="nb">rewrite</span> prednK.
      <span class="nb">rewrite</span> big_mkord big_ord_recr /= prednK //.
      <span class="nb">rewrite</span> -{<span class="mi">9</span>}[a]add0n big_addn -/b big_mkord.
      <span class="nb">congr</span> (_ + _ + _).
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i; <span class="nb">rewrite</span> addnC addnS.
    <span class="nb">apply</span>: leq_add; <span class="kp">first</span> <span class="nb">apply</span>: leq_add.
    - <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      <span class="nb">apply</span>: eq_bigr =&gt; i _.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i)) = ‚Üì[u (inord i)].
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /= ltnW.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_mul2l /= eqn_leq [_ &lt;= i]leqNgt ltn_ord andbF.
        <span class="nb">rewrite</span> eqn_leq ltn_mul2l /= ltnNge [i &lt;= _]ltnW // andbF.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E eqxx mulKn.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = si i.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> ltn_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> (leq_trans (_ : (<span class="mi">3</span> * i).+<span class="mi">2</span> &lt;= (<span class="mi">3</span> * i.+<span class="mi">1</span>))) <span class="nl">?andbF</span> //;
               <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
        - <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        - <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
        <span class="nb">rewrite</span> eqn_leq !ltnS [_ &lt;= <span class="mi">3</span> * i]leq_mul2l.
        <span class="bp">by</span> <span class="nb">rewrite</span> [_ &lt;= i]leqNgt ltn_ord andbF mod3E /= div3E.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = ti i.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="nb">rewrite</span> (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (i.+<span class="mi">1</span>))) //.
              <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> -[(<span class="mi">3</span> * i).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span> i) leq_mul2l ltn_ord andbF.
        <span class="nb">rewrite</span> eqn_leq !ltnS [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> (leq_trans (_ : (<span class="mi">3</span> * i).+<span class="mi">1</span> &lt; <span class="mi">3</span> * (i.+<span class="mi">1</span>))) <span class="nl">?andbF</span> //;
             <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
        - <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        - <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">3</span>) = ‚Üì[u (inord i.+<span class="mi">1</span>)].
        <span class="nb">have</span> -&gt; : (<span class="mi">3</span> * i).+<span class="mi">3</span> = <span class="mi">3</span> * (i.+<span class="mi">1</span>) <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_mul2l /=; <span class="nb">case</span>: eqP =&gt; [-&gt;//|_].
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= <span class="mi">3</span> * i.+<span class="mi">1</span>]leqNgt ltnS leq_mul2l /= ltn_ord andbF.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="nb">case</span>: (sitiH i) =&gt; // _ _ -&gt;.
      <span class="bp">by</span> <span class="nb">rewrite</span> add2n /= addnA addn0.
    - <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 //= add0n !addnA.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">0</span>) = sam1 <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">1</span>) = tam1 <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">2</span>) = ‚Üì[u ai] <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="bp">by</span> <span class="nb">move</span>: duam1ua1E; <span class="nb">rewrite</span> /= addn0 add2n !addnA !addSn.
    <span class="nb">apply</span>: leq_sum =&gt; i _.
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS.
    <span class="nb">rewrite</span> addSn [i + _]addnC addnS.
    <span class="bp">by</span> <span class="nb">apply</span>/gdist_cunlift/shanoi_connect.
  <span class="nb">set</span> x1P1 := sd _ <span class="kr">in</span> P1; <span class="nb">set</span> x2P1 := sd _ <span class="kr">in</span> P1.
  <span class="nb">set</span> x3P1 := sd _ <span class="kr">in</span> P1; <span class="nb">set</span> xP1 := sd _ <span class="kr">in</span> P1.
  <span class="nb">rewrite</span> -/xP1.
  <span class="nb">have</span> cH2 (k : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span> -&gt; codom (u1 k) \subset [:: p2; a[p1, p3] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt].
    <span class="nb">have</span> kL3a1 : k &lt;= (<span class="mi">3</span> * a.-<span class="mi">1</span>).
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS (leq_trans k_lt) // -{<span class="mi">1</span>}[a]prednK // mulnS.
    <span class="nb">have</span> kLa1 : k %/ <span class="mi">3</span> &lt;= a.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -(mulKn a.-<span class="mi">1</span> (isT : <span class="mi">0</span> &lt; <span class="mi">3</span>)) leq_div2r.
    <span class="nb">rewrite</span> ffunE; <span class="nb">case</span>: eqP =&gt; [kH|/eqP kH].
      <span class="nb">rewrite</span> kH apegMr //.
      <span class="nb">have</span> := @H (inord a.-<span class="mi">1</span>); <span class="nb">rewrite</span> inordK //.
        <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS prednK // a_gt1.
      <span class="bp">by</span> <span class="nb">rewrite</span> prednK // (leq_trans aLld1).
    <span class="nb">have</span> k3La2 : k %/ <span class="mi">3</span> &lt;= a.-<span class="mi">2</span>.
      <span class="nb">rewrite</span> -ltnS [a.-<span class="mi">2</span>.+<span class="mi">1</span>]prednK //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL.
      <span class="nb">rewrite</span> ltn_divLR // [_ * <span class="mi">3</span>]mulnC.
      <span class="bp">by</span> <span class="nb">move</span>: kL3a1 kH; <span class="nb">case</span>: ltngtP.
    <span class="nb">rewrite</span> eqn_leq [_ &lt;= k]leqNgt (leq_trans k_lt) <span class="nl">?andbF</span> //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS addSn add2n.
    <span class="nb">have</span> k3La : k %/ <span class="mi">3</span> &lt;= a.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans kLa1) // -subn1 leq_subr.
    <span class="nb">case</span>: eqP =&gt; k3mH.
      <span class="nb">apply</span>: codom_liftr.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(divn_eq k <span class="mi">3</span>) k3mH addn0 [<span class="kr">in</span> a[_,_] _]mulnC apegMr //.
      <span class="nb">have</span> := @cH (inord (k %/<span class="mi">3</span>)); <span class="nb">rewrite</span> inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> (leq_ltn_trans k3La).
      <span class="nb">apply</span>.
      <span class="nb">rewrite</span> (leq_ltn_trans k3La) <span class="nl">?ltnS</span> //.
      <span class="nb">move</span>: k_gt0; <span class="nb">rewrite</span> andbT {<span class="mi">1</span>}(divn_eq k <span class="mi">3</span>) k3mH addn0 muln_gt0.
      <span class="bp">by</span> <span class="nb">case</span>/andP.
    <span class="nb">case</span>: eqP =&gt; k3mH1.
      <span class="nb">case</span>: (sitiH ((k %/ <span class="mi">3</span>))) =&gt; /=.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>]prednK // -ltnS prednK.
      <span class="nb">set</span> pp := u _ _; (<span class="nb">suff</span> &lt;- : pp = a[p1, p3] k <span class="bp">by</span> []); <span class="nb">rewrite</span> {}/pp.
      <span class="nb">set</span> i := inord _; <span class="nb">have</span> &lt;- : a[p1, p3] i = a[p1, p3] k.
        <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) k3mH1 addn1 apegS mulnC apegMr //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /i !inordK <span class="nl">?apegS</span> //= !ltnS (leq_trans k3La).
      <span class="nb">have</span> H2 : (k %/ <span class="mi">3</span>).+<span class="mi">1</span> &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS (leq_trans k3La).
      <span class="nb">rewrite</span> -(@aMin1 i); <span class="nb">last first</span>.
        <span class="nb">rewrite</span> !inordK // -{<span class="mi">2</span>}[a]prednK // ltnS // -[a.-<span class="mi">1</span>]prednK // .
        <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 subn_gt0.
      <span class="nb">congr</span> (u _ _).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
    <span class="nb">rewrite</span> codom_subC.
    <span class="nb">case</span>: (sitiH ((k %/ <span class="mi">3</span>))) =&gt; /= [|_].
      <span class="bp">by</span> <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>]prednK // -ltnS prednK.
    <span class="nb">set</span> pp := u _ _; (<span class="nb">suff</span> &lt;- : pp = a[p1, p3] k <span class="bp">by</span> []); <span class="nb">rewrite</span> {}/pp.
    <span class="nb">set</span> i := inord _; <span class="nb">have</span> &lt;- : a[p1, p3] i = a[p1, p3] k.
      <span class="nb">have</span> k3mH2 : k %% <span class="mi">3</span> = <span class="mi">2</span>.
        <span class="nb">have</span> := ltn_mod k <span class="mi">3</span>; <span class="nb">move</span>: k3mH k3mH1.
        <span class="bp">by</span> <span class="nb">case</span>: modn =&gt; // [] [|[]].
      <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) k3mH2 addn2 !apegS mulnC apegMr //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /i !inordK <span class="nl">?apegS</span> //= !ltnS (leq_trans k3La).
      <span class="nb">have</span> H2 : (k %/ <span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS (leq_trans k3La).
      <span class="nb">rewrite</span> -(@aMin1 i); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> !inordK // -{<span class="mi">2</span>}[a]prednK .
      <span class="nb">congr</span> (u _ _).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
  <span class="nb">have</span> {cH2}P2 := IH p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0 cH2.
  <span class="nb">have</span> a3B2_gt1 : <span class="mi">1</span> &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>.
    <span class="nb">rewrite</span> -subn2 leq_subRL.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">4</span> &lt;= <span class="mi">3</span> * <span class="mi">2</span>)) // leq_mul2l.
    <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">2</span> &lt;= <span class="mi">3</span> * <span class="mi">2</span>)) // leq_mul2l.
  <span class="nb">rewrite</span> u10E uiME apeg0 <span class="kr">in</span> P2.
  <span class="nb">have</span> {}P2 := leq_trans P2 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                          (leqnn _)).
  <span class="nb">pose</span> pa := a[p1, p3] a; <span class="nb">pose</span> paS := a[p1, p3] a.+<span class="mi">1</span>.
  <span class="nb">have</span> cH3 (k : &#39;I_3) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">2</span> -&gt; codom (u2 k) \subset [:: paS; a[p2, pa] k].
    <span class="nb">case</span>: k =&gt; [] [|[|]] //= iH _.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS !apegS apeg0 ffunE /= codom_apeg codom_subC.
  <span class="nb">rewrite</span> -/x1P1 <span class="kr">in</span> P2.
  <span class="nb">have</span> {cH3}P3 : 
    (S_[<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u2 + sp (u2 ord0) <span class="mi">2</span> (a[p2, pa] <span class="mi">0</span>) +
                       sp (u2 ord_max) <span class="mi">2</span> (a[p2, pa] <span class="mi">2</span>).
    <span class="nb">apply</span>: IH cH3 =&gt; //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS // eq_sym.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS apegS apeg_eqC eq_sym.
  <span class="nb">rewrite</span> !ffunE /= apeg0 -/x2P1 <span class="kr">in</span> P3.
  <span class="nb">have</span> cH4 (k : &#39;I_b.+<span class="mi">1</span>) :
      <span class="mi">0</span> &lt; k &lt; b -&gt; codom (u3 k) \subset [:: p2; a[pa, paS] k].
      <span class="nb">rewrite</span> /b .
    <span class="nb">move</span>=&gt; /andP[k_gt0 kLb].
    <span class="nb">have</span> kBound : <span class="mi">0</span> &lt; k + a &lt; l.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> (leq_trans a_gt0) <span class="nl">?leq_addl</span> //=.
      <span class="bp">by</span> <span class="nb">move</span>: kLb; <span class="nb">rewrite</span> /b ltn_subRL addnC.
    <span class="nb">rewrite</span> ffunE codom_liftr //.
    <span class="nb">have</span> := @cH (inord (k + a)).
    <span class="nb">rewrite</span> /pa /paS apegS inordK; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -apegD; <span class="nb">apply</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS; <span class="nb">case</span>/andP: kBound.
  <span class="nb">have</span> {cH4}P4 : 
   (S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u3 + sp (u3 ord0) b (a[pa, paS] <span class="mi">0</span>) +
                      sp (u3 ord_max) b (a[pa, paS] b).
    <span class="nb">apply</span>: IH cH4 =&gt; //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS // eq_sym.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS apegS apeg_eqC.
  <span class="nb">have</span> {}P4 := leq_trans P4 (leq_add (leqnn _) (leq_sum_beta _ _)).
  <span class="nb">rewrite</span> apeg0 /= (_ : a[_, _] b = a[p3, p1] l) <span class="kr">in</span> P4; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS apegS -apegD subnK <span class="nl">?apegS</span>.
  <span class="nb">rewrite</span> !ffunE /= add0n -/ai <span class="kr">in</span> P4.
  <span class="nb">rewrite</span> -/x3P1 subnK // (_ : inord l.+<span class="mi">1</span> = ord_max) <span class="kr">in</span> P4; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _]sum_beta_S //= KH1 eqxx addn0.
  <span class="nb">set</span> xS := \sum_(_ &lt; _) _ <span class="kr">in</span> P2; <span class="nb">rewrite</span> -/xS.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + _ + X]sum_beta_S //= KH2 mul1n.
  <span class="nb">set</span> yS := \sum_(_ &lt; _) _ <span class="kr">in</span> P4; <span class="nb">rewrite</span> -/yS.
  <span class="nb">set</span> x1S := sp _ _ _ <span class="kr">in</span> P2; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P3.
  <span class="nb">have</span> x1Sy1SE : x1S + y1S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="mi">2</span>] n.
    <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
    <span class="nb">rewrite</span> apeg32E //.
    <span class="bp">by</span> <span class="nb">move</span>: sam1C; <span class="nb">rewrite</span> -uiME uaiLEp2.
  <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> x1Sy1SE.
  <span class="nb">set</span> x2S := sp _ _ _ <span class="kr">in</span> P3; <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P4.
  <span class="nb">have</span> x2y2SE : x2S + y2S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">2</span> b] n.
    <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa eq_sym.
    <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a_gt0.
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK.
  <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S <span class="kr">in</span> P2.
  <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S <span class="kr">in</span> P3.
  <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S.
  <span class="nb">have</span> F4 k : S_[a.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *a).-<span class="mi">2</span>] k + a.-<span class="mi">1</span>.
    <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
    <span class="nb">rewrite</span> leq_add2r.
    <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /=.
  <span class="nb">have</span> F4n := F4 n.
  <span class="nb">have</span> {F4}F4n1 := F4 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F5 k :
    S_[l.+<span class="mi">1</span>] k.+<span class="mi">1</span> + S_[<span class="mi">1</span>] k.+<span class="mi">1</span> + S_[b.+<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;=
    S_[a.-<span class="mi">1</span>] k.+<span class="mi">1</span> + S_[b.+<span class="mi">2</span>] k.+<span class="mi">1</span> + S_[b] k + (Œ±_[<span class="mi">1</span>] k).*<span class="mi">2</span>.
    <span class="nb">have</span> &lt;- : a + b = l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> addnC subnK.
    <span class="nb">rewrite</span> -[X <span class="kr">in</span> _ &lt;= X]addnA (leq_add _ (dsum_alphaL_alpha k b_gt1)) //.
    <span class="nb">have</span> := concaveEk1 <span class="mi">1</span> a.-<span class="mi">2</span> b.+<span class="mi">1</span> (concave_dsum_alphaL_l k.+<span class="mi">1</span>).
    <span class="nb">rewrite</span> add1n prednK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0.
    <span class="bp">by</span> <span class="nb">rewrite</span> -addSnnS prednK // add1n [X <span class="kr">in</span> _ &lt;= X]addnC.
  <span class="nb">have</span> F5n := F5 n.
  <span class="nb">have</span> {F5}F5n1 := F5 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F6 k : S_[b.+<span class="mi">2</span>] k + S_[<span class="mi">1</span>] k &lt;= S_[b.+<span class="mi">1</span>] k + S_[<span class="mi">2</span>] k.
    <span class="bp">by</span> <span class="nb">have</span> := concaveEk1 <span class="mi">1</span> <span class="mi">1</span> b (concave_dsum_alphaL_l k).
  <span class="nb">have</span> F6n := F6 n.+<span class="mi">1</span>.
  <span class="nb">have</span> {F6}F6n1 := F6 n.+<span class="mi">2</span>.
  <span class="nb">have</span> F72 := dsum_alphaL_S <span class="mi">2</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F721 := dsum_alphaL_S <span class="mi">2</span> n.
  <span class="nb">have</span> F711 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F71 := dsum_alphaL_S <span class="mi">1</span> n.
  <span class="nb">have</span> F73 := dsum_alphaL_S b n.  
  <span class="nb">have</span> F8 : Œ±_[<span class="mi">2</span>] n.+<span class="mi">1</span> &lt;= Œ±_[<span class="mi">1</span>] n.+<span class="mi">2</span>.
    <span class="nb">have</span> -&gt;: Œ±_[<span class="mi">1</span>] n.+<span class="mi">2</span> = Œ±_[<span class="mi">3</span>] n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> alphaL_3E.
    <span class="bp">by</span> <span class="nb">apply</span>: increasing_alphaL_l.
  <span class="nb">have</span> F9 : Œ±_[<span class="mi">1</span>] (n.+<span class="mi">2</span>) &lt;= (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.+<span class="mi">2</span>.
    <span class="nb">apply</span>: leq_trans (leqnSn _).
    <span class="bp">by</span> <span class="nb">apply</span>: alphaL_4_5.
<span class="c">(* Lia should work now *)</span>
  gsimpl.
  applyr P1.
  <span class="nb">rewrite</span> -(leq_add2r x1S); applyr P2.
  <span class="nb">rewrite</span> -(leq_add2r (y1S + x2S)); applyr P3.
  <span class="nb">rewrite</span> -(leq_add2r y2S); applyr P4.
  applyl x2y2SE; applyl x1Sy1SE.
  <span class="nb">rewrite</span> -[<span class="kr">in</span> <span class="mi">2</span> * a](prednK a_gt0).
  applyr F4n; applyr F4n1; gsimpl.
  <span class="nb">rewrite</span> (maxn_idPr _) //.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[b.+<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F5n.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[b.+<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F5n1.
  gsimpl.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F6n; gsimpl.
  <span class="nb">rewrite</span> F71; gsimpl.
  <span class="nb">rewrite</span> !add1n {}F73; gsimpl.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">2</span>] n.+<span class="mi">2</span>)).
  applyl  F6n1; gsimpl.
  <span class="nb">rewrite</span> {}F72 {}F721 {}F711 {}F71; gsimpl.
  applyl F8.
  <span class="bp">by</span>  applyl F9; gsimpl.
<span class="nb">rewrite</span> negb_and -leqNgt -ltnNge =&gt; oH.
<span class="nb">have</span> [/andP[a_gt1 /eqP bE1]|] := boolP ((<span class="mi">1</span> &lt; a) &amp;&amp; (b == <span class="mi">1</span>)).
<span class="c">(* 2 &lt;= a and b = 1 *)</span>
  <span class="nb">have</span> am1_gt0 : <span class="mi">0</span> &lt; a.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 subn_gt0.
  <span class="nb">have</span> lEa : l = a.
    <span class="nb">have</span> : a + b = l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> addnC subnK //.
    <span class="bp">by</span> <span class="nb">rewrite</span> bE1 addn1 =&gt; [] [].
  <span class="nb">have</span> uaiLEp2 : u ai ldisk = p2.
    <span class="nb">have</span> /cH/subsetP/(_ (u ai ldisk) (codom_f _ _)) : <span class="mi">0</span> &lt; ai &lt; l.+<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> aiE a_gt0 lEa /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> !inE aiE (negPf aH) orbF =&gt; /eqP.
  <span class="nb">pose</span> si i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist1 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
  <span class="nb">pose</span> ti i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
     sgdist2 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
  <span class="nb">have</span> sitiH i : i &lt; a.-<span class="mi">1</span> -&gt;
     [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
         codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
         `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
           D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
    <span class="nb">move</span>=&gt; iLa.
    <span class="nb">have</span> iLa1 : i &lt; a <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans iLa) // ssrnat.leq_pred.
    <span class="nb">apply</span>: sgdistE =&gt; //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1.
    - <span class="nb">rewrite</span> !aMin1 //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK.
      <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="mi">1</span><span class="nl">?eq_sym</span> // -[a]prednK.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1.
    <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // -[a]prednK.
  <span class="nb">pose</span> pa := a[p1, p3] a.
  <span class="nb">pose</span> sam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := sgdist1 pa (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
  <span class="nb">pose</span> tam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := sgdist2 pa (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
  <span class="nb">have</span> [sam1C tam1C duam1ua1E] : 
     [/\ codom sam1 \subset [:: pa; u (inord a) ldisk ], 
         codom tam1 \subset [:: u (inord a.-<span class="mi">1</span>) ldisk; pa] &amp; 
         `d[u (inord a.-<span class="mi">1</span>), u (inord a)]_smove = 
           D[[:: ‚Üì[u (inord a.-<span class="mi">1</span>)]; sam1; tam1; ‚Üì[u (inord a)]]].+<span class="mi">2</span>].
    <span class="nb">apply</span>: sgdistE; <span class="nb">rewrite</span> /pa //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="nl">?prednK</span> // -{<span class="mi">2</span>}[a]prednK //= apegS apeg_eqC.
    - <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2 aMin1 // prednK.
    - <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2.
    - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // prednK.
    <span class="bp">by</span> <span class="nb">rewrite</span> uaiLEp2.
  <span class="nb">have</span> {}tam1C : codom tam1 \subset [:: p1; p3].
    <span class="nb">move</span>: tam1C; <span class="nb">rewrite</span> aMin1; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa -{<span class="mi">2</span>}[a]prednK // apegS codom_apeg.
  <span class="nb">pose</span> u1 := 
    [ffun i =&gt;
    <span class="kr">if</span> ((i : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span>) == <span class="mi">3</span> * a.-<span class="mi">1</span> :&gt;nat) <span class="kr">then</span> ‚Üì[u (inord a.-<span class="mi">1</span>)] 
    <span class="kr">else</span> <span class="kr">if</span> (i == (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span> :&gt;nat) <span class="kr">then</span> sam1
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (i %/ <span class="mi">3</span>))]
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> si (i %/ <span class="mi">3</span>)
    <span class="kr">else</span> ti (i %/ <span class="mi">3</span>)].
  <span class="nb">have</span> u10E : u1 ord0 = ‚Üì[u ord0].
    <span class="nb">rewrite</span> ffunE /= ifN <span class="nl">?inord_eq0</span> //.
    <span class="bp">by</span> <span class="nb">rewrite</span> neq_ltn muln_gt0 /= -ltnS prednK //= a_gt1.
  <span class="nb">have</span> uiME : u1 ord_max = sam1.
    <span class="nb">rewrite</span> ffunE /= eqn_leq leqNgt -{<span class="mi">2</span>}[a]prednK // mulnS.
    <span class="nb">rewrite</span> addSn add2n ltnS leqnn /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS eqxx.
  <span class="nb">pose</span> u2 := 
    [ffun i : &#39;I_4 =&gt;  
    <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> sam1 <span class="kr">else</span>
    <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span>
    <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> ‚Üì[u ai] <span class="kr">else</span> ‚Üì[u (inord (l.+<span class="mi">1</span>))]].
  <span class="nb">have</span> P1 :  a.*<span class="mi">2</span> + sd u1 + sd u2 &lt;= sd u.
    <span class="nb">have</span> G b1 : b1 = a -&gt;  
      \sum_(i &lt; (<span class="mi">3</span> * b1).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove =
      \sum_(i &lt; (<span class="mi">3</span> * a.-<span class="mi">1</span>)) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove +
      `d[‚Üì[u (inord a.-<span class="mi">1</span>)], sam1]_smove.
      <span class="nb">move</span>=&gt; b1Ea.
      <span class="nb">have</span> ta2E : (<span class="mi">3</span> * b1).-<span class="mi">2</span> = (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> b1Ea -{<span class="mi">1</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> ta2E big_ord_recr /=; <span class="nb">congr</span> (_ + `d[_,_]_smove).
        <span class="bp">by</span> <span class="nb">rewrite</span> ffunE ifT// inordK // -{<span class="mi">2</span>}b1Ea <span class="nl">?ta2E</span>.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}b1Ea <span class="nl">?ta2E</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> eqn_leq ltnn /= eqxx.
    <span class="nb">rewrite</span> {}[sd u1]G //.
    <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove).
    <span class="nb">have</span> -&gt; : a.*<span class="mi">2</span> = <span class="mi">2</span> + \sum_(i &lt; a.-<span class="mi">1</span>) <span class="mi">2</span>.
      <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord.
      <span class="bp">by</span> <span class="nb">rewrite</span> muln2 -(doubleD <span class="mi">1</span>) add1n prednK.
    <span class="nb">rewrite</span> !addnA -[<span class="mi">2</span> + _ + _]addnA -big_split /=.
    <span class="nb">rewrite</span> [sd u2]big_ord_recr /=.
    <span class="nb">rewrite</span> [u2 (inord <span class="mi">2</span>)]ffunE inordK //=.
    <span class="nb">rewrite</span> [u2 (inord <span class="mi">3</span>)]ffunE inordK //=.
    <span class="nb">rewrite</span> [<span class="mi">2</span> + _]addnC -!addnA <span class="mi">2</span>![X <span class="kr">in</span> _ + X &lt;= _]addnA addnA.
    <span class="nb">have</span> -&gt; : sd u =
      \sum_(i &lt; a.-<span class="mi">1</span>) (`d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove) + 
      `d[u (inord a.-<span class="mi">1</span>), u ai]_smove + `d[u ai, u (inord ai.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> -lEa (_ : ai = inord l); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= aiE inordK // lEa.
      <span class="nb">case</span>: l l_gt0 u =&gt; //= l1 _ f.
      <span class="nb">rewrite</span> /sd <span class="mi">2</span>!big_ord_recr //=; <span class="nb">congr</span> (_ + _ + `d[f _, f _]_smove).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
    <span class="nb">apply</span>: leq_add; <span class="kp">first</span> <span class="nb">apply</span>: leq_add.
    - <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      <span class="nb">apply</span>: eq_bigr =&gt; i _.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i)) = ‚Üì[u (inord i)].
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /= ltnW.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_mul2l /= eqn_leq [_ &lt;= i]leqNgt ltn_ord andbF.
        <span class="nb">rewrite</span> eqn_leq ltn_mul2l /= ltnNge [i &lt;= _]ltnW // andbF.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = si i.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> ltn_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> (leq_trans (_ : (<span class="mi">3</span> * i).+<span class="mi">2</span> &lt;= (<span class="mi">3</span> * i.+<span class="mi">1</span>))) <span class="nl">?andbF</span> //;
               <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
        - <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        - <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
        <span class="nb">rewrite</span> eqn_leq !ltnS [_ &lt;= <span class="mi">3</span> * i]leq_mul2l.
        <span class="bp">by</span> <span class="nb">rewrite</span> [_ &lt;= i]leqNgt ltn_ord andbF mod3E /= div3E.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = ti i.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="nb">rewrite</span> (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (i.+<span class="mi">1</span>))) //.
              <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> -[(<span class="mi">3</span> * i).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span> i) leq_mul2l ltn_ord andbF.
        <span class="nb">rewrite</span> eqn_leq !ltnS [_ &lt;= _.+<span class="mi">1</span>]leqNgt.
        <span class="nb">rewrite</span> (leq_trans (_ : (<span class="mi">3</span> * i).+<span class="mi">1</span> &lt; <span class="mi">3</span> * (i.+<span class="mi">1</span>))) <span class="nl">?andbF</span> //;
             <span class="nb">last</span> <span class="mi">2</span> <span class="kp">first</span>.
        - <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        - <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">3</span>) = ‚Üì[u (inord i.+<span class="mi">1</span>)].
        <span class="nb">have</span> -&gt; : (<span class="mi">3</span> * i).+<span class="mi">3</span> = <span class="mi">3</span> * (i.+<span class="mi">1</span>) <span class="bp">by</span> <span class="nb">rewrite</span> mulnS addSn add2n.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="nb">rewrite</span> ltnS (leq_trans (_ : _ &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>))) //.
            <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l /=.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /= ltnW.
        <span class="nb">rewrite</span> eqn_mul2l /=; <span class="nb">case</span>: eqP =&gt; [-&gt;//|_].
        <span class="nb">rewrite</span> eqn_leq [_ &lt;= <span class="mi">3</span> * i.+<span class="mi">1</span>]leqNgt ltnS leq_mul2l /= ltn_ord andbF.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="nb">case</span>: (sitiH i) =&gt; //= _ _.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addnA addn0 add2n.
    - <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      <span class="nb">rewrite</span> !big_ord_recr big_ord0 //= add0n !addnA.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">0</span>) = sam1 <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">1</span>) = tam1 <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="nb">have</span> -&gt; : u2 (inord <span class="mi">2</span>) = ‚Üì[u ai] <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inordK.
      <span class="bp">by</span> <span class="nb">move</span>: duam1ua1E; <span class="nb">rewrite</span> /= addn0 add2n !addnA !addSn.
    <span class="nb">rewrite</span> (_ : inord l.+<span class="mi">1</span> = inord ai.+<span class="mi">1</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK // lEa.
    <span class="bp">by</span> <span class="nb">apply</span>/gdist_cunlift/shanoi_connect.
  <span class="nb">set</span> x1P1 := sd _ <span class="kr">in</span> P1; <span class="nb">set</span> x2P1 := sd _ <span class="kr">in</span> P1.
  <span class="nb">set</span> xP1 := sd _ <span class="kr">in</span> P1; <span class="nb">rewrite</span> -/xP1.
  <span class="nb">have</span> cH2 (k : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span> -&gt; codom (u1 k) \subset [:: p2; a[p1, p3] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt].
    <span class="nb">have</span> kL3a1 : k &lt;= (<span class="mi">3</span> * a.-<span class="mi">1</span>).
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS (leq_trans k_lt) // -{<span class="mi">1</span>}[a]prednK // mulnS.
    <span class="nb">have</span> kLa1 : k %/ <span class="mi">3</span> &lt;= a.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -(mulKn a.-<span class="mi">1</span> (isT : <span class="mi">0</span> &lt; <span class="mi">3</span>)) leq_div2r.
    <span class="nb">rewrite</span> ffunE; <span class="nb">case</span>: eqP =&gt; [kH|/eqP kH].
      <span class="nb">rewrite</span> kH apegMr //.
      <span class="nb">have</span> := @H (inord a.-<span class="mi">1</span>); <span class="nb">rewrite</span> inordK //.
        <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS prednK // a_gt1.
      <span class="bp">by</span> <span class="nb">rewrite</span> prednK // (leq_trans aLld1).
    <span class="nb">have</span> k3La2 : k %/ <span class="mi">3</span> &lt;= a.-<span class="mi">2</span>.
      <span class="nb">rewrite</span> -ltnS [a.-<span class="mi">2</span>.+<span class="mi">1</span>]prednK //.
      <span class="nb">rewrite</span> ltn_divLR // [_ * <span class="mi">3</span>]mulnC.
      <span class="bp">by</span> <span class="nb">move</span>: kL3a1 kH; <span class="nb">case</span>: ltngtP.
    <span class="nb">rewrite</span> eqn_leq [_ &lt;= k]leqNgt (leq_trans k_lt) <span class="nl">?andbF</span> //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS addSn add2n.
    <span class="nb">have</span> k3La : k %/ <span class="mi">3</span> &lt;= a.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans kLa1) // -subn1 leq_subr.
    <span class="nb">case</span>: eqP =&gt; k3mH.
      <span class="nb">apply</span>: codom_liftr.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(divn_eq k <span class="mi">3</span>) k3mH addn0 [<span class="kr">in</span> a[_,_] _]mulnC apegMr //.
      <span class="nb">have</span> := @cH (inord (k %/<span class="mi">3</span>)); <span class="nb">rewrite</span> inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> (leq_ltn_trans k3La).
      <span class="nb">apply</span>.
      <span class="nb">rewrite</span> (leq_ltn_trans k3La) <span class="nl">?ltnS</span> <span class="nl">?lEa</span> //.
      <span class="nb">move</span>: k_gt0; <span class="nb">rewrite</span> andbT {<span class="mi">1</span>}(divn_eq k <span class="mi">3</span>) k3mH addn0 muln_gt0.
      <span class="bp">by</span> <span class="nb">case</span>/andP.
    <span class="nb">case</span>: eqP =&gt; k3mH1.
      <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>]prednK.
      <span class="nb">set</span> pp := u _ _; (<span class="nb">suff</span> &lt;- : pp = a[p1, p3] k <span class="bp">by</span> []); <span class="nb">rewrite</span> {}/pp.
      <span class="nb">set</span> i := inord _; <span class="nb">have</span> &lt;- : a[p1, p3] i = a[p1, p3] k.
        <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) k3mH1 addn1 apegS mulnC apegMr //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /i !inordK <span class="nl">?apegS</span> //= !ltnS lEa.  
      <span class="nb">have</span> H2 : (k %/ <span class="mi">3</span>).+<span class="mi">1</span> &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS lEa (leq_trans k3La).
      <span class="nb">rewrite</span> -(@aMin1 i); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> !inordK // -{<span class="mi">2</span>}[a]prednK // ltnS // -[a.-<span class="mi">1</span>]prednK.
      <span class="nb">congr</span> (u _ _).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
    <span class="nb">rewrite</span> codom_subC.
    <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; [|_]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>]prednK.
    <span class="nb">set</span> pp := u _ _; (<span class="nb">suff</span> &lt;- : pp = a[p1, p3] k <span class="bp">by</span> []); <span class="nb">rewrite</span> {}/pp.
    <span class="nb">set</span> i := inord _; <span class="nb">have</span> &lt;- : a[p1, p3] i = a[p1, p3] k.
      <span class="nb">have</span> k3mH2 : k %% <span class="mi">3</span> = <span class="mi">2</span>.
        <span class="nb">have</span> := ltn_mod k <span class="mi">3</span>; <span class="nb">move</span>: k3mH k3mH1.
        <span class="bp">by</span> <span class="nb">case</span>: modn =&gt; // [] [|[]].
      <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) k3mH2 addn2 !apegS mulnC apegMr //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /i !inordK <span class="nl">?apegS</span> //= !ltnS (leq_trans k3La).
      <span class="nb">have</span> H2 : (k %/ <span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS (leq_trans k3La).
      <span class="nb">rewrite</span> -(@aMin1 i); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> !inordK // -{<span class="mi">2</span>}[a]prednK .
      <span class="nb">congr</span> (u _ _).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
  <span class="nb">have</span> {cH2}P2 := IH p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0 cH2.
  <span class="nb">have</span> a3B2_gt1 : <span class="mi">1</span> &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>.
    <span class="nb">rewrite</span> -subn2 leq_subRL.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">4</span> &lt;= <span class="mi">3</span> * <span class="mi">2</span>)) // leq_mul2l.
    <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">2</span> &lt;= <span class="mi">3</span> * <span class="mi">2</span>)) // leq_mul2l.
  <span class="nb">rewrite</span> u10E uiME apeg0 <span class="kr">in</span> P2.
  <span class="nb">have</span> {}P2 := leq_trans P2 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                          (leqnn _)).
  <span class="nb">rewrite</span> -/x1P1 <span class="kr">in</span> P2.
  <span class="nb">pose</span> paS := a[p1, p3] a.+<span class="mi">1</span>.
  <span class="nb">have</span> cH3 (k : &#39;I_4) :
    <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> -&gt; codom (u2 k) \subset [:: pa; a[p2, paS] k].
    <span class="nb">case</span>: k =&gt; [] [|[|[|]]] //= iH _; <span class="nb">rewrite</span> ffunE /=.
      <span class="bp">by</span> <span class="nb">have</span> := tam1C; <span class="nb">rewrite</span> /pa /paS !(apegS, apeg0) codom_apeg.
    <span class="nb">apply</span>: codom_liftr.
    <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; ai &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> aiE a_gt0 // lEa /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS !(apegS, apeg0) aiE codom_subC.
  <span class="nb">have</span> {cH3}P3 : 
    (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u2 + sp (u2 ord0) <span class="mi">3</span> (a[p2, paS] <span class="mi">0</span>) +
                       sp (u2 ord_max) <span class="mi">3</span> (a[p2, paS] <span class="mi">3</span>).
    <span class="nb">apply</span>: IH cH3 =&gt; //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS // eq_sym.
    <span class="bp">by</span> <span class="nb">rewrite</span> /paS apegS apeg_eqC.
  <span class="nb">have</span> {}P3 := leq_trans P3 (leq_add (leqnn _) (leq_sum_beta _ _)).
  <span class="nb">rewrite</span> /pa /paS -lEa !(apegS, apeg0) <span class="kr">in</span> P3.
  <span class="nb">rewrite</span> !ffunE /= -/x2P1 (_ : inord l.+<span class="mi">1</span> = ord_max) <span class="kr">in</span> P3; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _]sum_beta_S //= KH1 eqxx addn0.
  <span class="nb">set</span> xS := \sum_(_ &lt; _) _ <span class="kr">in</span> P2; <span class="nb">rewrite</span> -/xS.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + _ + X]sum_beta_S //= KH2 mul1n.
  <span class="nb">set</span> yS := \sum_(i &lt; _) _ <span class="kr">in</span> P3; <span class="nb">rewrite</span> -/yS.
  <span class="nb">set</span> x1S := sp _ _  _ <span class="kr">in</span> P2; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P3.
  <span class="nb">have</span> x1Sy1SE : x1S + y1S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="mi">3</span>] n.
    <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
    <span class="bp">by</span> <span class="nb">move</span>: sam1C; <span class="nb">rewrite</span> -uiME uaiLEp2 /pa apeg32E.
  <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> x1Sy1SE; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL ltnW // (leq_mul2l <span class="mi">3</span> <span class="mi">2</span>).
  <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S <span class="kr">in</span> P2.
  <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S.
  <span class="nb">have</span> F4 k : S_[a.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *a).-<span class="mi">2</span>] k + a.-<span class="mi">1</span>.
    <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
    <span class="nb">rewrite</span> leq_add2r.
    <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS addSn add2n /=.
  <span class="nb">have</span> F4n := F4 n.
  <span class="nb">have</span> {F4}F4n1 := F4 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F6 k : S_[a.+<span class="mi">1</span>] k + S_[<span class="mi">1</span>] k &lt;= S_[a.-<span class="mi">1</span>] k + S_[<span class="mi">3</span>] k.
    <span class="nb">have</span> := concaveEk1 <span class="mi">1</span> a.-<span class="mi">2</span> <span class="mi">2</span> (concave_dsum_alphaL_l k).
    <span class="bp">by</span> <span class="nb">rewrite</span> add1n addn2 !prednK // [_ + S_[<span class="mi">3</span>] _]addnC.
  <span class="nb">have</span> F6n := F6 n.+<span class="mi">1</span>.
  <span class="nb">have</span> {F6}F6n1 := F6 n.+<span class="mi">2</span>.
  <span class="nb">have</span> F72 := dsum_alphaL_S <span class="mi">3</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F721 := dsum_alphaL_S <span class="mi">3</span> n.
  <span class="nb">have</span> F711 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F71 := dsum_alphaL_S <span class="mi">1</span> n. 
  <span class="nb">have</span> F8 : Œ±_[<span class="mi">1</span>] n.+<span class="mi">2</span> = Œ±_[<span class="mi">3</span>] n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> alphaL_3E.
  <span class="nb">have</span> F9 : Œ±_[<span class="mi">1</span>] (n.+<span class="mi">2</span>) &lt;= (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.+<span class="mi">2</span>.
    <span class="nb">apply</span>: leq_trans (leqnSn _).
    <span class="bp">by</span> <span class="nb">apply</span>: alphaL_4_5.
<span class="c">(* Lia should work now *)</span>
  gsimpl.
  applyr P1.
  <span class="nb">rewrite</span> -(leq_add2r x1S); applyr P2.
  <span class="nb">rewrite</span> -(leq_add2r y1S); applyr P3.
  applyl x1Sy1SE; gsimpl.
  <span class="nb">rewrite</span> -(leq_add2r (S_[a.-<span class="mi">1</span>] n.+<span class="mi">1</span>)) -[<span class="kr">in</span> <span class="mi">2</span> * a](prednK a_gt0).
  applyl F4n.
  <span class="nb">rewrite</span> -(leq_add2r (S_[a.-<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F4n1.
  <span class="nb">rewrite</span> lEa; applyr F6n.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">3</span>] n.+<span class="mi">2</span>)); applyr F6n1.
  <span class="nb">rewrite</span> {}F72 {}F711 {}F71; gsimpl.
  <span class="nb">rewrite</span> !add1n -{}F8.
  <span class="bp">by</span> applyl F9; gsimpl.
<span class="nb">rewrite</span> negb_and -leqNgt =&gt; o1H.
<span class="nb">have</span> [/eqP aE1| aD1] := boolP (a == <span class="mi">1</span>).
  <span class="nb">have</span> b_gt0 : <span class="mi">0</span> &lt; b <span class="bp">by</span> <span class="nb">rewrite</span> /b aE1 subn1.
  <span class="nb">have</span> bE : b = l <span class="bp">by</span> <span class="nb">rewrite</span> /b aE1 subn1.
  <span class="nb">move</span>: b_gt0; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP bE1 | b_gt1]; <span class="nb">last first</span>.
    <span class="nb">have</span> u1C : u (inord <span class="mi">1</span>) ldisk = p2.
      <span class="nb">move</span>: aH; <span class="nb">rewrite</span> aE1 apegS apeg0. 
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
      <span class="nb">move</span>=&gt; /subsetP/(_ (u (inord <span class="mi">1</span>) ldisk) (codom_f _ _)).
      <span class="bp">by</span> <span class="nb">rewrite</span> !inE =&gt; /orP[] /eqP-&gt; //; <span class="nb">rewrite</span> !inordK // apegS apeg0 eqxx.
    <span class="nb">pose</span> s0 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> :=  sgdist1 p3 (u ord0) (u (inord <span class="mi">1</span>)).
    <span class="nb">pose</span> t0 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> :=  sgdist2 p3 (u ord0) (u (inord <span class="mi">1</span>)).
    <span class="nb">have</span> [s0C t0C ds0t0E] :
        [/\ codom s0 \subset [:: p3; u (inord <span class="mi">1</span>) ldisk ], 
         codom t0 \subset [:: u ord0 ldisk; p3] &amp; 
         `d[u ord0, u (inord <span class="mi">1</span>)]_smove = 
           D[[:: ‚Üì[u ord0]; s0; t0; ‚Üì[u (inord <span class="mi">1</span>)]]].+<span class="mi">2</span>].
      <span class="nb">apply</span>: sgdistE =&gt; //.
      - <span class="bp">by</span> <span class="nb">rewrite</span>  /= KH1.
      - <span class="bp">by</span> <span class="nb">rewrite</span> KH1 u1C.
      - <span class="bp">by</span> <span class="nb">rewrite</span> u1C eq_sym.
      - <span class="bp">by</span> <span class="nb">rewrite</span> KH1.
      <span class="bp">by</span> <span class="nb">rewrite</span> u1C.
    <span class="nb">pose</span> u1 := 
      [ffun i : &#39;I_4 =&gt;  
      <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u ord0] <span class="kr">else</span>
      <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> s0 <span class="kr">else</span>
      <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> t0 <span class="kr">else</span> ‚Üì[u (inord <span class="mi">1</span>)]].
    <span class="nb">pose</span> u2 := [ffun i =&gt; ‚Üì[u (inord ((i : &#39;I_b.+<span class="mi">1</span>) + <span class="mi">1</span>))]].
    <span class="nb">have</span> P1 : <span class="mi">2</span> + sd u1 + sd u2 &lt;= sd u.
      <span class="nb">have</span> -&gt; : sd u = 
          `d[u ord0, u (inord <span class="mi">1</span>)]_smove +
          \sum_(i &lt; b) `d[u (inord (a +i)), u (inord (a + i.+<span class="mi">1</span>))]_smove.
        <span class="nb">rewrite</span> /sd big_ord_recl /= bE.
        <span class="nb">congr</span> (`d[u _,u _]_smove + _).
          <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
        <span class="nb">apply</span>: eq_bigr =&gt; i _.
        <span class="nb">congr</span> (`d[u _,u _]_smove); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> aE1 /= inordK //=.
          <span class="bp">by</span> <span class="nb">rewrite</span> /bump add1n !ltnS ltnW.
        <span class="bp">by</span> <span class="nb">rewrite</span> /bump add1n !ltnS.
      <span class="nb">apply</span>: leq_add.
        <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
        <span class="nb">rewrite</span> /sd !big_ord_recr /= big_ord0 add0n.
        <span class="nb">rewrite</span> !ffunE !inordK //= add2n.
        <span class="bp">by</span> <span class="nb">rewrite</span> ds0t0E /= addn0 !addnA.
      <span class="nb">apply</span>: leq_sum =&gt; i _.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS.
      <span class="nb">rewrite</span> aE1 addSn [i + _]addnC addnS.
      <span class="bp">by</span> <span class="nb">apply</span>/gdist_cunlift/shanoi_connect.
    <span class="nb">set</span> x1P1 := sd _ <span class="kr">in</span> P1; <span class="nb">set</span> x2P1 := sd _ <span class="kr">in</span> P1.
    <span class="nb">set</span> xP1 := sd _ <span class="kr">in</span> P1; <span class="nb">rewrite</span> -/xP1.
    <span class="nb">have</span> cH2 (k : &#39;I_4) :
      <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> -&gt; codom (u1 k) \subset [:: p3; a[p1, p2] k]. 
      <span class="nb">case</span>: k =&gt; [] [|[|[|]]] //= iH _; <span class="nb">rewrite</span> ffunE /= !(apegS, apeg0).
        <span class="bp">by</span> <span class="nb">have</span> := s0C; <span class="nb">rewrite</span> u1C.
      <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC -KH1.
    <span class="nb">have</span> {cH2}P2 : 
      (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u1 + sp ‚Üì[u (inord <span class="mi">0</span>)] <span class="mi">3</span> (a[p1, p2] <span class="mi">0</span>) +
                         sp ‚Üì[u (inord <span class="mi">1</span>)] <span class="mi">3</span> (a[p1, p2] <span class="mi">3</span>).
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH2) _ =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add =&gt; //; <span class="nb">rewrite</span> leq_eqVlt;
             <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
        <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE inord_eq0.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">have</span> {}P2 := leq_trans P2 
               (leq_add (leq_add (leqnn _) (leq_sum_beta _ _)) (leqnn _)).
    <span class="nb">rewrite</span> -/x2P1 (inord_eq0) // -[<span class="kr">in</span> inord <span class="mi">1</span>]aE1 !(apegS, apeg0) <span class="kr">in</span> P2.
    <span class="nb">have</span> cH3 (k : &#39;I_b.+<span class="mi">1</span>) :
      <span class="mi">0</span> &lt; k &lt; b -&gt; codom (u2 k) \subset [:: p2; a[p3, p1] k].
      <span class="nb">rewrite</span> [X <span class="kr">in</span> k &lt; X]bE =&gt; /andP[k_gt0 kLb].
      <span class="nb">rewrite</span> ffunE addn1; <span class="nb">apply</span>: codom_liftr.
      <span class="nb">have</span> := @cH (inord k.+<span class="mi">1</span>).
      <span class="nb">rewrite</span> inordK <span class="nl">?apegS</span> //=; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS (leq_trans kLb).
    <span class="nb">have</span> {cH3}P3 : 
     (S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u2 + sp ‚Üì[u (inord <span class="mi">1</span>)] b p3 + 
                        sp ‚Üì[u ord_max] b (a[p3, p1] b).
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH3) _ =&gt; //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add =&gt; //; <span class="nb">rewrite</span> leq_eqVlt; 
         <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP; <span class="nb">apply</span>: eq_bigr =&gt; i _.
        <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE.
      <span class="nb">rewrite</span> !ffunE /= addn1 bE; <span class="nb">congr</span> ((u _ _ != _) * _).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">have</span> {}P3 := leq_trans P3 (leq_add (leqnn _) (leq_sum_beta _ _)).
    <span class="nb">rewrite</span> -/x2P1 (_ : a[p3, p1] b = a[p3, p1] l) <span class="kr">in</span> P3; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> bE.
    <span class="nb">rewrite</span> -[<span class="kr">in</span> inord <span class="mi">1</span>]aE1 <span class="kr">in</span> P3.
    <span class="nb">rewrite</span> !sum_beta_S // KH1 eqxx mul0n addn0 KH2 mul1n.
    <span class="nb">set</span> xS := \sum_(i &lt; _) _ <span class="kr">in</span> P2; <span class="nb">rewrite</span> -/xS.
    <span class="nb">set</span> yS := \sum_(i &lt; _) _ <span class="kr">in</span> P3; <span class="nb">rewrite</span> -/yS.
    <span class="nb">set</span> x1S := sp _ _ _ <span class="kr">in</span> P2; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P3.
    <span class="nb">have</span> x1Sy1SE : x1S + y1S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">3</span> b] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
      <span class="nb">apply</span>: codom_liftr.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> aE1 inordK.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK aE1.
    <span class="nb">rewrite</span> -/x1P1 <span class="kr">in</span> P2.
    <span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S -bE.
    gsimpl; applyr P1.
    <span class="nb">rewrite</span> -(leq_add2r x1S); applyr P2.
    <span class="nb">rewrite</span> -(leq_add2r y1S); applyr P3.
    applyl x1Sy1SE; gsimpl.
    <span class="nb">move</span>: b_gt1; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP bE2|b_gt2].
      <span class="nb">rewrite</span> -bE2 (maxn_idPl _) //.
      <span class="nb">rewrite</span> [S_[<span class="mi">3</span>] n.+<span class="mi">2</span>]dsum_alphaL_S; gsimpl.
      <span class="nb">rewrite</span> !alphaL_3E.
      <span class="nb">have</span> F := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>; applyr F.
      <span class="nb">rewrite</span> !dsum_alphaL_S; gsimpl.
      <span class="nb">rewrite</span> !add1n.
      <span class="bp">by</span> <span class="nb">have</span> F := alphaL_4_5 n; applyl F; gsimpl.
    <span class="nb">rewrite</span> (maxn_idPr _) //.
    changer (<span class="mi">2</span> * (S_[<span class="mi">3</span>] (n.+<span class="mi">1</span>)).+<span class="mi">1</span> +  <span class="mi">2</span> * S_[b] (n.+<span class="mi">1</span>)).
    <span class="nb">rewrite</span> -dsum_alpha3_S.
    <span class="nb">rewrite</span> ![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= <span class="mi">2</span> * X + _]dsum_alphaL_S; gsimpl.
    <span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= _ + X]mul2n -addnn.
    <span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= _ + (X + _)]dsum_alphaL_S; gsimpl.
    changer ((S_[b] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>) + (S_[b] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>)).
    <span class="bp">by</span> <span class="nb">apply</span>: leq_add; <span class="nb">apply</span>: dsum_alphaL_alpha; <span class="nb">apply</span>: ltnW.
  <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
  <span class="nb">move</span>=&gt; /subsetP /(_ (u (inord <span class="mi">1</span>) ldisk) (codom_f _ _)).
  <span class="nb">rewrite</span> !inE inordK // apegS apeg0.
  <span class="nb">have</span> := aH; <span class="nb">rewrite</span> (_ : inord a = inord <span class="mi">1</span>); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK // aE1.
  <span class="nb">rewrite</span> aE1 apegS =&gt; /negPf-&gt;; <span class="nb">rewrite</span> orbF =&gt; /eqP u1LE. 
  <span class="nb">case</span>: (@sgdistE _ p3 (u ord0) (u (inord <span class="mi">1</span>))) =&gt; //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> KH1.
  - <span class="bp">by</span> <span class="nb">rewrite</span> KH1 u1LE.
  - <span class="bp">by</span> <span class="nb">rewrite</span> u1LE eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> KH1.
  <span class="bp">by</span> <span class="nb">rewrite</span> u1LE.
  <span class="nb">set</span> s0 := sgdist1 _ _ _; <span class="nb">set</span> t0 := sgdist2 _ _ _.
  <span class="nb">move</span>=&gt; s0C t0C du0u1; <span class="nb">rewrite</span> /= !addnA addn0 <span class="kr">in</span> du0u1.
  <span class="nb">pose</span> u1 := 
    [ffun i =&gt;  
      <span class="kr">if</span> (i : &#39;I_5) == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u ord0] <span class="kr">else</span>
      <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> s0 <span class="kr">else</span>
      <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> t0 <span class="kr">else</span> 
      <span class="kr">if</span> i == <span class="mi">3</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord <span class="mi">1</span>)] <span class="kr">else</span> ‚Üì[u (inord <span class="mi">2</span>)]].
  <span class="nb">have</span> P1 : <span class="mi">2</span> + sd u1 &lt;= sd u.
    <span class="nb">rewrite</span> /sd <span class="mi">2</span>![<span class="kr">in</span> X <span class="kr">in</span> X &lt;= _]big_ord_recr 
                  [X <span class="kr">in</span> _ &lt;= X]big_ord_recr /= !addnA.
    <span class="nb">apply</span>: leq_add; <span class="nb">last first</span>.
      <span class="nb">apply</span>: leq_trans (gdist_cunlift _); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
      <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      <span class="nb">rewrite</span> !ffunE ![<span class="kr">in</span> LHS]inordK //=.
      <span class="bp">by</span> <span class="nb">congr</span>(`d[‚Üì[u _],‚Üì[u _]]_smove); 
         <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK //= -bE bE1.
    <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
    <span class="nb">rewrite</span> !big_ord_recr big_ord0 /= !ffunE !inordK //= add0n.
    <span class="nb">rewrite</span> -addnA add2n -du0u1.
    <span class="nb">move</span>: bE; <span class="nb">rewrite</span> -bE1.
    <span class="nb">case</span>: (l) u =&gt; // [] [] // uu _; <span class="nb">rewrite</span> big_ord_recl big_ord0 addn0 /=.
    <span class="bp">by</span> <span class="nb">congr</span>(`d[uu _, uu _]_smove); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK.
  <span class="nb">have</span> cH1 (k : &#39;I_5) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">4</span> -&gt; codom (u1 k) \subset [:: p3; a[p1, p2] k].
    <span class="nb">case</span>: k =&gt; [] [|[|[|[|]]]] //= iH _; <span class="nb">rewrite</span> !ffunE !(apegS, apeg0).
    - <span class="bp">by</span> <span class="nb">have</span> := s0C; <span class="nb">rewrite</span> u1LE.
    - <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC -KH1.
    <span class="nb">rewrite</span> codom_subC.
    <span class="nb">apply</span>/subsetP=&gt; i /codomP[x -&gt;]; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">have</span> /cH: <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK //.
    <span class="bp">by</span> <span class="nb">rewrite</span> inordK // =&gt; 
        /subsetP /(_ (u (inord <span class="mi">1</span>) (trshift <span class="mi">1</span> x)) (codom_f _ _)).
  <span class="nb">have</span> {cH1}P2 :
     (S_[<span class="mi">4</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u1 + sp (u1 ord0) <span class="mi">4</span> p1 + sp (u1 ord_max) <span class="mi">4</span> p1.
    <span class="bp">by</span> <span class="nb">apply</span>: IH cH1 =&gt; //; <span class="nb">rewrite</span> eq_sym.
  <span class="nb">set</span> xP := sd _; <span class="nb">rewrite</span> -/xP <span class="kr">in</span> P1.
  <span class="nb">have</span> {}P2 := 
    leq_trans P2 (leq_add (leq_add (leqnn _ ) (leq_sum_beta _ _))
                          (leq_sum_beta _ _)).
  <span class="nb">set</span> x1P := sd _ <span class="kr">in</span> P1; <span class="nb">rewrite</span> -/x1P <span class="kr">in</span> P2.
  <span class="nb">rewrite</span> !ffunE /= (_ : inord <span class="mi">2</span> = ord_max) <span class="kr">in</span> P2; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= inordK // -bE bE1.
  <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : p1 = a[p3, p1] l) <span class="kr">in</span> P2; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -bE -bE1.
  <span class="nb">set</span> x1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P2; <span class="nb">set</span> x2S := \sum_(_ &lt; _) _ <span class="kr">in</span> P2.
  <span class="nb">rewrite</span> !sum_beta_S //= KH1 KH2 !eqxx !addn0 mul1n.
  <span class="nb">rewrite</span> -/x1S -/x2S -!addnA.
  <span class="nb">apply</span>: leq_trans (leq_add P1 (leqnn _)).
  <span class="nb">rewrite</span> -!addnA addnC !addnA -addnA.
  <span class="nb">apply</span>: leq_trans (leq_add P2 (leqnn _)).
  <span class="nb">rewrite</span> -bE -bE1 -addnn {<span class="mi">2</span>}dsum_alphaL_S addnA.
  <span class="nb">rewrite</span> [_ + <span class="mi">2</span>]addnC !addnA leq_add2r addnC.
  <span class="bp">by</span> <span class="nb">apply</span>: leq_dsum_alpha_2l_l <span class="mi">2</span> n.+<span class="mi">1</span>.
<span class="nb">have</span> aEl : a = l.+<span class="mi">1</span>.
  <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqn_leq aLld1 /=.
  <span class="nb">case</span>/orP: oH; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: (a) aD1 a_gt0 =&gt; [|[|]].
  <span class="nb">case</span>/orP: o1H; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">case</span>: (a) aD1 a_gt0 =&gt; [|[|]].
  <span class="nb">rewrite</span> /b prednK // =&gt; H1 lLa; <span class="nb">move</span>: lLa H1.
  <span class="bp">by</span> <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[] // /eqP -&gt;; <span class="nb">rewrite</span> subSn // subnn eqxx.
<span class="nb">have</span> bE0 : b = <span class="mi">0</span> <span class="bp">by</span> <span class="nb">rewrite</span> /b aEl subnn.
<span class="nb">pose</span> si i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
  sgdist1 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">pose</span> ti i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
   sgdist2 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">have</span> sitiH i : i &lt; l -&gt;
   [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
       codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
       `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
         D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
  <span class="nb">move</span>=&gt; iLl.
  <span class="nb">have</span> iLl1 : i &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans iLl).
  <span class="nb">apply</span>: sgdistE =&gt; //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // aEl.
  - <span class="nb">rewrite</span> !aMin1 <span class="nl">?aEl</span> //.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
  - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="nl">?aEl</span> // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // aEl.
  <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // aEl.
<span class="nb">pose</span> u1 := 
  [ffun i =&gt;
    <span class="kr">if</span> ((i : &#39;I_(<span class="mi">3</span> * l).+<span class="mi">2</span>) == (<span class="mi">3</span> * l).+<span class="mi">1</span> :&gt;nat) <span class="kr">then</span> ‚Üì[u ai] 
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (i %/ <span class="mi">3</span>))]
    <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> si (i %/ <span class="mi">3</span>)
    <span class="kr">else</span> ti (i %/ <span class="mi">3</span>)].
<span class="nb">have</span> u10E : u1 ord0 = ‚Üì[u ord0].
  <span class="nb">rewrite</span> ffunE /=.
  <span class="bp">by</span> <span class="nb">congr</span> (‚Üì[u _]); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> u1mE : u1 ord_max = ‚Üì[u ord_max].
  <span class="nb">rewrite</span> ffunE eqxx.
  <span class="bp">by</span> <span class="nb">congr</span> (‚Üì[u _]); <span class="nb">apply</span>/val_eqP/eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> P1 : l.*<span class="mi">2</span> + sd u1 &lt;= sd u.
  <span class="nb">rewrite</span> /sd !big_ord_recr /=.
  <span class="nb">rewrite</span> addnA; <span class="nb">apply</span>: leq_add; <span class="nb">last first</span>. 
    <span class="nb">apply</span>: leq_trans (gdist_cunlift _); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: shanoi_connect.
    <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
    <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?eqxx</span> //.
    <span class="nb">rewrite</span> eqn_leq [_ &lt;= _ * _]leqNgt leqnn andbF mod3E /= div3E.
    <span class="nb">congr</span> (`d[‚Üì[u _], ‚Üì[u _]]_smove); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= <span class="nl">?mulKn</span> //.
    <span class="bp">by</span> <span class="nb">rewrite</span> inordK // aiE aEl.
  <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
  <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove).
  <span class="nb">have</span> -&gt; : l.*<span class="mi">2</span> = \sum_(i &lt; l) <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord muln2.
  <span class="nb">rewrite</span> -big_split /=; <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">rewrite</span> ffunE !inordK //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW // ltnS leq_mul2l /= ltnW.
  <span class="nb">rewrite</span> eqn_leq [_ &lt;= _ * _]leqNgt ltnS leq_mul2l //=.
  <span class="nb">rewrite</span> (ltnW (ltn_ord _)) andbF mod3E /= div3E.
  <span class="nb">rewrite</span> ffunE !inordK //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS leq_mul2l /= ltnW.
  <span class="nb">rewrite</span> eqn_leq [_.+<span class="mi">1</span> &lt;= _]leqNgt !ltnS leq_mul2l /= [_ &lt;= i]leqNgt.
  <span class="nb">rewrite</span> ltn_ord andbF mod3E /= div3E -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span> i) add1n.
  <span class="nb">rewrite</span> ffunE !inordK //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span>!ltnS ltn_mul2l /=.
  <span class="nb">rewrite</span> !mod3E /= !div3E ifN; <span class="nb">last first</span>.
    <span class="nb">case</span>: eqP =&gt; // eH.
    <span class="nb">have</span> : (<span class="mi">3</span> * i).+<span class="mi">2</span> %% <span class="mi">3</span> = (<span class="mi">3</span> * l).+<span class="mi">1</span> %% <span class="mi">3</span> <span class="bp">by</span> <span class="nb">rewrite</span> eH.
    <span class="bp">by</span> <span class="nb">rewrite</span> !mod3E.
  <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW // ltnS leq_mul2l /=.
  <span class="nb">rewrite</span> mod3E /= div3E ifN.
    <span class="nb">case</span>: (sitiH i) =&gt; //= _ _ -&gt;.
    <span class="bp">by</span> <span class="nb">rewrite</span> /= !addnA addn0.
  <span class="nb">case</span>: eqP =&gt; // eH.
  <span class="nb">have</span> : (<span class="mi">3</span> * i.+<span class="mi">1</span>) %% <span class="mi">3</span> = (<span class="mi">3</span> * l).+<span class="mi">1</span> %% <span class="mi">3</span> <span class="bp">by</span> <span class="nb">rewrite</span> eH.
  <span class="bp">by</span> <span class="nb">rewrite</span> !mod3E.
<span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * l).+<span class="mi">2</span>) : 
    <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * l).+<span class="mi">1</span> -&gt; codom (u1 k) \subset [:: p2; a[p1, p3] k].
  <span class="nb">rewrite</span> !ffunE.
  <span class="nb">case</span>: eqP =&gt; [-&gt;|/eqP kD3l1]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnn andbF.
  <span class="nb">case</span>: eqP =&gt; [km3E0|/eqP km3D0].
    <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E0 addn0.
    <span class="nb">rewrite</span> ltnS mulnC muln_gt0 leq_mul2l /= =&gt; /andP[k3_gt0 k3Ll].
    <span class="nb">rewrite</span> apegMr //.
    <span class="nb">have</span>:= @H (inord (k %/ <span class="mi">3</span>)); <span class="nb">rewrite</span> ffunE inordK //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: leq_trans k3Ll _.
    <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">rewrite</span> k3_gt0.
  <span class="nb">case</span>: eqP =&gt; [km3E1|/eqP km3D1].
    <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E1 addn1 !ltnS /= mulnC ltn_mul2l /= =&gt; H1.
    <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; //.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS apegMr // aMin1 <span class="nl">?apegS</span> // aEl ltnS.
  <span class="nb">have</span> km3E2 : k %% <span class="mi">3</span> = <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">case</span>: (_ %% _) (ltn_mod k <span class="mi">3</span>) km3D0 km3D1 =&gt; // [] [|[|]].
  <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E2 addn2 /= ltnS =&gt; H1.
  <span class="nb">have</span> {}H1 : k %/ <span class="mi">3</span> &lt; l.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[_ &lt; _](ltn_mul2r <span class="mi">3</span>) [l * <span class="mi">3</span>]mulnC (leq_ltn_trans _ H1).
  <span class="nb">rewrite</span> codom_subC.
  <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; // _.
  <span class="nb">rewrite</span> !apegS [_ * <span class="mi">3</span>]mulnC apegMr //.
  <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // (leq_trans H1) // aEl.
<span class="nb">have</span> {cH1}P2 : 
   (S_[(<span class="mi">3</span> * l).+<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u1 + sp (u1 ord0) (<span class="mi">3</span> * l).+<span class="mi">1</span> p1 +
                               sp (u1 ord_max) (<span class="mi">3</span> * l).+<span class="mi">1</span> 
                                               (a[p1, p3] (<span class="mi">3</span> * l).+<span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">apply</span>: IH cH1.
 <span class="nb">have</span> {}P2 := leq_trans P2 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                          (leq_sum_beta _ _)).
<span class="nb">set</span> xP := sd _; <span class="nb">rewrite</span> -/xP <span class="kr">in</span> P1.
<span class="nb">set</span> x1P := sd _ <span class="kr">in</span> P1.
<span class="nb">rewrite</span> -/x1P (_ : a[p1, p3] (<span class="mi">3</span> * l).+<span class="mi">1</span> = a[p3, p1] l) <span class="kr">in</span> P2; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> apegS apegMr.
<span class="nb">rewrite</span> !sum_beta_S // KH1 KH2 !eqxx addn0 mul1n.
<span class="nb">rewrite</span> !ffunE /= eqxx inord_eq0 // (_ : ai = ord_max) <span class="kr">in</span> P2; <span class="nb">last first</span>.
  <span class="bp">by</span> <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= inordK.
<span class="nb">set</span> x1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P2; <span class="nb">set</span> x2S := \sum_(_ &lt; _) _ <span class="kr">in</span> P2.
<span class="nb">rewrite</span> -/x1S -/x2S .
<span class="nb">rewrite</span> -addnn {<span class="mi">1</span>}dsum_alphaL_S addnAC !addnA leq_add2r.
<span class="nb">rewrite</span> -[X <span class="kr">in</span> _ &lt;= X]addnA.
<span class="nb">apply</span>: leq_trans (leq_add P1 (leqnn _)).
<span class="nb">rewrite</span> -[X <span class="kr">in</span> _ &lt;= X]addnA [x1P + _]addnA.
<span class="nb">apply</span>: leq_trans (leq_add (leqnn _) P2).
<span class="nb">apply</span>: leq_trans (leq_dsum_alpha_2l_l _ _) _.
<span class="nb">rewrite</span> addnC; <span class="nb">apply</span>: leq_add.
  <span class="bp">by</span> <span class="nb">rewrite</span> -addnn -addn1 leq_add.
<span class="nb">rewrite</span> leq_double.
<span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
<span class="bp">by</span> <span class="nb">rewrite</span> doubleS ltnS -mul2n ltn_mul2r l_ggt0.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Case1</span>.

<span class="c">(* This corresponds to the subcase of 4.2 when E is empty *)</span>
<span class="kn">Section</span> <span class="nf">Case2</span>.

<span class="kn">Variable</span> <span class="nv">n</span> : nat.

<span class="kn">Hypothesis</span> <span class="nv">IH</span>:
     <span class="kr">forall</span> (<span class="nv">l</span> : nat) (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : ordinal_eqType <span class="mi">4</span>)
       (<span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">1</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}),
     p1 != p2 -&gt;
     p1 != p3 -&gt;
     p2 != p3 -&gt;
     p1 != p0 -&gt;
     p2 != p0 -&gt;
     p3 != p0 -&gt;
     (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">1</span>,
      <span class="mi">0</span> &lt; k &lt; l -&gt; codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
     (S_[l] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u + sp (u ord0) l (a[p1, p3] <span class="mi">0</span>) +
                            sp (u ord_max) l (a[p1, p3] l).

<span class="kn">Lemma</span> <span class="nf">case2</span> <span class="nv">l</span> (<span class="nv">u</span> :  {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">2</span>}) 
              (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span>: peg <span class="mi">4</span>) :
   p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt;
   p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
     <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
  (u ord0 ord_max = p1) -&gt;
  (u ord_max ord_max = a[p3, p1] l) -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span>, u k ldisk = a[p1, p3] k) -&gt;
  (S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span>).*<span class="mi">2</span> &lt;= sd u + sp (u ord0) l.+<span class="mi">1</span> p1
                             + sp (u ord_max) l.+<span class="mi">1</span> (a[p3, p1] l).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0.
<span class="nb">move</span>=&gt; /= cH KH1 KH2 ukLE.
<span class="nb">pose</span> u&#39;:= ([ffun i =&gt; ‚Üì[u i]] : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>})
 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}.
<span class="nb">have</span> H: <span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
    <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u&#39; k) \subset [:: p2; a[p1, p3] k].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; k kH; <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>/codom_liftr/cH.
<span class="nb">have</span> apegpaD2 a : a[p1, p3] a != p2.
  <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym.
<span class="nb">have</span> apegpaD0 a : a[p1, p3] a != p0.
  <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym.
<span class="nb">pose</span> si i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
    sgdist1 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">pose</span> ti i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
    sgdist2 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">have</span> sitiH i : i &lt; l.+<span class="mi">1</span> -&gt;
    [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
        codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
        `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
          D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
  <span class="nb">move</span>=&gt; iLl.
  <span class="nb">have</span> i1Ll1 : i &lt;= l <span class="bp">by</span> [].
  <span class="nb">apply</span>: sgdistE; <span class="nb">rewrite</span> <span class="nl">?ukLE</span> //.
    <span class="nb">rewrite</span> !inordK //=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW // ltnS.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
<span class="nb">pose</span> u1 := 
  [ffun i =&gt;
  <span class="kr">if</span> ((i : &#39;I_(<span class="mi">3</span> * l.+<span class="mi">1</span>).+<span class="mi">1</span>) %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (i %/ <span class="mi">3</span>))]
  <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> si (i %/ <span class="mi">3</span>)
  <span class="kr">else</span> ti (i %/ <span class="mi">3</span>)].
<span class="nb">have</span> u10E : u1 ord0 = ‚Üì[u ord0].
  <span class="nb">rewrite</span> ffunE /=.
  <span class="bp">by</span> <span class="nb">congr</span> (‚Üì[u _]); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> u1ME : u1 ord_max = ‚Üì[u ord_max].
  <span class="nb">rewrite</span> ffunE /= mod3E /= div3E.
  <span class="bp">by</span> <span class="nb">congr</span> (‚Üì[u _]); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> P1 : l.+<span class="mi">1</span>.*<span class="mi">2</span> + sd u1 = sd u.
  <span class="nb">rewrite</span> /sd.
  <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove).
  <span class="nb">have</span> -&gt; : l.+<span class="mi">1</span>.*<span class="mi">2</span> = \sum_(i &lt; l.+<span class="mi">1</span>) <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord muln2.
  <span class="nb">rewrite</span> -big_split /=; <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">rewrite</span> ffunE !inordK //; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_mul2l ltnW.
  <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /=.
  <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnW // ltnS leq_mul2l /= add1n.
  <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnS leq_mul2l /=.
  <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) mod3E /= div3E.
  <span class="nb">case</span>: (sitiH i) =&gt; // _ _.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= add2n addn0 !addnA add1n.
<span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * l.+<span class="mi">1</span>).+<span class="mi">1</span>) : 
  <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> * l.+<span class="mi">1</span> -&gt; codom (u1 k) \subset [:: p2; a[p1, p3] k].
  <span class="nb">rewrite</span> !ffunE.
  <span class="nb">case</span>: eqP =&gt; [km3E0|/eqP km3D0].
    <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E0 addn0.
    <span class="nb">rewrite</span> muln_gt0 andbT [_ * <span class="mi">3</span>]mulnC ltn_mul2l /= =&gt; /andP[k3_gt0 k3Ll].
    <span class="nb">rewrite</span> apegMr //.
    <span class="nb">have</span>:= @H (inord (k %/ <span class="mi">3</span>)); <span class="nb">rewrite</span> ffunE inordK //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: leq_trans k3Ll _.
    <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">rewrite</span> k3_gt0.
  <span class="nb">case</span>: eqP =&gt; [km3E1|/eqP km3D1].
    <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E1 addn1 /= =&gt; H1.
    <span class="nb">have</span> : <span class="mi">3</span> * (k %/ <span class="mi">3</span>)  &lt; <span class="mi">3</span> * l.+<span class="mi">1</span>.
      <span class="nb">apply</span>: leq_trans H1; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> mulnC ltnW.
      <span class="nb">rewrite</span> ltn_mul2l /= =&gt; k3Ll1.
    <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; //.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS [_ * <span class="mi">3</span>]mulnC apegMr // ukLE inordK // apegS.
  <span class="nb">have</span> km3E2 : k %% <span class="mi">3</span> = <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">case</span>: (_ %% _) (ltn_mod k <span class="mi">3</span>) km3D0 km3D1 =&gt; // [] [|[|]].
  <span class="nb">rewrite</span> {<span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span>}(divn_eq k <span class="mi">3</span>) km3E2 addn2 /= -[_.+<span class="mi">3</span>](mulnDl <span class="mi">1</span> _ <span class="mi">3</span>).
  <span class="nb">rewrite</span> mulnC leq_mul2l /= add1n =&gt; H1.
  <span class="nb">rewrite</span> codom_subC.
  <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; // _ sH _; <span class="nb">move</span>: sH.
  <span class="bp">by</span> <span class="nb">rewrite</span> ukLE // inordK ?(leq_trans H1) // !apegS [_ * <span class="mi">3</span>]mulnC apegMr.
<span class="nb">have</span> {cH1}P2 : 
    (S_[<span class="mi">3</span> * l.+<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u1 + sp (u1 ord0) (<span class="mi">3</span> * l.+<span class="mi">1</span>) p1 
                                    + sp (u1 ord_max) (<span class="mi">3</span> * l.+<span class="mi">1</span>)
                                         (a[p1, p3] (<span class="mi">3</span> * l.+<span class="mi">1</span>)).
  <span class="bp">by</span> <span class="nb">apply</span>: IH cH1.
<span class="nb">have</span> {}P2 := leq_trans P2 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                        (leq_sum_beta _ _)).
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _]big_ord_recr /= ukLE eqxx addn0.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X]big_ord_recr /= ukLE apegS eqxx addn0.
<span class="nb">set</span> x1S := \sum_(_ &lt; n.+<span class="mi">1</span>) _ <span class="kr">in</span> P2; <span class="nb">set</span> x2S := \sum_(_ &lt; n.+<span class="mi">1</span>) _ <span class="kr">in</span> P2.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _](_ : _ = x1S); <span class="nb">last first</span>.
  <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">rewrite</span> u10E ffunE /beta ifF; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> eqn_leq [_ &lt;= i]leqNgt ltn_ord !andbF.
  <span class="bp">by</span> <span class="nb">congr</span> ((u _ _ != _) * _); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /=.
<span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X](_ : _ = x2S); <span class="nb">last first</span>.
  <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">rewrite</span> u1ME ffunE /beta ifF; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> eqn_leq [_ &lt;= i]leqNgt ltn_ord !andbF.
  <span class="nb">congr</span> ((u _ _ != _) * _); <span class="kp">first</span> <span class="bp">by</span> <span class="nb">apply</span>/val_eqP.
  <span class="bp">by</span> <span class="nb">rewrite</span> apegMr // apegS.
<span class="nb">rewrite</span> -P1 -!addnA addnC !addnA.
<span class="nb">apply</span>: leq_trans (leq_add P2 (leqnn _)).
<span class="bp">by</span> <span class="nb">rewrite</span> -doubleD leq_double dsum_alpha3l.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Case2</span>.

<span class="c">(* This corresponds to 4.2 *)</span>
<span class="kn">Section</span> <span class="nf">Case3</span>.

<span class="kn">Variable</span> <span class="nv">n</span> : nat.

<span class="kn">Hypothesis</span> <span class="nv">IH</span>:
  <span class="kr">forall</span> (<span class="nv">l</span> : nat) (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> : ordinal_eqType <span class="mi">4</span>)
    (<span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">1</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}),
  p1 != p2 -&gt;
  p1 != p3 -&gt;
  p2 != p3 -&gt;
  p1 != p0 -&gt;
  p2 != p0 -&gt;
  p3 != p0 -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">1</span>,
  <span class="mi">0</span> &lt; k &lt; l -&gt; codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
  (S_[l] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u + sp (u ord0) l p1 + sp (u ord_max) l (a[p1, p3] l).

<span class="kn">Lemma</span> <span class="nf">case3</span> <span class="nv">l</span> (<span class="nv">u</span> :  {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">2</span>}) 
              (<span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span>: peg <span class="mi">4</span>) :
   p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt;
   p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
     <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
  (u ord0 ord_max = p1) -&gt;
  (u ord_max ord_max = a[p3, p1] l) -&gt;
  (S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span>).*<span class="mi">2</span> &lt;= sd u + sp (u ord0) l.+<span class="mi">1</span> p1 
                             + sp (u ord_max) l.+<span class="mi">1</span> (a[p3, p1] l).
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0.
<span class="nb">move</span>=&gt; cH KH1 KH2.
<span class="nb">pose</span> u&#39;:= ([ffun i =&gt; ‚Üì[u i]] : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>})
 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}.
<span class="nb">have</span> H: <span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
    <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u&#39; k) \subset [:: p2; a[p1, p3] k].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; k kH; <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>/codom_liftr/cH.
<span class="nb">have</span> apegpaD2 a : a[p1, p3] a != p2.
  <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym.
<span class="nb">have</span> apegpaD0 a : a[p1, p3] a != p0.
  <span class="bp">by</span> <span class="nb">rewrite</span> /apeg; <span class="nb">case</span>: odd; <span class="nb">rewrite</span> // eq_sym.
<span class="nb">case</span>: (pickP (<span class="kr">fun</span> <span class="nv">i</span> =&gt; u i ldisk != a[p1, p3] i)) =&gt; [x xH|pH]; <span class="nb">last first</span>.
  <span class="nb">have</span> {pH}ukLE k : u k ldisk = a[p1, p3] k <span class="bp">by</span> <span class="nb">have</span> := pH k; <span class="nb">case</span>: eqP.
  <span class="nb">have</span> := case2 _ _ _ _ _ _ _ cH KH1 KH2 ukLE.
  <span class="bp">by</span> <span class="nb">apply</span>.
<span class="nb">have</span> exH : <span class="kr">exists</span> <span class="nv">x</span>, u (inord x) ldisk != a[p1, p3] x.
  <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> (_ : inord x = x) //.
  <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">case</span>: (@ex_minnP _ exH) =&gt; a aH {exH}aMin.
<span class="nb">have</span> exL : <span class="kr">exists</span> <span class="nv">x</span>, (x &lt;= l) &amp;&amp; (u (inord x) ord_max != a[p1, p3] x).
  <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">apply</span>/andP; <span class="nb">split</span> =&gt; //.
    <span class="nb">have</span> := ltn_ord x.
     <span class="nb">rewrite</span> ltnS leq_eqVlt =&gt; /orP[] // /eqP xEl1.
    <span class="nb">case</span>/eqP: xH.
    <span class="nb">rewrite</span> (_ : x = ord_max); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/val_eqP/eqP.
    <span class="bp">by</span> <span class="nb">apply</span>/eqP/val_eqP; <span class="nb">rewrite</span> /= apegS.
  <span class="bp">by</span> <span class="nb">rewrite</span> (_ : inord x = x) //; <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="nb">have</span> exL1 y : (y &lt;= l) &amp;&amp; (u (inord y) ord_max != a[p1, p3] y) -&gt; y &lt;= l.
  <span class="bp">by</span> <span class="nb">case</span>/andP.
<span class="nb">pose</span> a1 := ex_maxn exL exL1.
<span class="nb">have</span> a1H: u (inord a1) ldisk != a[p1, p3] a1.
  <span class="bp">by</span> <span class="nb">rewrite</span> /a1; <span class="nb">case</span>: ex_maxnP =&gt; i /andP[].
<span class="nb">have</span> a1Ll : a1 &lt;= l <span class="bp">by</span> <span class="nb">rewrite</span> /a1; <span class="nb">case</span>: ex_maxnP =&gt; i /andP[].
<span class="nb">have</span> a1Max i : a1 &lt; i &lt; l.+<span class="mi">2</span> -&gt; u (inord i) ord_max = a[p1, p3] i.
  <span class="nb">case</span>/andP=&gt; a1Li; <span class="nb">rewrite</span> ltnS leq_eqVlt =&gt; /orP[/eqP iEl1|iLl].
    <span class="nb">rewrite</span> iEl1 apegS (_ : inord l.+<span class="mi">1</span> = ldisk) //.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">move</span>: a1Li; <span class="nb">rewrite</span> /a1; <span class="nb">case</span>: ex_maxnP =&gt; j _ /(_ i).
  <span class="bp">by</span> <span class="nb">case</span>: eqP; <span class="nb">rewrite</span> // andbT =&gt; _ /(_ iLl); <span class="nb">rewrite</span> ltnNge =&gt; -&gt;.
<span class="nb">have</span> aLld1 : a &lt;= l.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> -ltnS; <span class="nb">apply</span>: leq_trans (ltn_ord x).
  <span class="nb">rewrite</span> ltnS; <span class="nb">apply</span>: aMin;<span class="nb">rewrite</span> (_ : inord x = x) //.
  <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
<span class="c">(* Showing the symmetry of the problem *)</span>
<span class="nb">wlog</span> aLl1Ba1 : u p1 p3 p1Dp3 p2Dp3 p3Dp0 apegpaD2 apegpaD0 p1Dp2 p1Dp0 
   {u&#39; H xH exL exL1}cH KH1 KH2 a a1 aH aLld1 aMin a1H a1Ll a1Max /
  a &lt;= l.+<span class="mi">1</span> - a1.
  <span class="nb">move</span>=&gt; wH.
  <span class="nb">case</span>: (leqP a (l.+<span class="mi">1</span> -a1)) =&gt; [aLl1Ba1|l1Ba1La].
    <span class="bp">by</span> <span class="nb">apply</span>: wH aLl1Ba1.
  <span class="nb">have</span> a_gt0 : <span class="mi">0</span> &lt; a <span class="bp">by</span> <span class="nb">apply</span>: leq_ltn_trans l1Ba1La.
  <span class="nb">pose</span> u1 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">2</span>} := 
     [ffun i : &#39;I_l.+<span class="mi">2</span> =&gt; u (inord (l.+<span class="mi">1</span> - i))].
  <span class="nb">have</span> -&gt; : sd u = sd u1.
    <span class="nb">have</span> F : injective (<span class="kr">fun</span> <span class="nv">i</span> : &#39;I_l.+<span class="mi">1</span> =&gt; (inord (l - i) : &#39;I_l.+<span class="mi">1</span>)).
      <span class="nb">move</span>=&gt; i j /val_eqP.
        <span class="nb">have</span> lBiLl (i1 : &#39;I_l.+<span class="mi">1</span>) : l - i1 &lt; l.+<span class="mi">1</span>.
          <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR <span class="nl">?leq_addl</span> // -ltnS.
      <span class="nb">rewrite</span> /= !inordK // =&gt; /eqP liE; <span class="nb">apply</span>/val_eqP =&gt; /=.
      <span class="nb">rewrite</span> -(subKn (_ : i &lt;= l)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> liE subKn // -ltnS.
    <span class="nb">rewrite</span> [sd u](reindex_inj F) /=.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">have</span> iLl2 : i &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">apply</span>: leq_trans (ltn_ord _) _.
    <span class="nb">have</span> lBiLl : l - i &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR <span class="nl">?leq_addl</span> // -ltnS.
    <span class="nb">have</span> iLl : i &lt;= l <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS.
    <span class="nb">rewrite</span> gdistC; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/move_sym/ssym.
    <span class="nb">congr</span> (`d[u _,u _]_smove).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK <span class="nl">?subSn</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK // <span class="nl">?subSS</span> ltnS // ltnW.
  <span class="nb">pose</span> p1&#39; := a[p1, p3] l; <span class="nb">pose</span> p3&#39; := a[p3, p1] l.
  <span class="nb">have</span> -&gt; : sp (u ord0) l.+<span class="mi">1</span> p1 = sp (u1 ord_max) l.+<span class="mi">1</span> (a[p1&#39;, p3&#39;] l). 
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> (_ * _).
    <span class="nb">rewrite</span> -apegD addnn apegO odd_double /= apegS apeg0.
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE subnn inord_eq0.
  <span class="nb">have</span> -&gt; : sp (u ord_max) l.+<span class="mi">1</span> (a[p3, p1] l) = sp (u1 ord0) l.+<span class="mi">1</span> p3&#39;.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> (_ * _).
    <span class="nb">rewrite</span> ffunE subn0.
    <span class="nb">suff</span> -&gt; : inord l.+<span class="mi">1</span> = ord_max :&gt; &#39;I_l.+<span class="mi">2</span> <span class="bp">by</span> []. 
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">rewrite</span> addnAC.
  <span class="nb">have</span> FF : (l.+<span class="mi">1</span> - a1) &lt;= l.+<span class="mi">1</span> - (l.+<span class="mi">1</span> - a).
    <span class="bp">by</span> <span class="nb">rewrite</span> leq_sub2l // leq_subLR addnC -leq_subLR ltnW.
  <span class="nb">have</span> a1Ll1 : a1 &lt;= l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans a1Ll).
  <span class="nb">apply</span>: wH FF =&gt; //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_eqC eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; b; <span class="nb">rewrite</span> !apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">move</span>=&gt; b; <span class="nb">rewrite</span> !apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="nb">move</span>=&gt; k /andP[kH1 kH2]; <span class="nb">rewrite</span> ffunE.
    <span class="nb">have</span> F1 : k &lt;= l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: ltnW.
    <span class="nb">have</span> F2 : l.+<span class="mi">1</span> - k &lt; l.+<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR // addnS ltnS leq_addl.
    <span class="nb">have</span> -&gt; :  a[p3&#39;, p1&#39;] k = a[p1, p3] (inord (l.+<span class="mi">1</span> - k) : &#39;I_l.+<span class="mi">2</span>) .
      <span class="nb">rewrite</span> inordK // -apegD -apegS -addnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> [LHS]apegO [RHS]apegO oddD oddB //= addbC.
    <span class="nb">apply</span>: cH; <span class="nb">rewrite</span> inordK // subn_gt0 // ltn_subLR // kH2 //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> addnS ltnS -{<span class="mi">1</span>}[l.+<span class="mi">1</span>]add1n leq_add2r.
  - <span class="nb">rewrite</span> !ffunE /p1&#39; subn0 -[RHS]KH2; <span class="nb">congr</span> (u _ _); <span class="nb">apply</span>/val_eqP.
    <span class="bp">by</span> <span class="nb">rewrite</span> /= inordK.
  - <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE /p1&#39; subnn inord_eq0 // KH1 /p3&#39; -apegD addnn apeg_double.
  - <span class="nb">rewrite</span> ffunE inordK //=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_subr. 
    <span class="nb">rewrite</span> subKn // -apegD apegO oddD oddB //= addbAC !addNb addbb /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> -oddS -apegO apegS.
  - <span class="bp">by</span> <span class="nb">rewrite</span> leq_subr.
  - <span class="nb">move</span>=&gt; k; <span class="nb">rewrite</span> ffunE.
    <span class="nb">case</span>: leqP =&gt; //; <span class="nb">rewrite</span> ltn_subRL addnC -ltn_subRL =&gt; kH.
    <span class="nb">have</span> kLl1 : k &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn_gt0 (leq_ltn_trans _ kH).
      <span class="nb">rewrite</span> inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="nb">have</span> /a1Max-&gt; : a1 &lt; l.+<span class="mi">1</span> - k &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> kH /= ltnS leq_subr.
    <span class="nb">case</span>/eqP; <span class="nb">rewrite</span> -apegD apegO oddB <span class="mi">1</span><span class="nl">?ltnW</span> // -oddD -apegO.
    <span class="bp">by</span> <span class="nb">rewrite</span> addSn addnC apegS.
  - <span class="nb">rewrite</span> ffunE inordK <span class="nl">?ltnS</span> <span class="nl">?leq_subr</span> //.
    <span class="nb">rewrite</span> subKn //.
    <span class="nb">rewrite</span> -apegD apegO oddD oddB //= !addNb addbAC addbb /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> -oddS -apegO apegS.
  - <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK // subSS leq_subr.
  <span class="nb">move</span>=&gt; k /andP[l1BaLk kLl2]; <span class="nb">rewrite</span> ffunE.
  <span class="nb">rewrite</span> inordK //; <span class="nb">apply</span>/eqP; <span class="nb">case</span>: eqP =&gt; // /eqP.
  <span class="nb">suff</span> -&gt; : a[p3&#39;, p1&#39;] k = a[p1, p3] (l.+<span class="mi">1</span> - k).
    <span class="bp">by</span> <span class="nb">move</span>=&gt; /aMin; <span class="nb">rewrite</span> leqNgt ltn_subLR // addnC -ltn_subLR // l1BaLk.
  <span class="bp">by</span> <span class="nb">rewrite</span> [RHS]apegO oddB // -oddD -apegO addSn apegS addnC apegD.
<span class="nb">pose</span> u&#39;:= ([ffun i =&gt; ‚Üì[u i]] : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>})
 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>}.
<span class="nb">have</span> H: <span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">2</span>,
    <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u&#39; k) \subset [:: p2; a[p1, p3] k].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; k kH; <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>/codom_liftr/cH.
<span class="nb">have</span> aMin1 i : i &lt; a -&gt; u (inord i) ord_max = a[p1, p3] i.
  <span class="bp">by</span> <span class="nb">case</span>: (u (inord i) ord_max =P a[p1, p3] i) =&gt; // /eqP /aMin; <span class="nb">case</span>: leqP.
<span class="nb">have</span> a_gt0 : <span class="mi">0</span> &lt; a.
  <span class="nb">have</span> : <span class="mi">0</span> &lt;= a <span class="bp">by</span> [].
  <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP aE0|] //.
  <span class="bp">by</span> <span class="nb">case</span>/eqP: aH; <span class="nb">rewrite</span> inord_eq0 // -aE0.
<span class="nb">pose</span> ai : &#39;I_l.+<span class="mi">2</span> := inord a.
<span class="nb">have</span> aiE : ai = a :&gt; nat <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
<span class="nb">have</span> aLa1 : a &lt;= a1.
  <span class="nb">case</span>: leqP =&gt; // =&gt; a1La.
  <span class="bp">by</span> <span class="nb">case</span>/eqP: aH; <span class="nb">apply</span>: a1Max; <span class="nb">rewrite</span> a1La.
<span class="nb">have</span> uaLEp2 : u (inord a) ldisk = p2.
  <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a_gt0 /= (leq_ltn_trans _ (_ : a1 &lt; l.+<span class="mi">1</span>)).
  <span class="nb">move</span>=&gt; /subsetP/(_ (u (inord a) ldisk) (codom_f _ _)).
  <span class="bp">by</span> <span class="nb">rewrite</span> !inE inordK // (negPf aH) orbF =&gt; /eqP.
<span class="nb">have</span> ua1LEp2 : u (inord a1) ldisk = p2.
  <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a1 : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> inordK // !ltnS (leq_trans a1Ll) // (leq_trans a_gt0).
  <span class="nb">move</span>=&gt; /subsetP/(_ (u (inord a1) ldisk) (codom_f _ _)).
  <span class="bp">by</span> <span class="nb">rewrite</span> !inE inordK <span class="nl">?ltnS</span> ?(leq_trans a1Ll) // (negPf a1H) orbF =&gt; /eqP.
<span class="nb">have</span> a1_gt0 : <span class="mi">0</span> &lt; a1 <span class="bp">by</span> <span class="nb">apply</span>: leq_trans a_gt0 _.
<span class="nb">pose</span> b := a1 - a.
<span class="nb">pose</span> c := l.+<span class="mi">1</span> - a1.
<span class="nb">have</span> c_gt0 : <span class="mi">0</span> &lt; c <span class="bp">by</span> <span class="nb">rewrite</span> subn_gt0.
<span class="nb">have</span> l1E : l.+<span class="mi">1</span> = a + b + c.
  <span class="bp">by</span> <span class="nb">rewrite</span> /b /c [a + _]addnC subnK // addnC subnK // ltnW.
<span class="nb">pose</span> si i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
   sgdist1 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">pose</span> ti i : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
   sgdist2 p2 (u (inord i)) (u (inord i.+<span class="mi">1</span>)).
<span class="nb">have</span> sitiH i : i &lt; a.-<span class="mi">1</span> -&gt;
   [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
       codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
       `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
         D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
  <span class="nb">move</span>=&gt; iLa.
  <span class="nb">have</span> iLa1 : i &lt; a <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans iLa) // ssrnat.leq_pred.
  <span class="nb">apply</span>: sgdistE; <span class="nb">rewrite</span> <span class="nl">?aMin1</span> // -<span class="mi">1</span>?[a]prednK //.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
<span class="nb">pose</span> pa := a[p1, p3] a.
<span class="nb">pose</span> sam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := sgdist1 pa (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
<span class="nb">pose</span> tam1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := sgdist2 pa (u (inord a.-<span class="mi">1</span>)) (u (inord a)).
<span class="nb">have</span> [sam1C tam1C duam1ua1E] : 
   [/\ codom sam1 \subset [:: pa; u (inord a) ldisk ], 
       codom tam1 \subset [:: u (inord a.-<span class="mi">1</span>) ldisk; pa] &amp; 
       `d[u (inord a.-<span class="mi">1</span>), u (inord a)]_smove = 
         D[[:: ‚Üì[u (inord a.-<span class="mi">1</span>)]; sam1; tam1; ‚Üì[u (inord a)]]].+<span class="mi">2</span>].
  <span class="nb">apply</span>: sgdistE; <span class="nb">rewrite</span> /pa <span class="nl">?uaLEp2</span> <span class="nl">?aMin1</span> <span class="nl">?prednK</span> //.
  <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}(prednK a_gt0) apegS apeg_eqC.
<span class="nb">rewrite</span> uaLEp2 <span class="kr">in</span> sam1C.
<span class="nb">have</span> {}tam1C : codom tam1 \subset [:: p1; p3].
  <span class="nb">move</span>: tam1C; <span class="nb">rewrite</span> aMin1; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK.
  <span class="bp">by</span> <span class="nb">rewrite</span> /pa  -{<span class="mi">2</span>}[a]prednK // apegS codom_apeg.
<span class="nb">pose</span> u1 := 
  [ffun i : &#39;I_(<span class="mi">3</span> * a).+<span class="mi">1</span> =&gt;
  <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (i %/ <span class="mi">3</span>))]
  <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> 
     (<span class="kr">if</span> i == (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span> :&gt; nat <span class="kr">then</span> sam1 <span class="kr">else</span> si (i %/ <span class="mi">3</span>))
  <span class="kr">else</span> 
     (<span class="kr">if</span> i == (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">2</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span> ti (i %/ <span class="mi">3</span>))].
<span class="nb">have</span> u10E : u1 ord0 = ‚Üì[u ord0] <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= inord_eq0.
<span class="nb">have</span> uiME : u1 ord_max = ‚Üì[u (inord a)] <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= mod3E /= div3E.
<span class="nb">have</span> P1 :  a.*<span class="mi">2</span> + sd u1 = \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
  <span class="nb">rewrite</span> /sd.
  <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove).
  <span class="nb">have</span> -&gt; : a.*<span class="mi">2</span> = \sum_(i &lt; a) <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord muln2.
  <span class="nb">rewrite</span> -big_split /=.
  <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i)) = ‚Üì[u (inord i)].
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_mul2l /= ltnW.
    <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">3</span>) = ‚Üì[u (inord i.+<span class="mi">1</span>)].
    <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>).
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_mul2l /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">have</span> [/eqP iEa| iDa] := boolP (i == a.-<span class="mi">1</span> :&gt; nat).
    <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = sam1.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /=.
      <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="bp">by</span> <span class="nb">rewrite</span> iEa eqxx.
    <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = tam1.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnW // add1n ltnS leq_mul2l /=.
      <span class="nb">rewrite</span> mod3E /= div3E.
      <span class="bp">by</span> <span class="nb">rewrite</span> iEa eqxx.
    <span class="bp">by</span> <span class="nb">rewrite</span> iEa prednK // duam1ua1E /= -!addnA add2n !addnA addn0.
  <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = si i.
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /=.
    <span class="nb">rewrite</span> mod3E /= div3E.
    <span class="bp">by</span> <span class="nb">rewrite</span> [_.+<span class="mi">1</span> == _.+<span class="mi">1</span>]eqn_mul2l /= (negPf iDa).
  <span class="nb">have</span> -&gt; : u1 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = ti i.
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnW // ltnS add1n leq_mul2l /=.
    <span class="nb">rewrite</span> mod3E /= div3E.
    <span class="bp">by</span> <span class="nb">rewrite</span> [_.+<span class="mi">1</span> == _.+<span class="mi">1</span>]eqn_mul2l /= (negPf iDa).
  <span class="nb">case</span>: (sitiH i) =&gt; // [|_ _ -&gt;].
    <span class="nb">rewrite</span> -ltnS prednK //.
    <span class="nb">have</span> := ltn_ord i; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[] //.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // [_ == _](negPf iDa).
  <span class="bp">by</span> <span class="nb">rewrite</span> /= -!addnA add2n addn0.
<span class="nb">have</span> sitiHb i : a1 &lt; i &lt; l.+<span class="mi">1</span> -&gt;
   [/\ codom (si i) \subset [:: p2; u (inord i.+<span class="mi">1</span>) ldisk ], 
       codom (ti i) \subset [:: u (inord i) ldisk; p2] &amp; 
       `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove = 
         D[[:: ‚Üì[u (inord i)]; si i; ti i; ‚Üì[u (inord i.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
  <span class="nb">move</span>=&gt; /andP[a1Li iLl].
  <span class="nb">apply</span>: sgdistE =&gt; //; 
      <span class="nb">rewrite</span> !a1Max <span class="nl">?a1Li</span> ?(leq_trans a1Li) // ?(leq_trans iLl) //.
    <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
<span class="nb">pose</span> sa1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
  sgdist1 (a[p1, p3] a1) (u (inord a1)) (u (inord a1.+<span class="mi">1</span>)).
<span class="nb">pose</span> ta1 : configuration <span class="mi">4</span> n.+<span class="mi">1</span> := 
  sgdist2 (a[p1, p3] a1) (u (inord a1)) (u (inord a1.+<span class="mi">1</span>)).
<span class="nb">have</span> [sa1C ta1C dua1uad1E] : 
   [/\ codom sa1 \subset [:: a[p1, p3] a1; u (inord a1.+<span class="mi">1</span>) ldisk ], 
       codom ta1 \subset [:: u (inord a1) ldisk; a[p1, p3] a1] &amp; 
       `d[u (inord a1), u (inord a1.+<span class="mi">1</span>)]_smove = 
         D[[:: ‚Üì[u (inord a1)]; sa1 ; ta1; ‚Üì[u (inord a1.+<span class="mi">1</span>)]]].+<span class="mi">2</span>].
  <span class="nb">apply</span>: sgdistE; <span class="nb">rewrite</span> <span class="nl">?ua1LEp2</span> <span class="nl">?a1Max</span> <span class="nl">?leqnn</span> // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
  <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC eq_sym.
<span class="nb">rewrite</span> ua1LEp2 <span class="kr">in</span> ta1C.
<span class="nb">have</span> {}sa1C : codom sa1 \subset [:: p1; p3].
  <span class="nb">move</span>: sa1C; <span class="nb">rewrite</span> a1Max //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leqnn.
  <span class="bp">by</span> <span class="nb">rewrite</span> apegS codom_apeg.
<span class="nb">pose</span> u2 := 
  [ffun i : &#39;I_(<span class="mi">3</span> * c).+<span class="mi">1</span> =&gt;
  <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">0</span> <span class="kr">then</span> ‚Üì[u (inord (a1 +(i %/ <span class="mi">3</span>)))]
  <span class="kr">else</span> <span class="kr">if</span> (i %% <span class="mi">3</span>) == <span class="mi">1</span> <span class="kr">then</span> 
     (<span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> si (a1 + (i %/ <span class="mi">3</span>)))
  <span class="kr">else</span> 
     (<span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> ta1 <span class="kr">else</span> ti (a1 + (i %/ <span class="mi">3</span>)))].
<span class="nb">have</span> u20E : u2 ord0 = ‚Üì[u (inord a1)] <span class="bp">by</span> <span class="nb">rewrite</span> ffunE /= addn0.
<span class="nb">have</span> u2ME : u2 ord_max = ‚Üì[u ord_max].
  <span class="nb">rewrite</span> ffunE /= mod3E /= div3E addnC subnK //.
    <span class="bp">by</span> <span class="nb">rewrite</span> (_ : inord _ = ord_max) //; <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS.
<span class="nb">have</span> P2 : c.*<span class="mi">2</span> + sd u2 = 
  \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>)  `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
  <span class="nb">have</span> -&gt; : \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove =
            \sum_(i &lt; c) `d[u (inord (a1 + i)), u (inord (a1 + i).+<span class="mi">1</span>)]_smove.
    <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a1]add0n big_addn big_mkord.
    <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> addnC.
  <span class="nb">rewrite</span> /sd.
  <span class="nb">have</span> -&gt; := @sum3E _ (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove).
  <span class="nb">have</span> -&gt; : c.*<span class="mi">2</span> = \sum_(i &lt; c) <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> sum_nat_const /= cardT size_enum_ord muln2.
  <span class="nb">rewrite</span> -big_split /=.
  <span class="nb">apply</span>: eq_bigr =&gt; i _.
  <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i)) = ‚Üì[u (inord (a1 + i))].
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_mul2l /= ltnW.
    <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E.
  <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i).+<span class="mi">3</span>) = ‚Üì[u (inord (a1 + i).+<span class="mi">1</span>)].
    <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>).
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS leq_mul2l /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= div3E // add1n addnS.
  <span class="nb">have</span> [/eqP iEa| iDa] := boolP (i == <span class="mi">0</span> :&gt; nat).
    <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = sa1.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /=.
      <span class="nb">rewrite</span> mod3E /=.
      <span class="bp">by</span> <span class="nb">rewrite</span> iEa eqxx.
    <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = ta1.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnW // add1n ltnS leq_mul2l /=.
      <span class="nb">rewrite</span> mod3E /=.
      <span class="bp">by</span> <span class="nb">rewrite</span> iEa eqxx.
    <span class="bp">by</span> <span class="nb">rewrite</span> iEa !addn0 // dua1uad1E /= -!addnA add2n !addnA addn0.
  <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i).+<span class="mi">1</span>) = si (a1 + i).
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /=.
    <span class="nb">rewrite</span> mod3E /= div3E.
    <span class="bp">by</span> <span class="nb">rewrite</span> [_.+<span class="mi">1</span> == _.+<span class="mi">1</span>](eqn_mul2l <span class="mi">3</span> _ <span class="mi">0</span>) /= (negPf iDa).
  <span class="nb">have</span> -&gt; : u2 (inord (<span class="mi">3</span> * i).+<span class="mi">2</span>) = ti (a1 + i).
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) ltnW // ltnS add1n leq_mul2l /=.
    <span class="nb">rewrite</span> mod3E /= div3E.
    <span class="bp">by</span> <span class="nb">rewrite</span> [_.+<span class="mi">1</span> == _.+<span class="mi">1</span>](eqn_mul2l <span class="mi">3</span> _ <span class="mi">0</span>) /= (negPf iDa).
  <span class="nb">case</span>: (sitiHb (a1 + i)) =&gt; // [|_ _ -&gt;].
    <span class="nb">rewrite</span> -addn1 leq_add2l lt0n iDa /= -[l.+<span class="mi">1</span>](subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)).
      <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnW.
  <span class="bp">by</span> <span class="nb">rewrite</span> /= -!addnA add2n addn0.
<span class="nb">have</span> P3 : 
     \sum_(a &lt;= i &lt; a1) `d[‚Üì[u (inord i)], ‚Üì[u (inord i.+<span class="mi">1</span>)]]_smove &lt;=
     \sum_(a &lt;= i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
  <span class="nb">apply</span>: leq_sum =&gt; i _.
  <span class="bp">by</span> <span class="nb">apply</span>: gdist_cunlift; <span class="nb">apply</span>: shanoi_connect.
<span class="nb">have</span> SH : <span class="mi">2</span> &lt;= l -&gt; 
  (S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span>).*<span class="mi">2</span>  &lt;= S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[l] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
  <span class="nb">move</span>=&gt; l_gt2.
  <span class="nb">rewrite</span> -addnn -!addnA leq_add2l.
  <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
<span class="nb">have</span> [/andP[a_gt1 c_gt1]|] := boolP ((<span class="mi">1</span> &lt; a) &amp;&amp; (<span class="mi">1</span> &lt; c)).
<span class="c">(* This is 4.2.1 *)</span>
  <span class="nb">have</span> l_gt0 : <span class="mi">0</span> &lt; l <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E (leq_trans c_gt1) // leq_addl.
  <span class="nb">rewrite</span> !sum_beta_S //= KH1 KH2 !eqxx !addn0. 
  <span class="nb">pose</span> u1l := [ffun i : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span> =&gt; u1 (inord i)].
  <span class="nb">have</span> a3_gt1 : <span class="mi">1</span> &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK a_gt1) addn2 !mulnS.
  <span class="nb">have</span> c3_gt1 : <span class="mi">1</span> &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK c_gt1) addn2 !mulnS.
  <span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * a).-<span class="mi">2</span>.+<span class="mi">1</span>) : 
    <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span> -&gt; codom (u1l k) \subset [:: p2; a[p1, p3] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k3L3a].
    <span class="nb">have</span> k3La1 : k %/ <span class="mi">3</span> &lt;= a.-<span class="mi">1</span>.
      <span class="nb">have</span> kL3a : k &lt;= <span class="mi">3</span> * (a.-<span class="mi">1</span>).
        <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>]subn1 mulnBr -ltnS -[<span class="mi">3</span> *<span class="mi">1</span>]/(<span class="mi">2</span>.+<span class="mi">1</span>) subnSK.
          <span class="bp">by</span> <span class="nb">rewrite</span> subn2.
        <span class="bp">by</span> <span class="nb">rewrite</span> (leq_mul2l <span class="mi">3</span> <span class="mi">1</span>).
      <span class="bp">by</span> <span class="nb">rewrite</span> -[a.-<span class="mi">1</span>](mulKn _ (_ : <span class="mi">0</span> &lt; <span class="mi">3</span>)) // leq_div2r.
    <span class="nb">have</span> k3Ll : k %/ <span class="mi">3</span> &lt; l.
      <span class="nb">rewrite</span> -ltnS l1E (leq_trans (_ : _ &lt; a.-<span class="mi">1</span>.+<span class="mi">3</span>)) //; <span class="nb">last first</span>.
        <span class="nb">rewrite</span> prednK // addnAC -addn2 (leq_trans (_ : _ &lt;= a + c)) //.
          <span class="bp">by</span> <span class="nb">rewrite</span> leq_add2l.
        <span class="bp">by</span> <span class="nb">rewrite</span> leq_addr.
      <span class="bp">by</span> <span class="nb">rewrite</span> !ltnS ltnW // ltnS.
    <span class="nb">rewrite</span> !ffunE inordK //; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> (leq_trans (ltn_ord _)) // -subn2 ltn_subLR.
        <span class="bp">by</span> <span class="nb">rewrite</span> add2n ltnS // ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : _ &lt; <span class="mi">3</span> * <span class="mi">1</span>)) // leq_mul2l.
    <span class="nb">rewrite</span> {<span class="mi">8</span>}(divn_eq k <span class="mi">3</span>) apegD [_ * <span class="mi">3</span>]mulnC apegMr //=.
    <span class="nb">case</span>: eqP =&gt; [km3E0 /= |/eqP km3D0].
      <span class="nb">have</span> k3_gt0 : <span class="mi">0</span> &lt; k %/ <span class="mi">3</span>.
        <span class="nb">case</span>: (k: nat) k_gt0 km3E0  =&gt; // [] [|[|k1 _ _]] //.
        <span class="bp">by</span> <span class="nb">rewrite</span> (divnMDl <span class="mi">1</span> k1 (_ : <span class="mi">0</span> &lt; <span class="mi">3</span>)).
      <span class="nb">rewrite</span> km3E0 !apeg0.
      <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord (k %/ <span class="mi">3</span>) : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> inordK //.
          <span class="bp">by</span> <span class="nb">rewrite</span> k3_gt0 /= (leq_trans k3Ll).
        <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans k3Ll) // ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK // (leq_trans k3Ll) // ltnW .
    <span class="nb">case</span>: eqP =&gt; [km3E1|/eqP km3D1].
      <span class="nb">rewrite</span> km3E1 !apegS !apeg0; <span class="nb">case</span>: eqP =&gt; [-&gt;|kE3a1].
        <span class="nb">rewrite</span> (_ : (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span> = a.-<span class="mi">1</span> * <span class="mi">3</span> + <span class="mi">1</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> addn1 mulnC.
        <span class="nb">rewrite</span> divnMDl // divn_small // addn0.
        <span class="bp">by</span> <span class="nb">have</span> := sam1C; <span class="nb">rewrite</span> codom_subC /pa -{<span class="mi">1</span>}[a]prednK //= apegS.
      <span class="nb">move</span>: k3La1; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP k3Ea1| k3La].
        <span class="nb">case</span>: kE3a1.
        <span class="bp">by</span> <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) km3E1 k3Ea1 mulnC addn1.
      <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; // siH _ _; <span class="nb">move</span>: siH.
      <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 <span class="nl">?apegS</span> // -{<span class="mi">2</span>}[a]prednK .
    <span class="nb">have</span> km3E2 : k %% <span class="mi">3</span> = <span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">case</span>: (_ %% _) (ltn_mod k <span class="mi">3</span>) km3D0 km3D1 =&gt; // [] [|[|]].
    <span class="nb">rewrite</span> km3E2 !apegS !apeg0; <span class="nb">case</span>: eqP =&gt; [kE3a1|kD3a1].
      <span class="nb">rewrite</span> ltnNge <span class="kr">in</span> k3L3a; <span class="nb">case</span>/negP: k3L3a.
      <span class="bp">by</span> <span class="nb">rewrite</span> kE3a1 -{<span class="mi">1</span>}[a]prednK // mulnS.
    <span class="nb">move</span>: k3La1; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP k3Ea1| k3La].
      <span class="nb">case</span>: kD3a1.
      <span class="bp">by</span> <span class="nb">rewrite</span> (divn_eq k <span class="mi">3</span>) km3E2 k3Ea1 mulnC addn2.
    <span class="nb">rewrite</span> codom_subC.
    <span class="nb">case</span>: (sitiH (k %/ <span class="mi">3</span>)) =&gt; // _ tiH _; <span class="nb">move</span>: tiH.
    <span class="bp">by</span> <span class="nb">rewrite</span> aMin1 // -{<span class="mi">2</span>}[a]prednK // ltnS ltnW.
    <span class="nb">have</span> {cH1}P4 : 
      (S_[(<span class="mi">3</span> * a).-<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      \sum_(i &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove +
      \sum_(k &lt; n.+<span class="mi">1</span>) (‚Üì[u ord0] k != p1) * Œ≤_[n.+<span class="mi">1</span>, (<span class="mi">3</span> * a).-<span class="mi">2</span>] k +
      \sum_(k &lt; n.+<span class="mi">1</span>) (sam1 k != pa) * Œ≤_[n.+<span class="mi">1</span>, (<span class="mi">3</span> * a).-<span class="mi">2</span>] k.
    <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH1) _ =&gt; //.
    <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
    <span class="nb">congr</span> (_ + _ + _); <span class="nb">apply</span>: eq_bigr =&gt; i _.
    - <span class="bp">by</span> <span class="nb">rewrite</span> ![u1l _]ffunE !inordK // ltnS // ltnW.
    - <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inord_eq0 // ffunE /= inord_eq0.
    <span class="nb">rewrite</span> !ffunE /= inordK //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS -subn2 leq_subr.
    <span class="nb">rewrite</span> (_ : _.-<span class="mi">2</span> = (<span class="mi">3</span> * a.-<span class="mi">1</span>).+<span class="mi">1</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
    <span class="nb">rewrite</span> mod3E /= eqxx.
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa apegS apegMr //= -apegS prednK.
  <span class="nb">have</span> {}P4 := leq_trans P4 (leq_add (leq_add (leqnn _) 
                     (leq_sum_beta _ _)) (leqnn _)).
  <span class="nb">set</span> x1S := \sum_(_ &lt; _.+<span class="mi">1</span>) _ <span class="kr">in</span> P4; <span class="nb">set</span> x2S := \sum_(_ &lt; _.+<span class="mi">1</span>) _ <span class="kr">in</span> P4.
  <span class="nb">rewrite</span> -/x1S.
  <span class="nb">pose</span> u2r := [ffun i : &#39;I_(<span class="mi">3</span> * c).-<span class="mi">2</span>.+<span class="mi">1</span> =&gt; u2 (inord i.+<span class="mi">2</span>)].
  <span class="nb">pose</span> pa1 := a[p1, p3] a1.
  <span class="nb">pose</span> pa1S := a[p1, p3] a1.+<span class="mi">1</span>.
  <span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * c).-<span class="mi">2</span>.+<span class="mi">1</span>) : 
    <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span> -&gt; codom (u2r k) \subset [:: p2; a[pa1, pa1S] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k3L3a].
    <span class="nb">have</span> k2L3c : k.+<span class="mi">2</span> &lt; (<span class="mi">3</span> * c).
      <span class="bp">by</span> <span class="nb">have</span> := k3L3a; <span class="nb">rewrite</span> -{<span class="mi">2</span>}subn2 ltn_subRL add2n.    
    <span class="nb">rewrite</span> !ffunE inordK <span class="nl">?ltnS</span> <span class="mi">1</span><span class="nl">?ltnW</span> //.
    <span class="nb">case</span>: eqP =&gt; [km3E0 /= |/eqP km3D0].
      <span class="nb">have</span> k3_gt0 : <span class="mi">0</span> &lt; k.+<span class="mi">2</span> %/ <span class="mi">3</span>.
        <span class="nb">case</span>: (k: nat) k_gt0 km3E0  =&gt; // [] //= k1 _ _.
        <span class="bp">by</span> <span class="nb">rewrite</span> (divnMDl <span class="mi">1</span> k1 (_ : <span class="mi">0</span> &lt; <span class="mi">3</span>)).
      <span class="nb">have</span> a1k3Ll1 : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
        <span class="nb">move</span>: k2L3c.
        <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E0 addn0 mulnC ltn_mul2l /= =&gt; k2L3c.
        <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
        <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
      <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>)) ; <span class="nb">last first</span>.
        <span class="nb">rewrite</span> /pa1 /pa1S apegS -apegD -<span class="mi">2</span>!apegS -!addSn addnC.
        <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E0 addn0 apegO.
        <span class="bp">by</span> <span class="nb">rewrite</span> oddD oddM andbT -oddD -apegO.
      <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>) : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> inordK; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> addn_gt0 a1_gt0.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK // ltnS ltnW.
    <span class="nb">case</span>: eqP =&gt; [km3E1|/eqP km3D1].
      <span class="nb">rewrite</span> eqn_leq ltnNge /=.
      <span class="nb">have</span> a1La1k : a1 &lt; a1 + k.+<span class="mi">2</span> %/<span class="mi">3</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(addn0 a1) ltn_add2l divn_gt0.
      <span class="nb">have</span> a1k3Ll : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
        <span class="nb">move</span>: (ltnW k2L3c).
        <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E1 addn1 mulnC ltn_mul2l /=.
        <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
        <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
      <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span>)) ; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S apegS -apegD !addnS addnC !apegS.
      <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p3, p1] (a1 + (k.+<span class="mi">2</span>) %/ <span class="mi">3</span>)) ; <span class="nb">last first</span>.
        <span class="nb">rewrite</span> apegO oddD {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) oddD km3E1 addbT oddM andbT.
        <span class="bp">by</span> <span class="nb">rewrite</span> addbN -oddD -oddS -apegO apegS.
      <span class="nb">case</span>: (sitiHb (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>)) =&gt; // [| siH _ _].
        <span class="bp">by</span> <span class="nb">rewrite</span> a1La1k.
      <span class="bp">by</span> <span class="nb">move</span>: siH; <span class="nb">rewrite</span> a1Max <span class="nl">?apegS</span> // ltnS ltnW.
    <span class="nb">have</span> km3E2 : k.+<span class="mi">2</span> %% <span class="mi">3</span> = <span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">case</span>: (_ %% _) (ltn_mod k.+<span class="mi">2</span> <span class="mi">3</span>) km3D0 km3D1 =&gt; // [] [|[|]].
    <span class="nb">rewrite</span> ifN; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0.
    <span class="nb">have</span> a1La1k : a1 &lt; a1 + k.+<span class="mi">2</span> %/<span class="mi">3</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(addn0 a1) ltn_add2l divn_gt0.
    <span class="nb">have</span> a1k3Ll : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
      <span class="nb">have</span>: k.+<span class="mi">2</span> %/ <span class="mi">3</span> * <span class="mi">3</span> &lt; <span class="mi">3</span> * c.
        <span class="nb">rewrite</span> ltnW //.
        <span class="nb">move</span>: (ltnW k2L3c).
        <span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E2 addn2.
      <span class="nb">rewrite</span> mulnC ltn_mul2l /=.
      <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span>)) ; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa1 /pa1S apegS -apegD addnC !addnS !apegS.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + (k.+<span class="mi">2</span>) %/ <span class="mi">3</span>)) ; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> apegO /= oddD {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) !oddD oddM andbT.
      <span class="bp">by</span> <span class="nb">rewrite</span> km3E2 addbF -oddD -apegO.
    <span class="nb">rewrite</span> codom_subC.
    <span class="nb">case</span>: (sitiHb (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>)) =&gt; // [| _ tiH _]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> a1La1k.
    <span class="bp">by</span> <span class="nb">move</span>: tiH; <span class="nb">rewrite</span> a1Max // a1La1k ltnS ltnW.
  <span class="nb">have</span> P5 :
    (S_[(<span class="mi">3</span> * c).-<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=       
    \sum_(i &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>) `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove +
    sp ta1 (<span class="mi">3</span> * c).-<span class="mi">2</span>  pa1 + sp ‚Üì[u ord_max] (<span class="mi">3</span> * c).-<span class="mi">2</span> (a[p3, p1] l).
    <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH1) _; <span class="nb">rewrite</span> /pa1 /pa1S {cH1}//.
    - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
    - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
    <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
    - <span class="nb">apply</span>: eq_bigr =&gt; i _.
      <span class="bp">by</span> <span class="nb">rewrite</span> ![u2r _]ffunE !inordK // ltnS // ltnW.
    - <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> ((_ != _) * _).
      <span class="nb">rewrite</span> !ffunE /= !inordK //=.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">2</span> &lt; (<span class="mi">3</span> * <span class="mi">1</span>).+<span class="mi">1</span>)) // ltnS leq_mul2l.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> ((_ != _) * _).
      <span class="nb">rewrite</span> !ffunE /= !prednK <span class="nl">?muln_gt0</span> //=; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0 (leq_trans (_ : _ &lt; <span class="mi">3</span> * <span class="mi">1</span>)) // 
                   leq_mul2l.
      <span class="nb">rewrite</span> inordK // mod3E /= div3E addnC subnK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">apply</span>: (leq_trans a1Ll).
      <span class="bp">by</span> <span class="nb">rewrite</span> ffunE; <span class="nb">congr</span> (u _ _ ); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">rewrite</span> -[RHS]apegS -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) // -/c.
      <span class="nb">rewrite</span> apegS -apegD apegO oddD -subn2 oddB.
        <span class="bp">by</span> <span class="nb">rewrite</span> addbF oddM /= -oddD -apegO.
      <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : _ &lt; <span class="mi">3</span> * <span class="mi">1</span>)) // leq_mul2l //.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnW.
  <span class="nb">rewrite</span> {cH1}//.
  <span class="nb">have</span> {}P5 := 
    leq_trans P5 (leq_add (leqnn _) (leq_sum_beta _ _)).
  <span class="nb">set</span> y1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P5; <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P5.
  <span class="nb">have</span> [b_gt1|b_le2] := leqP <span class="mi">2</span> b.
<span class="c">(*   subcase b &gt;= 2 *)</span>
    <span class="nb">pose</span> u3 := [ffun i : &#39;I_3 =&gt;
                 <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> sam1 
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span> ‚Üì[u (inord a)]].
    <span class="nb">have</span> cH6 (k : &#39;I_3) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">2</span> -&gt; codom (u3 k) \subset [:: p1; a[p2, p3] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt2].
      <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">have</span> -&gt;/= : k = <span class="mi">1</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0 k_lt2 =&gt; // [] [|].
    <span class="nb">have</span> P6 : 
      (S_[<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      (`d[sam1, tam1]_smove + `d[tam1, ‚Üì[u (inord a)]]_smove) + sp sam1 <span class="mi">2</span> p2 
                                                + sp ‚Üì[u (inord a)] <span class="mi">2</span> p2.
      <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH6)) =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK /=.
      - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">rewrite</span> {cH6}// <span class="kr">in</span> P6.
    <span class="nb">set</span> x3S := sp _ _ _ <span class="kr">in</span> P6; <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P6.
    <span class="nb">have</span> x2Sx3SE : x2S + x3S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="mi">2</span>] n.
      <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE; <span class="bp">by</span> <span class="nb">rewrite</span> /pa.
    <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> x2Sx3SE.
    <span class="nb">pose</span> u4 := [ffun i : &#39;I_b.+<span class="mi">1</span> =&gt; ‚Üì[u (inord (a + i))]].
    <span class="nb">pose</span> paS := a[p1, p3] a.+<span class="mi">1</span>.
    <span class="nb">have</span> cH7 (k : &#39;I_b.+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; b -&gt; codom (u4 k) \subset [:: p2; a[pa, paS] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
      <span class="nb">have</span> akLl : a + k &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span>  ltnS (leq_trans _ a1Ll) //.
        <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK aLa1) addnC leq_add2r ltnW.
      <span class="nb">rewrite</span> !ffunE.
      <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord (a + k) : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> inordK; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> addn_gt0 a_gt0.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="nb">rewrite</span> ffunE inordK //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS apegS -apegD [k + _]addnC.
    <span class="nb">have</span> P7 : 
      (S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= 
      \sum_(i &lt; b) `d[‚Üì[u (inord (a + i))], ‚Üì[u (inord (a + i).+<span class="mi">1</span>)]]_smove +
      sp ‚Üì[u (inord a)] b pa + sp ‚Üì[u (inord a1)] b (a[p1, p3] a1).
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH7) (leq_add (leq_add _ _) _);
        <span class="nb">rewrite</span> /pa /paS // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
      - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC eq_sym.
      - <span class="nb">apply</span>: leq_sum =&gt; i; <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addnS</span> //.
          <span class="bp">by</span> <span class="nb">rewrite</span> ltnS.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      - <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> !ffunE addn0.
      <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> !ffunE /= [a + b]addnC subnK //.
      <span class="bp">by</span> <span class="nb">rewrite</span> apegS -apegD subnK.
    <span class="nb">set</span> x4S := sp _ _ _ <span class="kr">in</span> P7; <span class="nb">set</span> y4S := sp _ _ _ <span class="kr">in</span> P7.
    <span class="nb">have</span> y3Sx4SE : y3S + x4S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">2</span> b] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa eq_sym.
      <span class="nb">apply</span>: codom_liftr.
      <span class="nb">have</span> := @cH (inord a); <span class="nb">rewrite</span> inordK //; <span class="nb">apply</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> a_gt0 /= ltnS (leq_trans _ a1Ll).
    <span class="nb">rewrite</span> (maxn_idPr _) // <span class="kr">in</span> y3Sx4SE.
    <span class="nb">pose</span> u5 := [ffun i : &#39;I_3 =&gt;
                     <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a1)]
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> ta1].
    <span class="nb">have</span> cH8 (k : &#39;I_3) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">2</span> -&gt; codom (u5 k) \subset [:: p1; a[p2, p3] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt2].
      <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">have</span> -&gt;/= : k = <span class="mi">1</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0 k_lt2 =&gt; // [] [|].
    <span class="nb">have</span> P8 : 
      (S_[<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      (`d[‚Üì[u (inord a1)], sa1]_smove + `d[sa1, ta1]_smove) + 
        sp ‚Üì[u (inord a1)] <span class="mi">2</span> p2 + sp ta1 <span class="mi">2</span> p2.
      <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH8)) =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK /=.
      - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">set</span> x5S := sp _ _ _ <span class="kr">in</span> P8; <span class="nb">set</span> y5S := sp _ _ _ <span class="kr">in</span> P8.
    <span class="nb">have</span> y4Sx5SE : y4S + x5S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn b <span class="mi">2</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> := @cH (inord a1); <span class="nb">rewrite</span> inordK //.
        <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">rewrite</span> a1_gt0 /= ltnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
    <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> y4Sx5SE.
    <span class="nb">have</span> y2Sy5SE : y2S + y5S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * c).-<span class="mi">2</span> <span class="mi">2</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa1.
      <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
    <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> y2Sy5SE.
    <span class="nb">rewrite</span> (_ : sd u = 
       \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
       \sum_(a &lt;= i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
       \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove); <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f).
      <span class="bp">by</span> <span class="nb">rewrite</span> -!big_cat_nat //= ltnW.
    <span class="nb">rewrite</span> -{}P1 -{}P2.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _ + _ + _ + _]
       (_ : _  =
              \sum_(i &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove
              + `d[sam1, tam1]_smove + `d[tam1, ‚Üì[u (inord a)]]_smove); 
              <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
      <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * a)) //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK // mulnS.
      <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recr /f //=; <span class="nb">congr</span> (_ + _ + _).
        <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
        <span class="nb">rewrite</span> inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /= prednK.
        <span class="nb">rewrite</span> mod3E /= eqxx.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) add1n prednK // ltnW.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= eqxx.
      <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> mod3E /= eqxx.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) mod3E /= div3E add1n prednK.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + (_ + X) + _ + _]
       (_ : _  = `d[‚Üì[u (inord a1)], sa1]_smove +  `d[sa1, ta1]_smove +
         \sum_(i &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>) `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove);
        <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
      <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * c)) //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[c]prednK // mulnS.
      <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recl // /f /= !addnA; <span class="nb">congr</span> (_ + _ + _).
      - <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addn0</span> //=.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
      - <span class="nb">rewrite</span> !ffunE !inordK //=.
          <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS (leq_mul2l <span class="mi">3</span> <span class="mi">1</span> c).
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
      <span class="bp">by</span> <span class="nb">rewrite</span> big_mkord.
    <span class="nb">rewrite</span> -/y1S.
    <span class="nb">set</span> z1S := \sum_(_ &lt; _) _; <span class="nb">set</span> z2S := \sum_(_ &lt; _) _.
    <span class="nb">set</span> z3S := \sum_(_ &lt;= _ &lt; _) _. 
    <span class="nb">rewrite</span> -/z1S <span class="kr">in</span> P4; <span class="nb">rewrite</span> -/z2S <span class="kr">in</span> P5; <span class="nb">rewrite</span> -/z3S <span class="kr">in</span> P3.
    <span class="nb">rewrite</span> -[z1S + _ + _]addnA; <span class="nb">set</span> d1 := `d[_,_]_ _ + `d[_,_]_ _;
       <span class="nb">rewrite</span> -/d1 <span class="kr">in</span> P6.
    <span class="nb">set</span> d2 := `d[_,_]_ _ + `d[_,_]_ _; <span class="nb">rewrite</span> -/d2 <span class="kr">in</span> P8.
    <span class="nb">set</span> xS := \sum_(_ &lt;= _ &lt; _) _ <span class="kr">in</span> P3.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X + _ + _](_ : _ = xS) <span class="kr">in</span> P7; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> /xS -[<span class="kr">in</span> RHS](add0n a) big_addn -/b big_mkord.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> [a + _]addnC.
    <span class="nb">have</span> F1 := dsum_alphaL_S (<span class="mi">3</span> * a).-<span class="mi">2</span> n.
    <span class="nb">have</span> F2 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n.
    <span class="nb">have</span> F3 := dsum_alphaL_S b n.
    <span class="nb">have</span> F4_a : <span class="mi">2</span> * a = <span class="mi">2</span> + a.-<span class="mi">1</span> + a.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mul2n -addnn addnS.
    <span class="nb">have</span> F4_c : <span class="mi">2</span> * c = <span class="mi">2</span> + c.-<span class="mi">1</span> + c.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[c]prednK // mul2n -addnn addnS.
    <span class="nb">have</span> F4 i k : <span class="mi">0</span> &lt; i -&gt; S_[i.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *i).-<span class="mi">2</span>] k + i.-<span class="mi">1</span>.
      <span class="nb">move</span>=&gt; i_gt0; <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
      <span class="nb">rewrite</span> leq_add2r.
      <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[i]prednK // mulnS addSn add2n /=.
    <span class="nb">have</span> F4an := F4 a n a_gt0.
    <span class="nb">have</span> F4an1 := F4 a n.+<span class="mi">1</span> a_gt0.
    <span class="nb">have</span> F4cn := F4 c n (c_gt0).
    <span class="nb">have</span> F4cn1 := F4 c n.+<span class="mi">1</span> (c_gt0).
    <span class="nb">have</span> l_gt1 : <span class="mi">1</span> &lt; l.
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E -[<span class="mi">3</span>]/(<span class="mi">2</span> + <span class="mi">0</span> + <span class="mi">1</span>); <span class="nb">rewrite</span> !leq_add.
    <span class="nb">have</span> F5 := SH l_gt1.
    <span class="nb">have</span> F6 : S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[(b + c).+<span class="mi">2</span>] n.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X]addnC.
      <span class="nb">rewrite</span> (_ : l.+<span class="mi">1</span> =  <span class="mi">1</span> + a.-<span class="mi">2</span> + (b + c).+<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="nb">rewrite</span> /b /c add1n -addSnnS !prednK //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS prednK.
        <span class="bp">by</span> <span class="nb">rewrite</span> addnCA addnA subnK // addnC subnK // ltnW.
      <span class="nb">rewrite</span> (_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
         <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
    <span class="nb">have</span> F7 : S_[l] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[(b + c).+<span class="mi">1</span>] n.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X]addnC.
      <span class="nb">rewrite</span> (_ : l =  <span class="mi">1</span> + a.-<span class="mi">2</span> + (b + c)); <span class="nb">last first</span>.
        <span class="nb">rewrite</span> /b /c subSn // addnS -addSnnS add1n.
        <span class="nb">rewrite</span> !prednK //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS prednK.
        <span class="bp">by</span> <span class="nb">rewrite</span> addnCA addnA subnK // addnC subnK // ltnW.
      <span class="nb">rewrite</span> (_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
         <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
    <span class="nb">have</span> F8 : S_[(b + c).+<span class="mi">2</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[b.+<span class="mi">4</span>] n.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> (_ : (b + c).+<span class="mi">2</span> =  <span class="mi">1</span> + b.+<span class="mi">3</span> + (c.-<span class="mi">2</span>)); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK // -subn1 ltn_subRL addn0.
      <span class="nb">rewrite</span> (_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
    <span class="nb">have</span> F9 : S_[(b + c).+<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[b.+<span class="mi">3</span>] n.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> (_ : (b + c).+<span class="mi">1</span> =  <span class="mi">1</span> + b.+<span class="mi">2</span> + (c.-<span class="mi">2</span>)); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK // -subn1 ltn_subRL addn0.
      <span class="nb">rewrite</span> (_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
    <span class="nb">have</span> F10 : S_[b.+<span class="mi">4</span>] n.+<span class="mi">2</span> &lt;= S_[b.+<span class="mi">3</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">have</span> F11 : S_[b.+<span class="mi">3</span>] n.+<span class="mi">1</span> &lt;= S_[b.+<span class="mi">2</span>] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">have</span> F12 : S_[b.+<span class="mi">2</span>] n + S_[<span class="mi">1</span>] n &lt;= S_[b] n + S_[<span class="mi">3</span>] n.
      <span class="nb">rewrite</span> (_ : b.+<span class="mi">2</span> = <span class="mi">1</span> + <span class="mi">2</span> + b.-<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n addSnnS prednK // ltnW.
      <span class="nb">rewrite</span> -{<span class="mi">2</span>}[b]prednK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: ltnW.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n).
    <span class="nb">have</span> F13 : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> = (S_[<span class="mi">3</span>] n).+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alpha3_S.
    <span class="nb">have</span> F14 := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>.
    <span class="nb">have</span> F15n := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
    <span class="nb">have</span> F15n1 := dsum_alphaL_S <span class="mi">1</span> n.
    <span class="c">(* lia should work *)</span>
    <span class="nb">move</span>: P3 P4 P5 P6 P7 P8 =&gt; P3 P4 P5 P6 P7 P8.
    applyr P3.
    <span class="nb">rewrite</span> -(leq_add2r x2S); applyr P4.
    <span class="nb">rewrite</span> -(leq_add2r y2S); applyr P5.
    <span class="nb">rewrite</span> -(leq_add2r (x3S + y3S)); applyr P6.
    <span class="nb">rewrite</span> -(leq_add2r (x4S + y4S)); applyr P7.
    <span class="nb">rewrite</span> -(leq_add2r (x5S + y5S)); applyr P8.
    applyl y4Sx5SE; applyl y3Sx4SE; applyl y2Sy5SE; applyl x2Sx3SE.
    gsimpl.
    <span class="nb">rewrite</span> ![<span class="mi">2</span> * S_[_.-<span class="mi">2</span>] _]mul2n -!addnn {<span class="mi">1</span>}F1 {<span class="mi">1</span>}F2.
    <span class="nb">rewrite</span> {F1 F2}F3; gsimpl.
    <span class="nb">rewrite</span>  {}F4_a {}F4_c.
    applyr F4an; applyr F4an1; applyr F4cn; applyr F4cn1.
    applyl F5.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F6.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F7.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F8.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F9; gsimpl.
    applyl F10.
    changel ((<span class="mi">4</span> * S_[<span class="mi">1</span>] n + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> + S_[b.+<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>).
    changer ((<span class="mi">2</span> + S_[<span class="mi">2</span>] n.+<span class="mi">1</span> + S_[b] n + S_[<span class="mi">2</span>] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + 
      (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)).*<span class="mi">2</span>).
    <span class="nb">rewrite</span> leq_double.
    applyl F11; applyl F12; gsimpl; applyr F14.
    <span class="nb">rewrite</span> -ltnS -!addnS -F13.
    <span class="bp">by</span> <span class="nb">rewrite</span> {}F15n {}F15n1; gsimpl.
  <span class="nb">move</span>: b_le2; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP[] bE1|].
<span class="c">(*  subcase b = 1 *)</span>  
    <span class="nb">have</span> a1E : a1 = a.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK aLa1) -/b bE1.
    <span class="nb">pose</span> u3 := [ffun i : &#39;I_4 =&gt;
                 <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> sam1 
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> tam1 
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a)]
                 <span class="kr">else</span> ‚Üì[u (inord a.+<span class="mi">1</span>)]].
    <span class="nb">have</span> cH6 (k : &#39;I_4) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> -&gt; codom (u3 k) \subset [:: pa1S; a[p2, pa1] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt3].
      <span class="nb">rewrite</span> !ffunE eqn_leq leqNgt k_gt0 /=.
      <span class="nb">case</span>: eqP =&gt; [-&gt;/=|/eqP kD1].
        <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S !apegS apeg0 codom_apeg codom_subC.
      <span class="nb">have</span> -&gt;/= : k = <span class="mi">2</span> :&gt; nat.
        <span class="bp">by</span> <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqn_leq -ltnS k_lt3 ltn_neqAle eq_sym k_gt0 kD1.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> inordK //.
        <span class="bp">by</span> <span class="nb">rewrite</span> a_gt0 /= l1E bE1 addn1 leq_addr.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK // /pa1S a1E !apegS apeg0.
    <span class="nb">have</span> P6 : 
      (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      (`d[sam1, tam1]_smove + `d[tam1, ‚Üì[u (inord a)]]_smove + 
          `d[‚Üì[u (inord a)], ‚Üì[u (inord a.+<span class="mi">1</span>)]]_smove) +
      sp sam1 <span class="mi">3</span> p2 + sp ‚Üì[u (inord a.+<span class="mi">1</span>)] <span class="mi">3</span> (a[p1, p3] a1).
      <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH6)); <span class="nb">rewrite</span> /pa1S /pa1 //.
      - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK /=.
      - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE /=.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">set</span> x3S := sp _ _ _ <span class="kr">in</span> P6; <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P6.
    <span class="nb">have</span> x2Sx3SE : x2S + x3S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="mi">3</span>] n.
      <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE; <span class="nb">rewrite</span> /pa.
    <span class="nb">rewrite</span> (maxn_idPl _) <span class="kr">in</span> x2Sx3SE; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -subn2  ltn_subRL ltnW // (leq_mul2l <span class="mi">3</span> <span class="mi">2</span>).
    <span class="nb">pose</span> u5 := [ffun i : &#39;I_3 =&gt;
                     <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a1)]
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> ta1].
    <span class="nb">have</span> cH8 (k : &#39;I_3) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">2</span> -&gt; codom (u5 k) \subset [:: p1; a[p2, p3] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt2].
      <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">have</span> -&gt;/= : k = <span class="mi">1</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0 k_lt2 =&gt; // [] [|].
    <span class="nb">have</span> P8 : 
      (S_[<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      (`d[‚Üì[u (inord a.+<span class="mi">1</span>)], sa1]_smove + `d[sa1, ta1]_smove) +
      sp ‚Üì[u (inord a.+<span class="mi">1</span>)] <span class="mi">2</span> p2 + sp ta1 <span class="mi">2</span> p2.
      <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH8)) =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK //= a1E.
      - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE a1E.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">set</span> x5S := sp _ _ _ <span class="kr">in</span> P8; <span class="nb">set</span> y5S := sp _ _ _ <span class="kr">in</span> P8.
    <span class="nb">have</span> y3Sx5SE : y3S + x5S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[<span class="mi">3</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> := @cH (inord a.+<span class="mi">1</span>); <span class="nb">rewrite</span> inordK <span class="nl">?a1E</span> //.
        <span class="bp">by</span> <span class="nb">apply</span>; <span class="nb">rewrite</span> andTb //= ltnS -a1E.
      <span class="bp">by</span> <span class="nb">rewrite</span> -a1E ltnS ltnW.
    <span class="nb">have</span> y5Sy2SE : y5S + y2S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">2</span> (<span class="mi">3</span> * c).-<span class="mi">2</span>] n.
      <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE; <span class="nb">rewrite</span> // /pa1 eq_sym.
    <span class="nb">rewrite</span> (maxn_idPr _) <span class="kr">in</span> y5Sy2SE; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL (ltn_mul2l <span class="mi">3</span> <span class="mi">1</span>).
    <span class="nb">rewrite</span> (_ : sd u = 
       \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
       \sum_(a &lt;= i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
       \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove);
        <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f).
      <span class="bp">by</span> <span class="nb">rewrite</span> -!big_cat_nat //= ltnW.
    <span class="nb">rewrite</span> -{}P1 -{}P2; applyr P3.
    <span class="nb">rewrite</span> (_ : sd u1  =
              \sum_(i &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove
              + `d[sam1, tam1]_smove + 
              `d[tam1, ‚Üì[u (inord a)]]_smove); <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
      <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * a)) //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK // mulnS.
      <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recr /f //=; <span class="nb">congr</span> (_ + _ + _).
        <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
          <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
        <span class="nb">rewrite</span> inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /= prednK.
        <span class="nb">rewrite</span> mod3E /= eqxx.
        <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
          <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) add1n prednK // ltnW.
        <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= eqxx.
      <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> mod3E /= eqxx.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) mod3E /= div3E add1n prednK.
    <span class="nb">rewrite</span> (_ : sd u2  = 
       `d[‚Üì[u (inord a1)], sa1]_smove +  `d[sa1, ta1]_smove +
               \sum_(i &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>) 
                  `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove); <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
      <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * c)) //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[c]prednK // mulnS.
      <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recl // /f /= !addnA.
       <span class="nb">congr</span> (_ + _ + _).
      - <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addn0</span> //=.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
      - <span class="nb">rewrite</span> !ffunE !inordK //=.
          <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS (leq_mul2l <span class="mi">3</span> <span class="mi">1</span> c).
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
      <span class="bp">by</span> <span class="nb">rewrite</span> big_mkord.
    <span class="nb">rewrite</span> (_ : \sum_(_ &lt;= _ &lt; _) _ =
      `d[‚Üì[u (inord a)], ‚Üì[u (inord a.+<span class="mi">1</span>)]]_smove); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> a1E big_nat1.
    <span class="nb">set</span> z1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P4; <span class="nb">set</span> z2S := \sum_(_ &lt; _) _ <span class="kr">in</span>  P5.
    <span class="nb">rewrite</span> -/z1S -/z2S.
    <span class="nb">rewrite</span> -a1E <span class="kr">in</span> P8; <span class="nb">set</span> d2 := `d[_,_]_ _ + `d[_,_]_ _ <span class="kr">in</span> P8; <span class="nb">rewrite</span> -/d2.
    <span class="nb">set</span> d1 := `d[_,_]_ _ + `d[_,_]_ _ + `d[_,_]_ _ <span class="kr">in</span> P6.
    <span class="nb">rewrite</span> -/y1S.
    changer  (<span class="mi">2</span> * a + <span class="mi">2</span> * c + x1S + y1S + z1S + z2S + d2 + 
              (`d[sam1, tam1]_smove +  `d[tam1, ‚Üì[u (inord a)]]_smove +
               `d[‚Üì[u (inord a)], ‚Üì[u (inord a.+<span class="mi">1</span>)]]_smove)).
    <span class="nb">rewrite</span> -/d1.
    <span class="nb">have</span> F1 := dsum_alphaL_S (<span class="mi">3</span> * a).-<span class="mi">2</span> n.
    <span class="nb">have</span> F2 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n.
    <span class="nb">have</span> F3 := dsum_alphaL_S <span class="mi">3</span> n.
    <span class="nb">have</span> F4_a : <span class="mi">2</span> * a = <span class="mi">2</span> + a.-<span class="mi">1</span> + a.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mul2n -addnn addnS.
    <span class="nb">have</span> F4_c : <span class="mi">2</span> * c = <span class="mi">2</span> + c.-<span class="mi">1</span> + c.-<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[c]prednK // mul2n -addnn addnS.
    <span class="nb">have</span> F4 i k : <span class="mi">0</span> &lt; i -&gt; S_[i.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *i).-<span class="mi">2</span>] k + i.-<span class="mi">1</span>.
      <span class="nb">move</span>=&gt; i_gt0; <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
      <span class="nb">rewrite</span> leq_add2r.
      <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[i]prednK // mulnS addSn add2n /=.
    <span class="nb">have</span> F4an := F4 a n a_gt0.
    <span class="nb">have</span> F4an1 := F4 a n.+<span class="mi">1</span> a_gt0.
    <span class="nb">have</span> F4cn := F4 c n (c_gt0).
    <span class="nb">have</span> F4cn1 := F4 c n.+<span class="mi">1</span> (c_gt0).
    <span class="nb">have</span> l_gt1 : <span class="mi">1</span> &lt; l.
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E -[<span class="mi">3</span>]/(<span class="mi">2</span> + <span class="mi">0</span> + <span class="mi">1</span>); <span class="nb">rewrite</span> !leq_add.
    <span class="nb">have</span> F5 := SH l_gt1.
    <span class="nb">have</span> F6n : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> = (S_[<span class="mi">3</span>] n).+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alpha3_S.
    <span class="nb">have</span> F6n1 : S_[<span class="mi">1</span>] n.+<span class="mi">2</span> = (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alpha3_S.
    <span class="nb">have</span> am1_gt0 : <span class="mi">0</span> &lt; a.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0.
    <span class="nb">have</span> F7n1 : S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">3</span>] n.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> addnC (_ : l.+<span class="mi">1</span> = <span class="mi">1</span> + c.+<span class="mi">2</span> + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> /c a1E add1n !addSnnS !prednK <span class="nl">?subnK</span> // -a1E ltnW.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
    <span class="nb">have</span> F7n : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[l] n.+<span class="mi">1</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[c.+<span class="mi">2</span>] n.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> addnC (_ : l = <span class="mi">1</span> + c.+<span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> /c a1E add1n subSS !addSnnS !prednK <span class="nl">?subnK</span> // -ltnS -a1E ltnW.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
    <span class="nb">have</span> cm1_gt0 : <span class="mi">0</span> &lt; c.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0.
    <span class="nb">have</span> F8n1 : S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">3</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">5</span>] n.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> addnC (_ : c.+<span class="mi">3</span> = <span class="mi">1</span> + <span class="mi">4</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
    <span class="nb">have</span> F8n : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[c.+<span class="mi">2</span>] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">4</span>] n.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> addnC (_ : c.+<span class="mi">2</span> = <span class="mi">1</span> + <span class="mi">3</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
    <span class="nb">have</span> F9 : S_[<span class="mi">5</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">4</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">have</span> F10 : S_[<span class="mi">4</span>] n.+<span class="mi">1</span> &lt;= S_[<span class="mi">3</span>] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">have</span> F11 : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> = (S_[<span class="mi">3</span>] n).+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alpha3_S.
    <span class="nb">have</span> F12 := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>.
    <span class="nb">have</span> F13n1 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
    <span class="nb">have</span> F13n := dsum_alphaL_S <span class="mi">1</span> n.
    <span class="c">(* lia should work *)</span>
    <span class="nb">move</span>: P4 P5 P6 P8 =&gt; P4 P5 P6 P8.
    <span class="nb">rewrite</span> -(leq_add2r x2S); applyr P4.
    <span class="nb">rewrite</span> -(leq_add2r y2S); applyr P5.
    <span class="nb">rewrite</span> -(leq_add2r (x3S + y3S)); applyr P6.
    <span class="nb">rewrite</span> -(leq_add2r (x5S + y5S)); applyr P8.
    applyl y5Sy2SE; applyl y3Sx5SE; applyl x2Sx3SE.
    <span class="nb">rewrite</span> [<span class="mi">2</span> * (S_[_.-<span class="mi">2</span>] _)]mul2n -addnn {<span class="mi">1</span>}F1.
    <span class="nb">rewrite</span> [<span class="mi">2</span> * (S_[_.-<span class="mi">2</span>] _)]mul2n -addnn {<span class="mi">1</span>}F2.
    <span class="nb">rewrite</span> [<span class="mi">2</span> * (S_[<span class="mi">3</span>] _)]mul2n -addnn {<span class="mi">1</span>}F3.
    gsimpl.
    <span class="nb">rewrite</span>  {}F4_a {}F4_c.
    applyr F4an; applyr F4an1; applyr F4cn; applyr F4cn1.
    applyl F5.
    <span class="nb">rewrite</span> -ltnS -!addSn -!addnA [X <span class="kr">in</span> _ &lt;= X]addnC !addnA -ltnS -!addSn.
    <span class="nb">rewrite</span> -{}F6n -{}F6n1.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F7n1.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F7n; gsimpl.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F8n1.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F8n; gsimpl.
    applyl F9.
    <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F10; applyl F10.
    <span class="nb">rewrite</span> -(leq_add2r <span class="mi">2</span>).
    changel (<span class="mi">6</span> * S_[<span class="mi">1</span>] n + <span class="mi">4</span> * Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>  + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span> + 
      ((S_[<span class="mi">3</span>] n).+<span class="mi">1</span>).*<span class="mi">2</span>).
    <span class="nb">rewrite</span> -{}F11.
    applyr F12.
    <span class="bp">by</span> <span class="nb">rewrite</span> F13n1 F13n; gsimpl.
<span class="c">(* subcase b = 0 *)</span>
  <span class="nb">rewrite</span> !ltnS leqn0 =&gt; /eqP bE0.
  <span class="nb">have</span> a1E : a1 = a <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK aLa1) -/b bE0.
  <span class="nb">pose</span> u3 := [ffun i : &#39;I_5 =&gt;
                 <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> sam1 
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> tam1 
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a)]
                 <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">3</span> :&gt; nat <span class="kr">then</span> sa1 
                 <span class="kr">else</span> ta1].
  <span class="nb">have</span> cH6 (k : &#39;I_5) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">4</span> -&gt; codom (u3 k) \subset [:: pa1; a[p2, pa1S] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt3].
    <span class="nb">rewrite</span> !ffunE eqn_leq leqNgt k_gt0 /=.
    <span class="nb">case</span>: eqP =&gt; [-&gt;/=|/eqP kD1].
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S !apegS apeg0 codom_apeg.
    <span class="nb">case</span>: eqP =&gt;[-&gt;/=|/eqP kD2].
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a_gt0 /= -a1E.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK // /pa1 a1E.
    <span class="nb">have</span> -&gt;/= : k = <span class="mi">3</span> :&gt; nat.
      <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_lt3 k_gt0 kD1 kD2 =&gt; // [] [|[|[|]]].
    <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S !(apegS, apeg0) codom_apeg.
  <span class="nb">have</span> P6 : 
    (S_[<span class="mi">4</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
    (`d[sam1, tam1]_smove + `d[tam1, ‚Üì[u (inord a)]]_smove + 
        `d[‚Üì[u (inord a)], sa1]_smove +
        `d[sa1, ta1]_smove) + sp sam1 <span class="mi">4</span> p2 + sp ta1 <span class="mi">4</span> p2.
    <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH6)); <span class="nb">rewrite</span> /pa1S /pa1 //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
    - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
    - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
    <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
    - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK /= <span class="nl">?a1E</span>.
    - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE /=.
    <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE /= a1E.
  <span class="nb">set</span> x3S := sp _ _ _ <span class="kr">in</span> P6; <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P6.
  <span class="nb">have</span> x2Sx3SE : x2S + x3S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * a).-<span class="mi">2</span> <span class="mi">4</span>] n.
    <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE; <span class="nb">rewrite</span> /pa.
  <span class="nb">rewrite</span> (maxn_idPl _) <span class="kr">in</span> x2Sx3SE; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL // (leq_mul2l <span class="mi">3</span> <span class="mi">2</span>).
  <span class="nb">have</span> y2Sy3SE : y2S + y3S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn (<span class="mi">3</span> * c).-<span class="mi">2</span> <span class="mi">4</span>] n.
    <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa1.
    <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
  <span class="nb">rewrite</span> (maxn_idPl _) <span class="kr">in</span> y2Sy3SE; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL (leq_mul2l <span class="mi">3</span> <span class="mi">2</span>).
  <span class="nb">rewrite</span> (_ : sd u = 
      \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
      \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove); <span class="nb">last first</span>.
    <span class="nb">pose</span> f i := `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
    <span class="bp">by</span> <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) a1E -!big_cat_nat.
  <span class="nb">rewrite</span> -{}P1 -{P3}P2.
  <span class="nb">rewrite</span> (_ : sd u1  =
            \sum_(i &lt; (<span class="mi">3</span> * a).-<span class="mi">2</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove
            + `d[sam1, tam1]_smove 
            + `d[tam1, ‚Üì[u (inord a)]]_smove); <span class="nb">last first</span>.
    <span class="nb">pose</span> f i := `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove.
    <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
    <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * a)) //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[a]prednK // mulnS.
    <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recr /f //=; <span class="nb">congr</span> (_ + _ + _).
      <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
      <span class="nb">rewrite</span> inordK; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltn_mul2l /= prednK.
      <span class="nb">rewrite</span> mod3E /= eqxx.
      <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> -[_.+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) add1n prednK // ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> mod3E /= eqxx.
    <span class="nb">rewrite</span> ffunE (_ : (<span class="mi">3</span> * a).-<span class="mi">2</span> = (<span class="mi">3</span> * (a.-<span class="mi">1</span>)).+<span class="mi">1</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]prednK // mulnS.
    <span class="nb">rewrite</span> inordK; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
    <span class="nb">rewrite</span> mod3E /= eqxx.
    <span class="nb">rewrite</span> ffunE inordK; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[a]prednK // mulnS.
    <span class="bp">by</span> <span class="nb">rewrite</span> -[(_ * _).+<span class="mi">3</span>](mulnDr <span class="mi">3</span> <span class="mi">1</span>) mod3E /= div3E add1n prednK.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + (_ + X) + _ + _](_ : _  = 
      `d[‚Üì[u (inord a1)], sa1]_smove + `d[sa1, ta1]_smove +
      \sum_(i &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>) `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove);
       <span class="nb">last first</span>.
    <span class="nb">pose</span> f i := `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove.
    <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f) .
    <span class="nb">rewrite</span> -{<span class="mi">1</span>}(subnK (_ : <span class="mi">1</span> &lt; <span class="mi">3</span> * c)) //; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[c]prednK // mulnS.
    <span class="nb">rewrite</span> subn2 !addn2 !big_nat_recl // /f /= !addnA; <span class="nb">congr</span> (_ + _ + _).
    - <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addn0</span> //=.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
    - <span class="nb">rewrite</span> !ffunE !inordK //=.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS (leq_mul2l <span class="mi">3</span> <span class="mi">1</span> c).
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
    <span class="bp">by</span> <span class="nb">rewrite</span> big_mkord.
  <span class="nb">set</span> z1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P4; <span class="nb">set</span> z2S := \sum_(_ &lt; _) _ <span class="kr">in</span> P5.
  <span class="nb">rewrite</span> -/z1S -/z2S.
  <span class="nb">rewrite</span> a1E -/y1S.
  changer (a.*<span class="mi">2</span> + c.*<span class="mi">2</span> + (`d[sam1, tam1]_smove + `d[tam1, ‚Üì[u (inord a)]]_smove
    + `d[‚Üì[u (inord a)], sa1]_smove + `d[sa1, ta1]_smove) 
    + x1S + y1S + z1S + z2S).
  <span class="nb">set</span> d1 := `d[_,_]_ _ + `d[_,_]_ _  + `d[_,_]_ _ + `d[_,_]_ _; 
    <span class="nb">rewrite</span> -/d1 <span class="kr">in</span> P6.
  <span class="nb">have</span> F1 := dsum_alphaL_S (<span class="mi">3</span> * a).-<span class="mi">2</span> n.
  <span class="nb">have</span> F2 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n.
  <span class="nb">have</span> F3 := dsum_alphaL_S <span class="mi">4</span> n.
  <span class="nb">have</span> F4_a : <span class="mi">2</span> * a = <span class="mi">2</span> + a.-<span class="mi">1</span> + a.-<span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> mul2n -{<span class="mi">1</span>}[a]prednK // -addnn addnS.
  <span class="nb">have</span> F4_c : <span class="mi">2</span> * c = <span class="mi">2</span> + c.-<span class="mi">1</span> + c.-<span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> mul2n -{<span class="mi">1</span>}[c]prednK // -addnn addnS.
  <span class="nb">have</span> F4 i k : <span class="mi">0</span> &lt; i -&gt; S_[i.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *i).-<span class="mi">2</span>] k + i.-<span class="mi">1</span>.
    <span class="nb">move</span>=&gt; i_gt0; <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
    <span class="nb">rewrite</span> leq_add2r.
    <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[i]prednK // mulnS addSn add2n /=.
  <span class="nb">have</span> F4an := F4 a n a_gt0.
  <span class="nb">have</span> F4an1 := F4 a n.+<span class="mi">1</span> a_gt0.
  <span class="nb">have</span> F4cn := F4 c n (c_gt0).
  <span class="nb">have</span> F4cn1 := F4 c n.+<span class="mi">1</span> (c_gt0).
  <span class="nb">have</span> l_gt1 : <span class="mi">1</span> &lt; l.
    <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E -[<span class="mi">3</span>]/(<span class="mi">2</span> + <span class="mi">0</span> + <span class="mi">1</span>); <span class="nb">rewrite</span> !leq_add.
  <span class="nb">have</span> F5 := SH l_gt1.
  <span class="nb">have</span> am1_gt0 : <span class="mi">0</span> &lt; a.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0.
  <span class="nb">have</span> F6n1 : S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span>.
    <span class="nb">rewrite</span> addnC (_ : l.+<span class="mi">1</span> = <span class="mi">1</span> + c.+<span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span>  /c add1n <span class="mi">2</span>!addSnnS !prednK <span class="nl">?a1E</span> <span class="nl">?subnK</span>.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
  <span class="nb">have</span> F6n : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[l] n.+<span class="mi">1</span> &lt;= S_[a.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[c.+<span class="mi">1</span>] n.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> addnC (_ : l = <span class="mi">1</span> + c + a.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="nb">rewrite</span>  /c add1n a1E -{<span class="mi">1</span>}[a]prednK // subSS.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSnnS !prednK // subnK // -ltnS prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : a.-<span class="mi">1</span> = <span class="mi">1</span> + a.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
  <span class="nb">have</span> cm1_gt0 : <span class="mi">0</span> &lt; c.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0.
  <span class="nb">have</span> F7n1 : S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">4</span>] n.+<span class="mi">2</span>.
    <span class="nb">rewrite</span> addnC (_ : c.+<span class="mi">2</span> = <span class="mi">1</span> + <span class="mi">3</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
  <span class="nb">have</span> F7n : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[c.+<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">3</span>] n.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> addnC (_ : c.+<span class="mi">1</span> = <span class="mi">1</span> + <span class="mi">2</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> add1n <span class="mi">2</span>!addSnnS !prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
  <span class="nb">have</span> F8 : S_[<span class="mi">4</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">3</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha n.+<span class="mi">1</span> (isT : <span class="mi">1</span> &lt; <span class="mi">3</span>).
  <span class="nb">have</span> F9 : S_[<span class="mi">3</span>] n.+<span class="mi">1</span> &lt;= S_[<span class="mi">4</span>] n.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">case</span>: (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
  <span class="nb">have</span> F10n1 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F10n := dsum_alphaL_S <span class="mi">1</span> n. 
  <span class="nb">have</span> F11 := bound_alphaL <span class="mi">2</span> n.
  <span class="nb">have</span> F12 := alphaL_1_2 n.
   <span class="c">(* lia should work *)</span>
  <span class="nb">move</span>: P4 P5 P6 =&gt; P4 P5 P6.
  <span class="nb">rewrite</span> -(leq_add2r x2S); applyr P4.
  <span class="nb">rewrite</span> -(leq_add2r y2S); applyr P5.
  <span class="nb">rewrite</span> -(leq_add2r (x3S + y3S)); applyr P6.
  applyl x2Sx3SE; applyl y2Sy3SE; gsimpl.
  <span class="nb">rewrite</span> [<span class="mi">2</span> * (S_[_.-<span class="mi">2</span>] _)]mul2n -addnn {<span class="mi">1</span>}F1.
  <span class="nb">rewrite</span> [<span class="mi">2</span> * (S_[_.-<span class="mi">2</span>] _)]mul2n -addnn {<span class="mi">1</span>}F2.
  gsimpl.
  <span class="nb">rewrite</span> {}F4_a {}F4_c.
  applyr F4an1; applyr F4an; applyr F4cn1; applyr F4cn.
  applyl F5.
  <span class="nb">rewrite</span> -(leq_add2r (S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span>)); applyr F6n1.
  <span class="nb">rewrite</span> -(leq_add2r (S_[c.+<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyr F6n; gsimpl.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span>)); applyl F7n1.
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F7n.
  applyl F8; gsimpl.
  changel ((Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> + (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> +
    (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> + (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>).
  changer (<span class="mi">4</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> +
    (S_[<span class="mi">4</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>).
  <span class="nb">apply</span>: leq_add; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leq_double.
  <span class="nb">rewrite</span> F10n1 F10n; gsimpl.
  <span class="bp">by</span> <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F12; applyl F12; gsimpl.
<span class="nb">rewrite</span> negb_and -!leqNgt =&gt; acH.
<span class="c">(* subcase a = 1 *)</span>
<span class="nb">have</span> aLc : a &lt;= c <span class="bp">by</span> [].
<span class="nb">have</span> aE1 : a = <span class="mi">1</span>.
  <span class="nb">case</span>/orP: acH; <span class="nb">case</span>: (a) aLc a_gt0 =&gt; // [] [|n1] //.
  <span class="bp">by</span> <span class="nb">case</span>: (c) =&gt; // [] [].
<span class="nb">have</span> leq_S4 k : <span class="mi">5</span> * S_[<span class="mi">1</span>] k.+<span class="mi">1</span> + S_[<span class="mi">1</span>] k.+<span class="mi">2</span> &lt;= <span class="mi">6</span> * S_[<span class="mi">4</span>] k + <span class="mi">9</span>.
  <span class="nb">have</span> F3 :  <span class="mi">4</span> * S_[<span class="mi">3</span>] k + <span class="mi">2</span> * S_[<span class="mi">6</span>] k &lt;= <span class="mi">6</span> * S_[<span class="mi">4</span>] k.
    <span class="nb">rewrite</span> -{<span class="mi">1</span>}[<span class="mi">4</span>]/(<span class="mi">2</span> * <span class="mi">2</span>) -mulnA -mulnDr -{<span class="mi">2</span>}[<span class="mi">6</span>]/(<span class="mi">2</span> * <span class="mi">3</span>) -mulnA.
    <span class="nb">rewrite</span> leq_mul2l /= -(leq_add2r (S_[<span class="mi">5</span>] k)).
    changel (S_[<span class="mi">6</span>] k + S_[<span class="mi">3</span>] k +  (S_[<span class="mi">5</span>] k + S_[<span class="mi">3</span>] k)).
    changer (S_[<span class="mi">5</span>] k + S_[<span class="mi">4</span>] k +  (S_[<span class="mi">4</span>] k + S_[<span class="mi">4</span>] k)).
    <span class="bp">by</span> <span class="nb">apply</span>: leq_add; <span class="nb">apply</span>: concaveEk1 <span class="mi">3</span> _ _ (concave_dsum_alphaL_l k).
  applyr F3.
  <span class="nb">have</span> F3k : S_[<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[<span class="mi">3</span>] k + <span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: dsum_alpha3l.
  <span class="nb">have</span> F3k1 : S_[<span class="mi">2</span>] k.+<span class="mi">1</span> &lt;= S_[<span class="mi">6</span>] k + <span class="mi">2</span> <span class="bp">by</span> <span class="nb">apply</span>: dsum_alpha3l.
  <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F3k1; applyr F3k1.
  <span class="nb">rewrite</span> -<span class="mi">2</span>!leq_double <span class="kr">in</span> F3k; applyr F3k; gsimpl.
  <span class="bp">by</span> <span class="nb">have</span> F4 := leq_dsum_alpha_2l_1 k.+<span class="mi">1</span>; applyr F4.
<span class="nb">move</span>: c_gt0; <span class="nb">rewrite</span> leq_eqVlt eq_sym =&gt; /orP[/eqP cE1|c_gt1].
<span class="c">(* This is 4.2.2 a = 1, b = 1 *)</span>
  <span class="nb">move</span> : P1 P2 P3 =&gt; P1 P2 P3.
  <span class="nb">have</span> l_gt0 : <span class="mi">0</span> &lt; l <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E aE1 cE1 addn1.
  <span class="nb">have</span> a1El : a1 = l.
    <span class="bp">by</span> <span class="nb">rewrite</span> -(subKn (_ : a1 &lt;= l.+<span class="mi">1</span>)) <span class="mi">1</span><span class="nl">?ltnW</span> // -/c cE1 subSS subn0.
  <span class="nb">have</span> [b_gt1|b_lt2]:= leqP <span class="mi">2</span> b.
<span class="c">(*   subcase b &gt;= 2*)</span>
    <span class="nb">rewrite</span> (_ : sd u = 
        \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
        \sum_(a &lt;= i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
        \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove);
        <span class="nb">last first</span>.
      <span class="nb">pose</span> f i := `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd -!(big_mkord xpredT f).
      <span class="bp">by</span> <span class="nb">rewrite</span> -!big_cat_nat //= ltnW.
    <span class="nb">rewrite</span> !sum_beta_S // KH1 eqxx addn0 KH2 eqxx addn0.
    <span class="nb">apply</span>: leq_trans (leq_add (leq_add (leq_add (leq_add (leqnn _) P3) 
                       (leqnn _)) (leqnn _)) (leqnn _)); <span class="nb">rewrite</span> -{P3}P1 -{}P2.
    <span class="nb">set</span> x2S := sd u2; <span class="nb">set</span> x0S := sd u1.
    <span class="nb">pose</span> u3 := [ffun i : &#39;I_b.+<span class="mi">1</span> =&gt; ‚Üì[u (inord (a + i))]].
    <span class="nb">rewrite</span>  (_ : \sum_(_ &lt;= _ &lt; _) _ =
        \sum_(i &lt; b) `d[u3 (inord i), u3 (inord i.+<span class="mi">1</span>)]_smove); <span class="nb">last first</span>.
      <span class="nb">rewrite</span> -{<span class="mi">1</span>}[a]add0n big_addn  -/b big_mkord.
      <span class="nb">apply</span>: eq_bigr =&gt; i _.
      <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE addnC !inordK ?(addnS, ltnS) // ltnW.
    <span class="nb">pose</span> paS := a[p1, p3] a.+<span class="mi">1</span>.
    <span class="nb">have</span> cH3 (k : &#39;I_b.+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; b -&gt; codom (u3 k) \subset [:: p2; a[pa, paS] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
      <span class="nb">have</span> akLl : a + k &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span>  ltnS (leq_trans _ a1Ll) //.
        <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK aLa1) addnC leq_add2r ltnW.
      <span class="nb">rewrite</span> !ffunE.
      <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord (a + k) : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> inordK; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> addn_gt0 a_gt0.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="nb">rewrite</span> ffunE inordK //; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      <span class="bp">by</span> <span class="nb">rewrite</span> /paS apegS -apegD [k + _]addnC.
    <span class="nb">pose</span> pa1 := a[p1, p3] a1.
    <span class="nb">have</span> P3 : 
      (S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      \sum_(i &lt; b) `d[‚Üì[u (inord (a + i))], ‚Üì[u (inord (a + i).+<span class="mi">1</span>)]]_smove +
      sp ‚Üì[u (inord a)] b pa + sp ‚Üì[u (inord a1)] b pa1.
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH3) (leq_add (leq_add _ _) _);
        <span class="nb">rewrite</span> /pa /paS // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
      - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC eq_sym.
      - <span class="nb">apply</span>: leq_sum =&gt; i; <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addnS</span> //.
          <span class="bp">by</span> <span class="nb">rewrite</span> ltnS.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
      - <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> !ffunE addn0.
      <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> !ffunE /= [a + b]addnC subnK //.
      <span class="bp">by</span> <span class="nb">rewrite</span> apegS -apegD subnK.
    <span class="nb">set</span> x1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P3; <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P3.
    <span class="nb">set</span> y3S :=  sp _ _ _ <span class="kr">in</span> P3.
    <span class="nb">rewrite</span> [\sum_(_ &lt; _) _](_ : _ = x1S); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i; <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?addnS</span> // ltnS // ltnW.
    <span class="nb">set</span> y0S := \sum_(_ &lt; _) _ ; <span class="nb">set</span> y5S := \sum_(_ &lt; _) _.
    <span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * a).+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> * a -&gt; codom (u1 k) \subset [:: p3; a[p1, p2] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
      <span class="nb">rewrite</span> {<span class="mi">2</span>}aE1 muln1 <span class="kr">in</span> k_ltb.
      <span class="nb">rewrite</span> ffunE !modn_small // !divn_small // inord_eq0 //.
      <span class="nb">rewrite</span> [<span class="kr">in</span> <span class="mi">3</span> * a.-<span class="mi">1</span>]aE1 /=.
      <span class="nb">case</span>: (k : nat) k_gt0 k_ltb =&gt; //= [] [|[|]] //= _ _.
        <span class="nb">rewrite</span> !(apegS, apeg0).
        <span class="bp">by</span> <span class="nb">have</span> := sam1C; <span class="nb">rewrite</span> /pa aE1 apegS apeg0.
      <span class="bp">by</span> <span class="nb">rewrite</span> !(apegS, apeg0) codom_subC.
    <span class="nb">have</span> P1 : 
      (S_[<span class="mi">3</span> * a] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= x0S + sp ‚Üì[u ord0] <span class="mi">3</span> p1 + sp ‚Üì[u (inord a)] <span class="mi">3</span> p2.
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH1) (leq_add (leq_add _ _) _);
          <span class="nb">rewrite</span> // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
        <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= inord_eq0 // aE1 muln1.
      <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= mod3E /= div3E // aE1 muln1.
    <span class="nb">have</span> {}P1 := leq_trans P1 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                          (leqnn _)).
    <span class="nb">rewrite</span> -/y0S <span class="kr">in</span> P1; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P1.
    <span class="nb">rewrite</span> aE1 muln1 <span class="kr">in</span> P1.
    <span class="nb">have</span> y1Sy2SE : y1S + y2S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">3</span> b] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa // eq_sym.
      <span class="nb">apply</span>: codom_liftr.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa aE1 inordK.
    <span class="nb">have</span> cH2 (k : &#39;I_(<span class="mi">3</span> * c).+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> * c -&gt; 
      codom (u2 k) \subset [:: a[p1, p3] a1; a[p2, a[p1, p3] a1.+<span class="mi">1</span>] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
      <span class="nb">rewrite</span> {<span class="mi">2</span>}cE1 muln1 <span class="kr">in</span> k_ltb.
      <span class="nb">rewrite</span> ffunE !modn_small // !divn_small // addn0.
      <span class="nb">case</span>: (k : nat) k_gt0 k_ltb =&gt; //= [] [|[|]] //= _ _.
        <span class="bp">by</span> <span class="nb">rewrite</span> !apegS apeg0 codom_apeg.
      <span class="bp">by</span> <span class="nb">rewrite</span> !(apegS, apeg0) codom_subC.
    <span class="nb">have</span> P2 : 
      (S_[<span class="mi">3</span> * c] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= x2S + sp ‚Üì[u (inord a1)] <span class="mi">3</span> p2 +
                             sp ‚Üì[u ord_max] <span class="mi">3</span> (a[p3, p1] l).
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH2) (leq_add (leq_add _ _) _);
          <span class="nb">rewrite</span> // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
      - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC eq_sym.
      - <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= addn0 cE1 muln1.
      <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= mod3E /= div3E // cE1 muln1.
      <span class="nb">rewrite</span> a1El addn1 (_ : inord _ = ord_max) <span class="nl">?apegS</span> //.
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">have</span> {}P2 := leq_trans P2 (leq_add (leqnn _) (leq_sum_beta _ _)).
    <span class="nb">rewrite</span> -/y5S <span class="kr">in</span> P2; <span class="nb">set</span> y4S := sp _ _ _ <span class="kr">in</span> P2.
    <span class="nb">have</span> y3Sy4SE : y3S + y4S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn b <span class="mi">3</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE; <span class="nb">rewrite</span> /pa /pa1 //.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord l : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK // l_gt0 /=.
      <span class="bp">by</span> <span class="nb">rewrite</span> a1El inordK.
    <span class="nb">have</span> Eb1 : l = b.+<span class="mi">1</span>.
      <span class="bp">by</span> <span class="nb">have</span> := l1E; <span class="nb">rewrite</span> aE1 cE1 addn1 =&gt; [] [].
    <span class="nb">rewrite</span> Eb1.
    <span class="nb">have</span> F1b := dsum_alphaL_S b n.
    <span class="nb">have</span> F1n31 : (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span> = S_[<span class="mi">1</span>] n.+<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alpha3_S.
    <span class="nb">have</span> F1n1 := dsum_alphaL_S <span class="mi">1</span> n.
    <span class="nb">have</span> F1n2 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
    <span class="nb">have</span> b_gt0 : <span class="mi">0</span> &lt; b <span class="bp">by</span> <span class="nb">apply</span>: leq_trans b_gt1.
    <span class="nb">have</span> F2n1 : S_[b.+<span class="mi">2</span>] n.+<span class="mi">2</span> &lt;= S_[b.+<span class="mi">1</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alphaL_alpha .
    <span class="nb">have</span> F2n : S_[b.+<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[b] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alphaL_alpha.
    <span class="nb">have</span> F3n : S_[<span class="mi">4</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">3</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> dsum_alphaL_alpha.
    <span class="nb">have</span> F4n := alphaL_3E n.
    <span class="nb">have</span> F5 := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>.
    <span class="c">(* lia should solve this *)</span>
    <span class="nb">move</span>: P1 P2 P3 =&gt; P1 P2 P3.
    <span class="nb">rewrite</span> -(leq_add2r y1S); applyr P1.
    <span class="nb">rewrite</span> -(leq_add2r y4S); applyr P2.
    <span class="nb">rewrite</span> -(leq_add2r (y2S + y3S)); applyr P3.
    applyl y3Sy4SE; applyl y1Sy2SE; gsimpl.
    <span class="nb">rewrite</span> maxnC aE1 cE1 !muln1.
    changel ((S_[b.+<span class="mi">2</span>] n.+<span class="mi">2</span> + (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">3</span> b] n).*<span class="mi">2</span>).
    changer (((S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span>.*<span class="mi">2</span> + S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span>).
    <span class="nb">rewrite</span> leq_double.
    <span class="nb">move</span>: b_gt1; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP&lt;-|b_gt2]; <span class="nb">last first</span>.
<span class="c">(*    Subcase b &gt;= 3 *)</span>
      <span class="nb">rewrite</span> (maxn_idPr _) //.    
      <span class="nb">rewrite</span> F1b addnA leq_add2r F1n31 F1n2 F1n1.
      <span class="bp">by</span> applyr F2n; applyr F2n1; gsimpl.
<span class="c">(*  Subcase b = 2*)</span>
    <span class="nb">rewrite</span> (maxn_idPl _) //.
    applyl F3n; gsimpl.
    <span class="nb">rewrite</span> -ltnS -![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addSn !{}F1n31 {}F4n; gsimpl.
    <span class="nb">rewrite</span> F1n2; gsimpl.
    <span class="nb">have</span> [n_gt3 |] := leqP <span class="mi">4</span> n; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">case</span>: n =&gt; [|[|[|[|n1]]]]; <span class="nb">rewrite</span> // !(alphaS_small, alpha_small).
    <span class="nb">rewrite</span> -leq_double; applyr F5.
    <span class="nb">rewrite</span> F1n2 F1n1; gsimpl.
    <span class="bp">by</span> <span class="nb">have</span> F := alpha_4_3 (n_gt3); applyr F.
  <span class="nb">move</span>: b_lt2; <span class="nb">rewrite</span> leq_eqVlt =&gt; /orP[/eqP [] bE1 | b_lt1].
<span class="c">(*  subcase b = 1 *)</span>
    <span class="nb">pose</span> u1l := 
      [ffun i =&gt;  
        <span class="kr">if</span> (i : &#39;I_5) == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u ord0] <span class="kr">else</span>
        <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sam1 <span class="kr">else</span>
        <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span> 
        <span class="kr">if</span> i == <span class="mi">3</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord <span class="mi">1</span>)] <span class="kr">else</span> ‚Üì[u (inord <span class="mi">2</span>)]].
    <span class="nb">have</span> a1E2 : a1 = <span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">move</span>: (cE1); <span class="nb">rewrite</span> /c l1E aE1 bE1 cE1; <span class="nb">case</span>: (a1) =&gt; // [] [|[|]].
    <span class="nb">have</span> P1l1 : a.*<span class="mi">2</span> + sd u1l &lt;=
      \sum_(i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove.
      <span class="nb">rewrite</span> /sd a1E2 !big_ord_recr /= !big_ord0 !add0n {<span class="mi">1</span>}aE1.
      <span class="nb">rewrite</span> !ffunE /= !inordK <span class="nl">?aE1</span> //= add2n -<span class="mi">2</span>!addSn leq_add //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">apply</span>/gdist_cunlift/shanoi_connect.
      <span class="nb">rewrite</span> (inord_eq0 _ (_ : <span class="mi">0</span> = <span class="mi">0</span>)) //.
      <span class="nb">rewrite</span> (_ : ord0 = inord a.-<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK aE1.
      <span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> inord <span class="mi">1</span>]aE1 duam1ua1E /= addnA addn0.
    <span class="nb">have</span> cH1 (k : &#39;I_5) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">4</span> -&gt; codom (u1l k) \subset [:: p3; a[p1, p2] k].
      <span class="nb">case</span>: k =&gt; [] [|[|[|[|]]]] //= iH _; <span class="nb">rewrite</span> !ffunE !(apegS, apeg0).
      - <span class="bp">by</span> <span class="nb">have</span> := sam1C; <span class="nb">rewrite</span> /pa aE1.
      - <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH: <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK.
    <span class="nb">have</span> lE2 : l = <span class="mi">2</span> <span class="bp">by</span> <span class="nb">move</span>: l1E; <span class="nb">rewrite</span> aE1 bE1 cE1 =&gt; [] [].
    <span class="nb">have</span> {cH1}P4 :
      (S_[<span class="mi">4</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u1l + sp ‚Üì[u ord0] <span class="mi">4</span> p1 +
                                  sp ‚Üì[u (inord a1)] <span class="mi">4</span> p1.
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH1) _ =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add =&gt; //; <span class="nb">apply</span>: leq_sum  =&gt; i /= _; <span class="nb">rewrite</span> !ffunE //.
      <span class="bp">by</span> <span class="nb">rewrite</span> a1El -[<span class="kr">in</span> inord <span class="mi">2</span>]lE2.
    <span class="nb">have</span> {}P4 := leq_trans P4 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                                    (leqnn _)).
    <span class="nb">set</span> x1S := sd _ <span class="kr">in</span> P4.
    <span class="nb">set</span> y1S := \sum_(_ &lt; _) _ <span class="kr">in</span> P4; <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P4.
    <span class="nb">have</span> cH2 (k : &#39;I_(<span class="mi">3</span> * c).+<span class="mi">1</span>) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> * c -&gt; 
      codom (u2 k) \subset [:: a[p1, p3] a1; a[p2, a[p1, p3] a1.+<span class="mi">1</span>] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
      <span class="nb">rewrite</span> {<span class="mi">2</span>}cE1 muln1 <span class="kr">in</span> k_ltb.
      <span class="nb">rewrite</span> ffunE !modn_small // !divn_small // addn0.
      <span class="nb">case</span>: (k : nat) k_gt0 k_ltb =&gt; //= [] [|[|]] //= _ _.
        <span class="bp">by</span> <span class="nb">rewrite</span> a1E2.
      <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
    <span class="nb">have</span> P5 : 
      (S_[<span class="mi">3</span> * c] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u2 + sp ‚Üì[u (inord a1)] <span class="mi">3</span> p2 +
                                     sp ‚Üì[u ord_max] <span class="mi">3</span> (a[p3, p1] l).
      <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH2) (leq_add (leq_add _ _) _);
          <span class="nb">rewrite</span> // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
      - <span class="bp">by</span> <span class="nb">rewrite</span> a1E2 eq_sym.
      - <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= addn0 cE1 muln1.
      <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= mod3E /= div3E // cE1 muln1.
      <span class="nb">rewrite</span> a1El addn1 (_ : inord _ = ord_max) <span class="nl">?apegS</span> //.
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">have</span> {}P5 := leq_trans P5 (leq_add (leqnn _) (leq_sum_beta _ _)).
    <span class="nb">rewrite</span> // {<span class="mi">1</span>}[<span class="kr">in</span> <span class="mi">3</span> *c]cE1 muln1 <span class="kr">in</span> P5.
    <span class="nb">set</span> x2S := sd _ <span class="kr">in</span> P5.
    <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P5; <span class="nb">set</span> y4S := \sum_(_ &lt; _) _ <span class="kr">in</span> P5.
    <span class="nb">rewrite</span> /sd -(big_mkord xpredT 
                   (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove)).
    <span class="nb">rewrite</span> (big_cat_nat _ _ _ (_ : <span class="mi">0</span> &lt;= a1)) //=; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>: ltnW.
    <span class="nb">rewrite</span> big_mkord -!addnA.
    <span class="nb">apply</span>: leq_trans (leq_add P1l1  (leqnn _)); <span class="nb">rewrite</span> -/x1S.
    <span class="nb">rewrite</span> -{P1l1}P2 -/x2S {<span class="mi">1</span>}lE2 !sum_beta_S //.
    <span class="nb">rewrite</span> KH1 KH2 !eqxx !addn0 aE1 -/y1S -/y4S.
    <span class="nb">have</span> y2Sy3SE : y2S + y3S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[<span class="mi">4</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a1 : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a1E2 lE2.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a1E2.
    <span class="nb">rewrite</span> {<span class="mi">1</span>}aE1 -[<span class="mi">1</span>.*<span class="mi">2</span>]/<span class="mi">2</span> <span class="kr">in</span> P1.
    <span class="nb">rewrite</span> {<span class="mi">1</span>}cE1 -[<span class="mi">1</span>.*<span class="mi">2</span>]/<span class="mi">2</span>.
    <span class="nb">have</span> F1n4 := dsum_alphaL_S <span class="mi">4</span> n.
    <span class="nb">have</span> F1n3 : (S_[<span class="mi">3</span>] n.+<span class="mi">2</span>).+<span class="mi">1</span> = S_[<span class="mi">1</span>] n.+<span class="mi">3</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -dsum_alpha3_S.
    <span class="nb">have</span> F1n13 : (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span> = S_[<span class="mi">1</span>] n.+<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -dsum_alpha3_S.
   <span class="c">(* lia should work *)</span>
    <span class="nb">move</span>: P4 P5 =&gt; P4 P5.
    <span class="nb">rewrite</span> -(leq_add2r y2S); applyr P4.
    <span class="nb">rewrite</span> -(leq_add2r y3S); applyr P5.
    applyl y2Sy3SE.
    <span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]mul2n -addnn.
    <span class="nb">rewrite</span> {<span class="mi">1</span>}F1n4; gsimpl.
    <span class="nb">rewrite</span> -(leq_add2r <span class="mi">2</span>).
    changel (((S_[<span class="mi">3</span>] n.+<span class="mi">2</span>).+<span class="mi">1</span>).*<span class="mi">2</span> + (S_[<span class="mi">1</span>] n).*<span class="mi">2</span>). 
    changer (<span class="mi">4</span> + S_[<span class="mi">4</span>] n + S_[<span class="mi">4</span>] n.+<span class="mi">1</span> + ((S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span>).*<span class="mi">2</span>).
    <span class="nb">rewrite</span> {}F1n3 {}F1n13.
    <span class="nb">case</span> : n =&gt; [|[|[|[|n1]]]]; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> !alphaS_small.
    <span class="nb">set</span> m1 := n1.+<span class="mi">3</span>.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] m1.+<span class="mi">2</span>).*<span class="mi">2</span>).
    <span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">6</span>).
    <span class="nb">have</span> F := leq_S4 m1.+<span class="mi">1</span>; applyr F.
    <span class="nb">have</span> F := leq_S4 m1.+<span class="mi">2</span>; applyr F; gsimpl.
    <span class="nb">have</span> F3n3 := dsum_alphaL_S <span class="mi">1</span> m1.+<span class="mi">3</span>.
    <span class="nb">have</span> F3n2 := dsum_alphaL_S <span class="mi">1</span> m1.+<span class="mi">2</span>.
    <span class="nb">have</span> F3n1 := dsum_alphaL_S <span class="mi">1</span> m1.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> !(F3n3, F3n2, F3n1); gsimpl.
    <span class="nb">have</span> F4m1 : <span class="mi">12</span> * Œ±_[<span class="mi">1</span>] m1.+<span class="mi">3</span> &lt;= <span class="mi">16</span> * Œ±_[<span class="mi">1</span>] m1.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> -[<span class="mi">12</span>]/(<span class="mi">4</span> * <span class="mi">3</span>) -mulnA.
      <span class="nb">rewrite</span> -[<span class="mi">16</span>]/(<span class="mi">4</span> * <span class="mi">4</span>) -mulnA leq_mul2l /=.
      <span class="bp">by</span> <span class="nb">rewrite</span> alpha_4_3.
    <span class="nb">apply</span>: leq_trans (leq_trans _ F4m1) _; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2r orbT.
    gsimpl.
    <span class="nb">have</span> F4m2 : <span class="mi">9</span> * Œ±_[<span class="mi">1</span>] m1.+<span class="mi">2</span> &lt;= <span class="mi">12</span> * Œ±_[<span class="mi">1</span>] m1.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> -[<span class="mi">12</span>]/(<span class="mi">3</span> * <span class="mi">4</span>) -mulnA.
      <span class="nb">rewrite</span> -[<span class="mi">9</span>]/(<span class="mi">3</span> * <span class="mi">3</span>) -mulnA leq_mul2l /=.
      <span class="bp">by</span> <span class="nb">rewrite</span> alpha_4_3.
    <span class="bp">by</span> applyr F4m2; gsimpl.
<span class="c">(* subcase b = 1 *)</span>
  <span class="nb">have</span> bE0 : b = <span class="mi">0</span> <span class="bp">by</span> <span class="nb">case</span>: (b) b_lt1 =&gt; //.
  <span class="nb">have</span> lE1 : l = <span class="mi">1</span> <span class="bp">by</span> <span class="nb">have</span> := l1E; <span class="nb">rewrite</span> aE1 bE0 cE1 =&gt; [] [].
  <span class="nb">have</span> a1E1 : a1 = <span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> a1El.
  <span class="nb">rewrite</span> (_ : a[p3, p1] l = a[p2, p1] l); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> lE1.
  <span class="nb">apply</span>: (@case2 _ IH)  =&gt; //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> (_ : a[p1, p3] _ = a[p1, p3] <span class="mi">1</span>).
  - <span class="nb">move</span>=&gt; k hK; <span class="nb">rewrite</span> {<span class="mi">3</span>}lE1 <span class="kr">in</span> hK.
    <span class="nb">have</span> -&gt; : k = inord <span class="mi">1</span>.
      <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK //.
      <span class="bp">by</span> <span class="nb">case</span>: (k : nat) hK =&gt; [] // [|].
    <span class="nb">rewrite</span> inordK //= !(apegS, apeg0) //= codom_subC.
    <span class="nb">have</span> := cH (inord <span class="mi">1</span>).
    <span class="nb">rewrite</span> inordK // !(apegS, apeg0).
    <span class="bp">by</span> <span class="nb">apply</span>. 
  - <span class="bp">by</span> <span class="nb">rewrite</span> KH2 lE1.
  <span class="nb">move</span>=&gt; k.
  <span class="nb">have</span> [-&gt;|[-&gt;|-&gt;]] // : k = ord0 \/ k = (inord <span class="mi">1</span>) \/ k = (inord <span class="mi">2</span>).
  - <span class="nb">move</span>: k; <span class="nb">rewrite</span> lE1.
    <span class="nb">case</span> =&gt; [] []; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span>: val_inj =&gt; /=.
    <span class="nb">case</span>.
      <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">left</span>; <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">case</span> =&gt; //.
    <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">right</span>; <span class="nb">apply</span>: val_inj; <span class="nb">rewrite</span> /= inordK.
  <span class="bp">by</span> <span class="nb">rewrite</span> -[<span class="kr">in</span> inord <span class="mi">1</span>]aE1 uaLEp2 aE1 inordK.
  <span class="nb">rewrite</span> {<span class="mi">1</span>}(_ : inord <span class="mi">2</span> = ord_max); <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= lE1 inordK.
  <span class="bp">by</span> <span class="nb">rewrite</span> KH2 lE1 /= inordK.
<span class="c">(* This is 4.2.3 a = 1, c &gt;= 2 *)</span>
<span class="nb">pose</span> u2r := [ffun i : &#39;I_(<span class="mi">3</span> * c).-<span class="mi">2</span>.+<span class="mi">1</span> =&gt; u2 (inord i.+<span class="mi">2</span>)].
<span class="nb">pose</span> pa1 := a[p1, p3] a1.
<span class="nb">pose</span> pa1S := a[p1, p3] a1.+<span class="mi">1</span>.
<span class="nb">have</span> cH8 (k : &#39;I_(<span class="mi">3</span> * c).-<span class="mi">2</span>.+<span class="mi">1</span>) : 
  <span class="mi">0</span> &lt; k &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span> -&gt; codom (u2r k) \subset [:: p2; a[pa1, pa1S] k].
  <span class="nb">move</span>=&gt; /andP[k_gt0 k3L3a].
  <span class="nb">have</span> k2L3c : k.+<span class="mi">2</span> &lt; (<span class="mi">3</span> * c).
    <span class="bp">by</span> <span class="nb">have</span> := k3L3a; <span class="nb">rewrite</span> -{<span class="mi">2</span>}subn2 ltn_subRL add2n.    
  <span class="nb">rewrite</span> !ffunE inordK <span class="nl">?ltnS</span> <span class="mi">1</span><span class="nl">?ltnW</span> //.
  <span class="nb">case</span>: eqP =&gt; [km3E0 /= |/eqP km3D0].
    <span class="nb">have</span> k3_gt0 : <span class="mi">0</span> &lt; k.+<span class="mi">2</span> %/ <span class="mi">3</span>.
      <span class="nb">case</span>: (k: nat) k_gt0 km3E0  =&gt; // [] //= k1 _ _.
      <span class="bp">by</span> <span class="nb">rewrite</span> (divnMDl <span class="mi">1</span> k1 (_ : <span class="mi">0</span> &lt; <span class="mi">3</span>)).
    <span class="nb">have</span> a1k3Ll1 : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
      <span class="nb">move</span>: k2L3c.
      <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E0 addn0 mulnC ltn_mul2l /= =&gt; k2L3c.
      <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span>)) ; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S !addnS !apegS -apegD addnC.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + (k.+<span class="mi">2</span>) %/ <span class="mi">3</span>)) ; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> apegO oddD {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) !oddD oddM andbT -oddD.
      <span class="bp">by</span> <span class="nb">rewrite</span> km3E0 addn0 -oddD -apegO.
    <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>) : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> inordK; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> addn_gt0 a1_gt0.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltnS ltnW.
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK // ltnS ltnW.
  <span class="nb">case</span>: eqP =&gt; [km3E1|/eqP km3D1].
    <span class="nb">rewrite</span> eqn_leq ltnNge /=.
    <span class="nb">have</span> a1La1k : a1 &lt; a1 + k.+<span class="mi">2</span> %/<span class="mi">3</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(addn0 a1) ltn_add2l divn_gt0.
    <span class="nb">have</span> a1k3Ll : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
      <span class="nb">move</span>: (ltnW k2L3c).
      <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E1 addn1 mulnC ltn_mul2l /=.
      <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span>)) ; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> /pa1S !addnS !apegS -apegD addnC.
    <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + (k.+<span class="mi">2</span>) %/ <span class="mi">3</span>).+<span class="mi">1</span>) ; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> apegS apegO {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) !oddD oddM andbT.
      <span class="bp">by</span> <span class="nb">rewrite</span> km3E1 addbT addbN -oddD -oddS -apegO apegS.
    <span class="nb">case</span>: (sitiHb (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>)) =&gt; // [| siH _ _]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> a1La1k.
    <span class="bp">by</span> <span class="nb">move</span>: siH; <span class="nb">rewrite</span> a1Max // ltnS ltnW.
  <span class="nb">have</span> km3E2 : k.+<span class="mi">2</span> %% <span class="mi">3</span> = <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">case</span>: (_ %% _) (ltn_mod k.+<span class="mi">2</span> <span class="mi">3</span>) km3D0 km3D1 =&gt; // [] [|[|]].
  <span class="nb">rewrite</span> ifN; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0.
  <span class="nb">have</span> a1La1k : a1 &lt; a1 + k.+<span class="mi">2</span> %/<span class="mi">3</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">1</span>}(addn0 a1) ltn_add2l divn_gt0.
  <span class="nb">have</span> a1k3Ll : a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span> &lt; l.+<span class="mi">1</span>.
    <span class="nb">have</span>: k.+<span class="mi">2</span> %/ <span class="mi">3</span> * <span class="mi">3</span> &lt; <span class="mi">3</span> * c.
      <span class="nb">rewrite</span> ltnW //.
      <span class="nb">move</span>: (ltnW k2L3c).
      <span class="bp">by</span> <span class="nb">rewrite</span> {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) km3E2 addn2.
    <span class="nb">rewrite</span> mulnC ltn_mul2l /=.
    <span class="nb">rewrite</span> -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) ?(leq_trans a1Ll) //.
    <span class="bp">by</span> <span class="nb">rewrite</span> addnC ltn_add2r -/c.
  <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + k.+<span class="mi">2</span>)) ; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> !addnS /pa1S !apegS -apegD addnC.
  <span class="nb">rewrite</span> (_ : a[_, _ ] _ = a[p1, p3] (a1 + (k.+<span class="mi">2</span>) %/ <span class="mi">3</span>)) ; <span class="nb">last first</span>.
    <span class="nb">rewrite</span> apegO {<span class="mi">1</span>}(divn_eq k.+<span class="mi">2</span> <span class="mi">3</span>) !oddD oddM andbT.
    <span class="bp">by</span> <span class="nb">rewrite</span> km3E2 addbF -oddD -apegO.
  <span class="nb">rewrite</span> codom_subC.
  <span class="nb">case</span>: (sitiHb (a1 + k.+<span class="mi">2</span> %/ <span class="mi">3</span>)) =&gt; // [| _ tiH _]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> a1La1k.
  <span class="bp">by</span> <span class="nb">move</span>: tiH; <span class="nb">rewrite</span> a1Max // a1La1k ltnS ltnW.
<span class="nb">have</span> c_gt0 : <span class="mi">0</span> &lt; c <span class="bp">by</span> <span class="nb">rewrite</span> ltnW.
<span class="nb">have</span> P8 :
  (S_[(<span class="mi">3</span> * c).-<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
  \sum_(i &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>) `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove +
  sp ta1 (<span class="mi">3</span> * c).-<span class="mi">2</span> pa1 + sp ‚Üì[u ord_max] (<span class="mi">3</span> * c).-<span class="mi">2</span> (a[p3, p1] l).
  <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH8) _; <span class="nb">rewrite</span> /pa1 /pa1S {cH8}//.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apegS apeg_eqC.
  - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
  <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
  - <span class="nb">apply</span>: eq_bigr =&gt; i _.
    <span class="bp">by</span> <span class="nb">rewrite</span> ![u2r _]ffunE !inordK // ltnS // ltnW.
  - <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> ((_ != _) * _).
    <span class="nb">rewrite</span> !ffunE /= !inordK //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : <span class="mi">2</span> &lt; (<span class="mi">3</span> * <span class="mi">1</span>).+<span class="mi">1</span>)) // ltnS leq_mul2l ltnW.
  <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> ((_ != _) * _).
    <span class="nb">rewrite</span> !ffunE /= !prednK <span class="nl">?muln_gt0</span> //=; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> -subn1 ltn_subRL addn0 (leq_trans (_ : _ &lt; <span class="mi">3</span> * <span class="mi">1</span>)) //
                 leq_mul2l.
    <span class="nb">rewrite</span> inordK // mod3E /= div3E addnC subnK; <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: (leq_trans a1Ll).
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE; <span class="nb">congr</span> (u _ _ ); <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">rewrite</span> /pa1 /pa1S -[RHS]apegS -(subnK (_ : a1 &lt;= l.+<span class="mi">1</span>)) // -/c.
    <span class="nb">rewrite</span> apegS -apegD apegO -subn2 oddD oddB //.
      <span class="bp">by</span> <span class="nb">rewrite</span> oddM /= addbF -oddD -apegO.
    <span class="bp">by</span> <span class="nb">rewrite</span> (leq_trans (_ : _ &lt; <span class="mi">3</span> * <span class="mi">1</span>)) // leq_mul2l //.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltnW.
<span class="nb">rewrite</span> {cH8}//.
<span class="nb">have</span> l_gt0 : <span class="mi">0</span> &lt; l.
  <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E aE1 add1n addSn ltnS addn_gt0 c_gt0 orbT.
<span class="nb">have</span> c3m2_gt1 : <span class="mi">1</span> &lt; (<span class="mi">3</span> * c).-<span class="mi">2</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL -[<span class="mi">2</span> +<span class="mi">1</span>]/(<span class="mi">3</span> * <span class="mi">1</span>) ltn_mul2l.
<span class="nb">have</span> {}P8 := leq_trans P8 (leq_add (leq_add (leqnn _) (leqnn _))
                      (leq_sum_beta _ _)).
<span class="nb">set</span> y7S := sp _ _ _ <span class="kr">in</span> P8; <span class="nb">set</span> y8S := \sum_(_ &lt; n.+<span class="mi">1</span>) _ <span class="kr">in</span> P8.
<span class="nb">rewrite</span> !sum_beta_S // KH1 KH2 !eqxx !addn0 -/y8S.
<span class="nb">rewrite</span> (_ : sd u =
  \sum_(i &lt; a) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
  \sum_(a &lt;= i &lt; a1) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
  \sum_(a1 &lt;= i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove); <span class="nb">last first</span>.
  <span class="nb">rewrite</span> /sd -[X <span class="kr">in</span> _ = X + _ + _](big_mkord xpredT 
                (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove)).
  <span class="bp">by</span> <span class="nb">rewrite</span> -!big_cat_nat <span class="nl">?big_mkord</span> //= ltnW.
<span class="nb">rewrite</span> -{}P1 -{}P2.
<span class="nb">move</span>: P3 =&gt; P3.
<span class="nb">rewrite</span> -<span class="mi">2</span>!addnA.
<span class="nb">apply</span>: leq_trans (leq_add (leq_add (leqnn _) P3) (leqnn _)); <span class="nb">rewrite</span> {P3}//.
<span class="nb">have</span> du2E : `d[‚Üì[u (inord a1)], sa1]_smove + `d[sa1, ta1]_smove =
             \sum_(i &lt; <span class="mi">2</span>) `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove.
  <span class="nb">rewrite</span> !big_ord_recr /= big_ord0 !ffunE !inordK //= <span class="nl">?addn0</span> //.
    <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS (leq_mul2l <span class="mi">3</span> <span class="mi">1</span>).
  <span class="bp">by</span> <span class="nb">rewrite</span> ltnS muln_gt0.
<span class="nb">rewrite</span> (_ : sd u2 =
  (`d[‚Üì[u (inord a1)], sa1]_smove + `d[sa1, ta1]_smove) +
  \sum_(i &lt;  (<span class="mi">3</span> * c).-<span class="mi">2</span>) `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove);
   <span class="nb">last first</span>.
  <span class="nb">rewrite</span> /sd du2E.
  <span class="nb">rewrite</span> -!(big_mkord xpredT 
                (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove)).
  <span class="nb">rewrite</span> -!(big_mkord xpredT 
                (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u2 (inord i.+<span class="mi">2</span>), u2 (inord i.+<span class="mi">3</span>)]_smove)).
  <span class="nb">rewrite</span>[X <span class="kr">in</span> _ = _ + X] (eq_bigr
                (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u2 (inord (i + <span class="mi">2</span>)), u2 (inord (i + <span class="mi">2</span>).+<span class="mi">1</span>)]_smove)); 
    <span class="nb">last</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; i_; <span class="nb">rewrite</span> !addn2.
  <span class="nb">rewrite</span> -subn2.
  <span class="nb">have</span> &lt;- := big_addn _ _ _ xpredT 
               (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u2 (inord i), u2 (inord i.+<span class="mi">1</span>)]_smove).
  <span class="nb">rewrite</span> -big_cat_nat //.
  <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // (leq_mul2l <span class="mi">3</span> <span class="mi">1</span>).
<span class="nb">set</span> x3S := \sum_(_ &lt; _) _ <span class="kr">in</span> P8; <span class="nb">rewrite</span> -/x3S.       
<span class="nb">have</span> [|b_gt0] := leqP b <span class="mi">0</span>; <span class="nb">last first</span>.
<span class="c">(* subcase 1 &lt;= b *)</span>
  <span class="nb">have</span> cH1 (k : &#39;I_(<span class="mi">3</span> * a).+<span class="mi">1</span>) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> * a -&gt; codom (u1 k) \subset [:: p3; a[p1, p2] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k_ltb].
    <span class="nb">rewrite</span> {<span class="mi">2</span>}aE1 muln1 <span class="kr">in</span> k_ltb.
    <span class="nb">rewrite</span> ffunE !modn_small // !divn_small // inord_eq0 //.
    <span class="nb">rewrite</span> [<span class="kr">in</span> <span class="mi">3</span> * a.-<span class="mi">1</span>]aE1 /=.
    <span class="nb">case</span>: (k : nat) k_gt0 k_ltb =&gt; //= [] [|[|]] //= _ _.
      <span class="nb">rewrite</span> apegS apeg0.
      <span class="bp">by</span> <span class="nb">have</span> := sam1C; <span class="nb">rewrite</span> /pa aE1.
    <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
  <span class="nb">set</span> x0S := sd u1.
  <span class="nb">have</span> P4 : 
    (S_[<span class="mi">3</span> * a] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= x0S + sp ‚Üì[u ord0] <span class="mi">3</span> p1 +
                                 sp ‚Üì[u (inord a)] <span class="mi">3</span> p2.
    <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH1) (leq_add (leq_add _ _) _);
        <span class="nb">rewrite</span> // <span class="mi">1</span><span class="nl">?eq_sym</span> //.
      <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= inord_eq0 // aE1 muln1.
    <span class="bp">by</span> <span class="nb">apply</span>: leq_sum =&gt; i _; <span class="nb">rewrite</span> ffunE /= mod3E /= div3E // aE1 muln1.
  <span class="nb">have</span> {}P4 := leq_trans P4 (leq_add (leq_add (leqnn _) (leq_sum_beta _ _))
                        (leqnn _)).
  <span class="nb">set</span> y0S := \sum_(_ &lt; _) _ <span class="kr">in</span> P4; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P4.
  <span class="nb">have</span> [b_gt1|b_le2] := leqP <span class="mi">2</span> b.
<span class="c">(*  subcase b &gt;= 2 *)</span>  
    <span class="nb">pose</span> u3 := [ffun i =&gt; ‚Üì[u (inord ((i : &#39;I_b.+<span class="mi">1</span>) + a))]].
    <span class="nb">pose</span> paS := a[p1, p3] a.+<span class="mi">1</span>.
    <span class="nb">have</span> cH6 (k : &#39;I_b.+<span class="mi">1</span>) :
        <span class="mi">0</span> &lt; k &lt; b -&gt; codom (u3 k) \subset [:: p2; a[pa, paS] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 kLb].
      <span class="nb">have</span> kBound : <span class="mi">0</span> &lt; k + a &lt; l.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> (leq_trans a_gt0) <span class="nl">?leq_addl</span> //=.
        <span class="nb">move</span>: kLb; <span class="nb">rewrite</span> /b ltn_subRL addnC =&gt; /leq_trans-&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnW.
      <span class="nb">rewrite</span> ffunE codom_liftr //.
      <span class="nb">have</span> := @cH (inord (k + a)).
      <span class="nb">rewrite</span> /pa /paS apegS -apegD /= !inordK //; <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltnW // ltnS; <span class="nb">case</span>/andP: kBound.
      <span class="bp">by</span> <span class="nb">apply</span>.
    <span class="nb">have</span> {cH6}P6 : 
    (S_[b] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u3 + sp (u3 ord0) b pa + 
                               sp (u3 ord_max) b (a[pa, paS] b).
      <span class="nb">apply</span>: IH cH6 =&gt; //; <span class="kp">try</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa /paS // eq_sym.
      <span class="bp">by</span> <span class="nb">rewrite</span> /paS apegS apeg_eqC.
    <span class="nb">set</span> x1S := \sum_(_ &lt;= _ &lt; _) _.
    <span class="nb">rewrite</span> !ffunE (_ : sd u3  = x1S) <span class="kr">in</span> P6; <span class="nb">last first</span>.
      <span class="nb">rewrite</span> /x1S -[a]add0n big_addn -/b big_mkord.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE !inordK <span class="nl">?ltnS</span> // ltnW.
    <span class="nb">rewrite</span> add0n subnK // <span class="kr">in</span> P6.
    <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P6; <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P6.
    <span class="nb">have</span> aLl : a &lt;= l <span class="bp">by</span> <span class="nb">apply</span>: leq_trans aLa1 _.
    <span class="nb">have</span> y1Sy2SE : y1S + y2S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">3</span> b] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa eq_sym.
      <span class="nb">apply</span>/codom_liftr.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a_gt0.
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK // aE1  /=.
    <span class="nb">pose</span> u5 := [ffun i : &#39;I_3 =&gt;
                     <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a1)]
                     <span class="kr">else</span> <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> ta1].
    <span class="nb">have</span> cH7 (k : &#39;I_3) : 
      <span class="mi">0</span> &lt; k &lt; <span class="mi">2</span> -&gt; codom (u5 k) \subset [:: p1; a[p2, p3] k].
      <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt2].
      <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">have</span> -&gt;/= : k = <span class="mi">1</span> :&gt; nat <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0 k_lt2 =&gt; // [] [|].
    <span class="nb">have</span> P7 : 
      (S_[<span class="mi">2</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;=
      (`d[‚Üì[u (inord a1)], sa1]_smove + `d[sa1, ta1]_smove) +
         sp ‚Üì[u (inord a1)] <span class="mi">2</span> p2 + sp ta1 <span class="mi">2</span> p2.
      <span class="nb">apply</span>: (leq_trans (IH _ _ _ _ _ _ cH7)) =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="kp">repeat</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
      - <span class="bp">by</span> <span class="nb">rewrite</span> /sd !big_ord_recr big_ord0 !ffunE !inordK /=.
      - <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
      <span class="bp">by</span> <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">set</span> x2S := (`d[_, _]_ _ + `d[_, _]_ _); <span class="nb">rewrite</span> -/x2S <span class="kr">in</span> P7.
    <span class="nb">set</span> y4S := sp _ _ _ <span class="kr">in</span> P7; <span class="nb">set</span> y5S := sp _ _ _ <span class="kr">in</span> P7.
    <span class="nb">have</span> y3Sy4SE : y3S + y4S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn b <span class="mi">2</span>] n.
      <span class="nb">apply</span>: sum_alpha_diffE =&gt; //.
        <span class="bp">by</span> <span class="nb">rewrite</span> /paS apegS -apegD apeg_neq // eq_sym.
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH : <span class="mi">0</span> &lt; (inord a1 : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> inordK <span class="nl">?a1_gt0</span> // ltnS (leq_trans a1Ll).
      <span class="nb">rewrite</span> inordK <span class="nl">?ltnS</span> ?(leq_trans a1Ll) //.
      <span class="bp">by</span> <span class="nb">rewrite</span> /paS apegS -apegD subnK.
    <span class="nb">rewrite</span> (maxn_idPl _) // <span class="kr">in</span> y3Sy4SE.
    <span class="nb">have</span> y5Sy7SE : y5S + y7S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">2</span> (<span class="mi">3</span> * c).-<span class="mi">2</span>] n.
      <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa1 eq_sym.
    <span class="nb">rewrite</span> (maxn_idPr _) // <span class="kr">in</span> y5Sy7SE.
    <span class="nb">rewrite</span> -/y0S.
    <span class="nb">move</span>: P4 P6 P7 P8 =&gt; P4 P6 P7 P8.
    <span class="nb">rewrite</span> -(leq_add2r y1S); applyr P4.
    <span class="nb">rewrite</span> -(leq_add2r (y2S + y3S)); applyr P6.
    <span class="nb">rewrite</span> -(leq_add2r (y4S + y5S)); applyr P7.
    <span class="nb">rewrite</span> -(leq_add2r y7S); applyr P8.
    applyl y5Sy7SE; applyl y3Sy4SE; applyl y1Sy2SE.
    <span class="nb">rewrite</span> aE1 !muln1.
    <span class="nb">have</span> F1 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n.
    <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X]mul2n -addnn -ltnS ![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addnA 
            -![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addnS {<span class="mi">2</span>}F1  {F1}//.
    gsimpl.
    <span class="nb">have</span> F2 i k : <span class="mi">0</span> &lt; i -&gt; S_[i.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *i).-<span class="mi">2</span>] k + i.-<span class="mi">1</span>.
      <span class="nb">move</span>=&gt; i_gt0; <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
      <span class="nb">rewrite</span> leq_add2r.
      <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
      <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[i]prednK // mulnS addSn add2n /=.
    <span class="nb">have</span> F2n := F2 c n c_gt0.
    <span class="nb">have</span> F2n1 := F2 c n.+<span class="mi">1</span> c_gt0.
    <span class="nb">have</span> F3 : c = c.-<span class="mi">1</span>.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> prednK.
    <span class="nb">rewrite</span> {}[<span class="kr">in</span> <span class="mi">2</span> * c]F3.
    gsimpl.
    applyr F2n; applyr F2n1; <span class="nb">rewrite</span> {F2}//.
    <span class="nb">have</span> l_gt1 : <span class="mi">1</span> &lt; l.
      <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E aE1 add1n addSn ltnS (leq_trans b_gt1) // leq_addr.
    <span class="nb">have</span> F4 := SH l_gt1; applyl F4.
    <span class="nb">have</span> cB1_gt0 : <span class="mi">0</span> &lt; c.-<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS prednK.
    <span class="nb">have</span> F5 : S_[l.+<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[b.+<span class="mi">3</span>] n.+<span class="mi">2</span>.
      <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X]addnC.
      <span class="nb">rewrite</span> (_ : l.+<span class="mi">1</span> =  <span class="mi">1</span> + c.-<span class="mi">2</span> + b.+<span class="mi">2</span>); <span class="nb">last first</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> l1E aE1 !add1n -addSnnS !prednK // addnC.
      <span class="nb">rewrite</span> (_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
         <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
    <span class="nb">have</span> F6 : S_[l] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[b.+<span class="mi">2</span>] n.+<span class="mi">1</span>.
      <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= X]addnC.
      <span class="nb">rewrite</span> (_ : l =  <span class="mi">1</span> + c.-<span class="mi">2</span> + b.+<span class="mi">1</span>); <span class="nb">last first</span>.
        <span class="nb">rewrite</span> -[l]/(l.+<span class="mi">1</span>.-<span class="mi">1</span>) l1E aE1.
        <span class="bp">by</span> <span class="nb">rewrite</span> !add1n -addSnnS !prednK // addnC addnS.
      <span class="nb">rewrite</span> (_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
         <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
    <span class="nb">rewrite</span> -(leq_add2r (S_[b.+<span class="mi">2</span>] n.+<span class="mi">1</span>)); applyr F6.
    <span class="nb">rewrite</span> -(leq_add2r (S_[b.+<span class="mi">3</span>] n.+<span class="mi">2</span>)); applyr F5; gsimpl.
    <span class="nb">have</span> [b_gt2|b_le3] := leqP <span class="mi">3</span> b.
<span class="c">(*    subcase b &gt;= 3 *)</span>
      <span class="nb">have</span> F7 := dsum_alphaL_S b n; <span class="nb">rewrite</span> {}F7; gsimpl.
      <span class="nb">have</span> F8 : S_[b.+<span class="mi">3</span>] n.+<span class="mi">2</span> &lt;= S_[b.+<span class="mi">2</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
        <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
      applyl F8.
      <span class="nb">have</span> F9 : S_[b.+<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[b] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
        <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
      <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F9.
      <span class="nb">rewrite</span> -(leq_add2r (<span class="mi">4</span> * Œ±_[<span class="mi">1</span>] n)); applyr F9.
      <span class="nb">have</span> F10 : S_[<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[b.+<span class="mi">2</span>] n.+<span class="mi">1</span> &lt;= S_[b.+<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">2</span>] n.+<span class="mi">1</span>.
        <span class="nb">rewrite</span> addnC -[b.+<span class="mi">2</span>]/(<span class="mi">1</span> + <span class="mi">1</span> + b).
        <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
      <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F10; applyr F10.
      <span class="nb">rewrite</span> -<span class="mi">2</span>!ltnS  [<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]mul2n -![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addSn -doubleS.
      <span class="nb">have</span> F11 := dsum_alpha3_S n.+<span class="mi">1</span>; <span class="nb">rewrite</span> -F11.
      <span class="nb">have</span> F12 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>; <span class="nb">rewrite</span> F12.
      <span class="nb">have</span> F13 := dsum_alphaL_S <span class="mi">1</span> n; <span class="nb">rewrite</span> !F13; gsimpl.
      <span class="bp">by</span> <span class="nb">have</span> F14 := alphaL_1_2 n; applyl F14; gsimpl.
<span class="c">(*  subcase b = 2 *)</span>
    <span class="nb">have</span> bE2 : b = <span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">case</span>: (b) b_gt1 b_le3 =&gt; // [] [|[|]].
    <span class="nb">rewrite</span> bE2.
    <span class="nb">rewrite</span> ![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]mul2n -!addnn.
    <span class="nb">have</span> F1 := dsum_alphaL_S <span class="mi">2</span> n; <span class="nb">rewrite</span> {<span class="mi">1</span>}F1.
    <span class="nb">have</span> F2 := dsum_alphaL_S <span class="mi">3</span> n; <span class="nb">rewrite</span> {<span class="mi">1</span>}F2.
    <span class="nb">have</span> F3 : S_[<span class="mi">5</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">4</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">rewrite</span> -[<span class="mi">3</span> + <span class="mi">2</span>]/<span class="mi">5</span> -[<span class="mi">2</span> + <span class="mi">2</span>]/<span class="mi">4</span>; applyl F3.
    <span class="nb">have</span> F4 : S_[<span class="mi">4</span>] n.+<span class="mi">1</span> &lt;= S_[<span class="mi">3</span>] n + (Œ±_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
    <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F4; applyl F4; gsimpl.
    <span class="nb">rewrite</span> -ltnS.
    <span class="nb">have</span> F5 := dsum_alpha3_S n.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> -![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addSn -F5.
    <span class="nb">have</span> F6 := dsum_alpha3_S n.
    <span class="nb">rewrite</span> addnAC -!addnS -F6.
    <span class="nb">rewrite</span> -leq_double.
    <span class="nb">have</span> F7 := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>.
    <span class="nb">have</span> F8 := leq_dsum_alpha_2l_1 n.
    <span class="nb">rewrite</span> -[_ &lt;= _]orFb -(leq_mul2l <span class="mi">3</span>) <span class="kr">in</span> F7.
    applyr F7; applyr F8; gsimpl.
    <span class="nb">have</span> F9 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
    <span class="nb">have</span> F10 := dsum_alphaL_S <span class="mi">1</span> n.
    <span class="nb">rewrite</span> !(F9, F10); gsimpl.
    <span class="bp">by</span> <span class="nb">have</span> F11 := alphaL_1_2 n; applyl F11; gsimpl.
<span class="c">(* subcase b = 1 *)</span>
  <span class="nb">have</span> bE1 : b = <span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">case</span>: (b) b_gt0 b_le2 =&gt; // [] [|].
  <span class="nb">have</span> a1E2 : a1 = <span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">move</span>: bE1; <span class="nb">rewrite</span> /b aE1; <span class="nb">case</span>: (a1) =&gt; // [] [|[]].
  <span class="nb">pose</span> u3 := 
    [ffun i : &#39;I_4 =&gt;  
    <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a)] <span class="kr">else</span>
    <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a1)] <span class="kr">else</span>
    <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> ta1].
  <span class="nb">set</span> x1S := \sum_(_ &lt;= _ &lt; _) _.
  <span class="nb">set</span> d1 := `d[_, _]_ _ + `d[_, _]_ _.
  <span class="nb">rewrite</span> -/y0S.
  changer (a.*<span class="mi">2</span> + x0S + c.*<span class="mi">2</span> + x3S + y0S + y8S + (x1S + d1)).
  <span class="nb">have</span> -&gt; : x1S + d1 = \sum_(i &lt; <span class="mi">3</span>) `d[u3 (inord i), u3 (inord i.+<span class="mi">1</span>)]_smove.
    <span class="nb">rewrite</span> /x1S aE1 a1E2 big_nat1 /d1 !big_ord_recr big_ord0 /=.
    <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE !inordK //= aE1 a1E2 add0n !addnA.
    <span class="nb">have</span> l_gt2 : <span class="mi">2</span> &lt; l <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS l1E aE1 bE1 !add1n.
  <span class="nb">set</span> x6S := \sum_(_ &lt; <span class="mi">3</span>) _.
  <span class="nb">have</span> cH6 (k : &#39;I_4) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">3</span> -&gt; codom (u3 k) \subset [:: pa1; a[pa1S, p2] k].
    <span class="nb">move</span>=&gt; /andP[k_gt0 k_lt3].
    <span class="nb">rewrite</span> !ffunE eqn_leq leqNgt k_gt0 /=.
    <span class="nb">case</span>: eqP =&gt; [-&gt;/=|/eqP kD1].
      <span class="nb">apply</span>: codom_liftr; <span class="nb">rewrite</span> codom_subC.
      <span class="nb">have</span> /cH :  <span class="mi">0</span> &lt; (inord a1 : &#39;I_l.+<span class="mi">2</span> ) &lt; l.+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> inordK a1E2 // (leq_trans l_gt2).
      <span class="bp">by</span> <span class="nb">rewrite</span> inordK // a1E2 (leq_trans l_gt2) // ltnW.
    <span class="nb">have</span> -&gt; : k = <span class="mi">2</span> :&gt; nat.
      <span class="bp">by</span> <span class="nb">case</span>: (k : nat) k_gt0 k_lt3 kD1 =&gt; // [] [|[]].
    <span class="bp">by</span> <span class="nb">have</span> := sa1C; <span class="nb">rewrite</span> eqxx /pa1 /pa1S !(apegS, apeg0) codom_apeg.
  <span class="nb">have</span> P6 : 
    (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= x6S + sp (u3 ord0) <span class="mi">3</span> pa1S + sp (u3 ord_max) <span class="mi">3</span> p2.
    <span class="nb">apply</span>: IH cH6; <span class="nb">rewrite</span> /pa1S /pa1 //.
    <span class="bp">by</span> <span class="nb">rewrite</span> a1E2 eq_sym.
  <span class="nb">rewrite</span> !ffunE /= <span class="kr">in</span> P6.
  <span class="nb">set</span> y2S := sp _ _ _ <span class="kr">in</span> P6; <span class="nb">set</span> y3S := sp _ _ _ <span class="kr">in</span> P6.
  <span class="nb">have</span> y1Sy2SE : y1S + y2S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[<span class="mi">3</span>] n.
    <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym /pa1S a1E2.
    <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord a : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span>; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK // aE1.
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK // /pa1S /= aE1 a1E2.
  <span class="nb">have</span> lEc : l = c.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> -[l]/l.+<span class="mi">1</span>.-<span class="mi">1</span> l1E aE1 bE1.
  <span class="nb">rewrite</span> lEc.
  <span class="nb">have</span> y3Sy7SE : y3S + y7S &lt;=  (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">3</span> (<span class="mi">3</span> * c).-<span class="mi">2</span>] n.
    <span class="bp">by</span> <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa1 a1E2 eq_sym.
  <span class="nb">rewrite</span> (maxn_idPr _) <span class="kr">in</span> y3Sy7SE; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL ltnW // (leq_mul2l <span class="mi">3</span> <span class="mi">2</span>).
  <span class="nb">move</span>: P4 P6 P8 =&gt; P4 P6 P8.
  <span class="nb">rewrite</span> -(leq_add2r y1S); applyr P4.
  <span class="nb">rewrite</span> -(leq_add2r (y2S + y3S)); applyr P6.
  <span class="nb">rewrite</span> -(leq_add2r y7S); applyr P8.
  <span class="nb">rewrite</span> aE1 !muln1.
  applyl y1Sy2SE; applyl y3Sy7SE.
  <span class="nb">rewrite</span> ![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]mul2n -!addnn.
  <span class="nb">have</span> F1 := dsum_alphaL_S <span class="mi">3</span> n; <span class="nb">rewrite</span> {<span class="mi">1</span>}F1.
  <span class="nb">have</span> F2 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n; <span class="nb">rewrite</span> {<span class="mi">1</span>}F2; gsimpl.
  <span class="nb">have</span> F4 k : S_[c.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *c).-<span class="mi">2</span>] k + c.-<span class="mi">1</span>.
    <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
    <span class="nb">rewrite</span> leq_add2r.
    <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[c]prednK // mulnS addSn add2n /=.
  <span class="nb">have</span> F4n := F4 n.
  <span class="nb">have</span> F4n1 := F4 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F5 := prednK c_gt0.
  <span class="nb">rewrite</span> -{}[<span class="kr">in</span> <span class="mi">2</span> * c]F5.
  applyr F4n1; applyr F4n.
  <span class="nb">have</span> l_gt1 : <span class="mi">1</span> &lt; l <span class="bp">by</span> <span class="nb">rewrite</span> lEc.
  <span class="nb">have</span> F6 : (S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span>).*<span class="mi">2</span> &lt;= 
             S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">1</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">have</span> := (SH l_gt1); <span class="nb">rewrite</span> lEc.
  applyl F6.
  <span class="nb">have</span> F7 : S_[c.+<span class="mi">2</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">4</span>] n.+<span class="mi">2</span>.
    <span class="nb">rewrite</span> (_ : c.+<span class="mi">2</span> =  <span class="mi">1</span> + <span class="mi">3</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK <span class="nl">?addn2</span> // -ltnS prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
  <span class="nb">have</span> F8 : S_[c.+<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">3</span>] n.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> (_ : c.+<span class="mi">1</span> =  <span class="mi">1</span> + <span class="mi">2</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK <span class="nl">?addn2</span> // -ltnS prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">1</span> + c.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> add1n prednK // -ltnS prednK.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
  <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">1</span>] n.+<span class="mi">1</span>)); applyl F7; applyl F8; gsimpl.
  <span class="nb">have</span> F9 : S_[<span class="mi">4</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">3</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
  applyl F9.
  <span class="nb">have</span> F10 := dsum_alpha3_S n.
  <span class="nb">have</span> F11 := dsum_alpha3_S n.+<span class="mi">1</span>.
  gsimpl.
  <span class="nb">rewrite</span> -ltnS -![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addSn -{}F11.
  <span class="nb">rewrite</span> -ltnS -<span class="mi">3</span>![<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addSn -[<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]addnS -{}F10.
  <span class="nb">have</span> F12 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F13 := dsum_alphaL_S <span class="mi">1</span> n.
  <span class="nb">rewrite</span> F12 F13; gsimpl.
  <span class="nb">have</span> F14 := alphaL_1_2 n; <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F14.
  <span class="bp">by</span> applyl F14; gsimpl.
<span class="c">(* subcase b = 0 *)</span>
<span class="nb">rewrite</span> leqn0 =&gt; /eqP bE0.
<span class="nb">have</span> a1Ea : a1 = a <span class="bp">by</span> <span class="nb">rewrite</span> -(subnK aLa1) -/b bE0.
<span class="nb">rewrite</span> big_geq <span class="nl">?a1Ea</span> // addn0.
<span class="nb">have</span> lEc : l = c <span class="bp">by</span> <span class="nb">rewrite</span> -[l]/(l.+<span class="mi">1</span>.-<span class="mi">1</span>) l1E aE1 bE0.
<span class="nb">rewrite</span> {<span class="mi">1</span>}lEc.
<span class="nb">set</span> d1 := `d[_, _]_ _ + `d[_, _]_ _.
<span class="nb">set</span> x0S := sd _; <span class="nb">set</span> y0S := \sum_(_ &lt; _) _.
changer (a.*<span class="mi">2</span> + c.*<span class="mi">2</span> + x3S + y0S + y8S + (x0S + d1)).
<span class="nb">pose</span> u3 := [ffun i : &#39;I_6 =&gt;
  <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span> ‚Üì[u ord0] <span class="kr">else</span>
  <span class="kr">if</span> i == <span class="mi">1</span> :&gt; nat <span class="kr">then</span> sam1 <span class="kr">else</span> 
  <span class="kr">if</span> i == <span class="mi">2</span> :&gt; nat <span class="kr">then</span> tam1 <span class="kr">else</span> 
  <span class="kr">if</span> i == <span class="mi">3</span> :&gt; nat <span class="kr">then</span> ‚Üì[u (inord a1)] <span class="kr">else</span> 
  <span class="kr">if</span> i == <span class="mi">4</span> :&gt; nat <span class="kr">then</span> sa1 <span class="kr">else</span> 
  ta1].
<span class="nb">have</span> -&gt; : x0S + d1 = sd u3.
  <span class="nb">rewrite</span> /x0S /d1 /sd. 
  <span class="nb">rewrite</span> -(big_mkord xpredT (<span class="kr">fun</span> <span class="nv">i</span> =&gt; `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_ _)).
  <span class="nb">rewrite</span> {<span class="mi">1</span>}aE1 !(big_nat1, big_nat_recr) // !big_ord_recr big_ord0 
          /= <span class="nl">?inordK</span> //= !ffunE <span class="nl">?inordK</span> <span class="nl">?a1Ea</span> <span class="nl">?aE1</span> //=.
  <span class="bp">by</span> <span class="nb">rewrite</span> add0n !addnA inord_eq0.
<span class="nb">have</span> cH4 (k : &#39;I_6) : 
    <span class="mi">0</span> &lt; k &lt; <span class="mi">5</span> -&gt; codom (u3 k) \subset [:: p3; a[p1, p2] k].
    <span class="nb">case</span>: k =&gt; [] [|[|[|[|[]]]]] //= iH _; <span class="nb">rewrite</span> !ffunE !(apegS, apeg0).
  - <span class="bp">by</span> <span class="nb">have</span> := sam1C; <span class="nb">rewrite</span> /pa aE1.
  - <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
  - <span class="nb">rewrite</span> a1Ea aE1.
  - <span class="nb">have</span> /H : <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">2</span>) &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> !inordK.
    <span class="bp">by</span> <span class="nb">rewrite</span> ffunE inordK // codom_subC.
  <span class="bp">by</span> <span class="nb">rewrite</span> codom_subC.
<span class="nb">have</span> P4 :
  (S_[<span class="mi">5</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span> &lt;= sd u3 + sp ‚Üì[u ord0] <span class="mi">5</span> p1 + sp ta1 <span class="mi">5</span> p2.
  <span class="nb">apply</span>: leq_trans (IH _ _ _ _ _ _ cH4) _ =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
  <span class="bp">by</span> <span class="nb">apply</span>: leq_add; <span class="nb">rewrite</span> !ffunE.
<span class="nb">have</span> {}P4 := leq_trans P4 
  (leq_add (leq_add (leqnn _) (leq_sum_beta _ _)) (leqnn _)).
<span class="nb">rewrite</span> -/y0S <span class="kr">in</span> P4; <span class="nb">set</span> y1S := sp _ _ _ <span class="kr">in</span> P4.
<span class="nb">set</span> x1S := sd _ <span class="kr">in</span> P4; <span class="nb">rewrite</span> -/x1S.
<span class="nb">have</span> y1Sy7SE : y1S + y7S &lt;= (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> + Œ±_[maxn <span class="mi">5</span> (<span class="mi">3</span> * c).-<span class="mi">2</span>] n. 
  <span class="nb">apply</span>: sum_alpha_diffE =&gt; //; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> /pa1 eq_sym.
<span class="nb">move</span>: P4 P8 =&gt; P4 P8.
<span class="nb">rewrite</span> -(leq_add2r y1S); applyr P4.
<span class="nb">rewrite</span> -(leq_add2r y7S); applyr P8.
<span class="nb">rewrite</span> aE1 muln1.
applyl y1Sy7SE.
<span class="nb">have</span> leq_S5 k : <span class="mi">2</span> * S_[<span class="mi">1</span>] k.+<span class="mi">1</span> + S_[<span class="mi">1</span>] k.+<span class="mi">2</span> &lt;= <span class="mi">3</span> * S_[<span class="mi">5</span>] k + <span class="mi">6</span>.
  <span class="nb">have</span> F8 :  S_[<span class="mi">3</span>] k + <span class="mi">2</span> * S_[<span class="mi">6</span>] k &lt;= <span class="mi">3</span> * S_[<span class="mi">5</span>] k.
    <span class="nb">rewrite</span> -(leq_add2r (S_[<span class="mi">4</span>] k)).
    changel (S_[<span class="mi">6</span>] k + S_[<span class="mi">3</span>] k + (S_[<span class="mi">6</span>] k + S_[<span class="mi">4</span>] k)).
    changer (S_[<span class="mi">4</span>] k + S_[<span class="mi">5</span>] k + (S_[<span class="mi">5</span>] k + S_[<span class="mi">5</span>] k)).
    <span class="nb">apply</span>: leq_add.
      <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> (concave_dsum_alphaL_l _).
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 <span class="mi">4</span> <span class="mi">1</span> <span class="mi">1</span> (concave_dsum_alphaL_l _).
  <span class="nb">apply</span>: leq_trans (leq_add F8 (leqnn _)).
  <span class="nb">have</span> F3k : S_[<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[<span class="mi">3</span>] k + <span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: dsum_alpha3l.
  <span class="nb">have</span> F3k1 : S_[<span class="mi">2</span>] k.+<span class="mi">1</span> &lt;= S_[<span class="mi">6</span>] k + <span class="mi">2</span> <span class="bp">by</span> <span class="nb">apply</span>: dsum_alpha3l.
  <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F3k1; applyr F3k1; applyr F3k; gsimpl.
  <span class="nb">have</span> F3k2 := leq_dsum_alpha_2l_1 k.+<span class="mi">1</span>.
  <span class="bp">by</span> applyr F3k2.
<span class="nb">have</span> [c_gt2|c_lt3] := leqP <span class="mi">3</span> c.
<span class="c">(* Subcase c &gt;= 3 *)</span>
  <span class="nb">rewrite</span> (maxn_idPr _); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -subn2 ltn_subRL (ltn_mul2l <span class="mi">3</span> <span class="mi">2</span>).
  <span class="nb">have</span> F1 k : S_[c.-<span class="mi">1</span>] k.+<span class="mi">1</span> &lt;= S_[(<span class="mi">3</span> *c).-<span class="mi">2</span>] k + c.-<span class="mi">1</span>.
    <span class="nb">apply</span>: leq_trans (dsum_alpha3l _ _) _.
    <span class="nb">rewrite</span> leq_add2r.
    <span class="nb">apply</span>: (increasingE (increasing_dsum_alphaL_l _)).
    <span class="bp">by</span> <span class="nb">rewrite</span> -{<span class="mi">2</span>}[c]prednK // mulnS addSn add2n /=.
  <span class="nb">have</span> F1n := F1 n.
  <span class="nb">have</span> F1n1 := F1 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F2 := dsum_alphaL_S (<span class="mi">3</span> * c).-<span class="mi">2</span> n.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X]mul2n -addnn {<span class="mi">1</span>}F2; gsimpl.
  <span class="nb">have</span> F3 : <span class="mi">2</span> * c  = <span class="mi">2</span> + c.-<span class="mi">1</span> + c.-<span class="mi">1</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> mul2n add2n prednK // addSnnS prednK // addnn.
  <span class="nb">rewrite</span> {}F3.
  applyr F1n; applyr F1n1.
  <span class="nb">have</span> F4 : S_[c.+<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[c] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
  applyl F4.
  <span class="nb">have</span> F7n1 : S_[<span class="mi">2</span>] n.+<span class="mi">2</span> + S_[c.+<span class="mi">1</span>] n.+<span class="mi">2</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">2</span> + S_[<span class="mi">4</span>] n.+<span class="mi">2</span>.
    <span class="nb">rewrite</span> addnC (_ : c.+<span class="mi">1</span> = <span class="mi">2</span> + <span class="mi">2</span> + c.-<span class="mi">2</span>.-<span class="mi">1</span>); <span class="nb">last first</span>.
       <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK // -ltnS prednK // -subn1 ltn_subRL //.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">2</span> + c.-<span class="mi">1</span>.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK // -<span class="nl">?subn2</span> -<span class="nl">?subn1</span> ltn_subRL.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">2</span>).
  <span class="nb">have</span> F7n : S_[<span class="mi">2</span>] n.+<span class="mi">1</span> + S_[c] n.+<span class="mi">1</span> &lt;= S_[c.-<span class="mi">1</span>] n.+<span class="mi">1</span> + S_[<span class="mi">3</span>] n.+<span class="mi">1</span>.
    <span class="nb">rewrite</span> addnC {<span class="mi">1</span>}(_ : c = <span class="mi">2</span> + <span class="mi">1</span> + c.-<span class="mi">1</span>.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK // -<span class="mi">2</span>!ltnS !prednK // -ltnS prednK.
    <span class="nb">rewrite</span> {<span class="mi">2</span>}(_ : c.-<span class="mi">1</span> = <span class="mi">2</span> + c.-<span class="mi">1</span>.-<span class="mi">2</span>); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> !addSn add0n !prednK // -<span class="nl">?subn2</span> -<span class="nl">?subn1</span> ltn_subRL.
    <span class="bp">by</span> <span class="nb">apply</span>: concaveEk1 (concave_dsum_alphaL_l n.+<span class="mi">1</span>).
  <span class="nb">rewrite</span> -(leq_add2l (S_[<span class="mi">2</span>] n.+<span class="mi">2</span> + S_[<span class="mi">2</span>] n.+<span class="mi">1</span>)); applyl F7n1; applyl F7n.
  gsimpl.
  <span class="nb">have</span> F8 := leq_S5 n.+<span class="mi">1</span>.
  <span class="nb">have</span> F9 : S_[<span class="mi">4</span>] n.+<span class="mi">2</span> &lt;= S_[<span class="mi">3</span>] n.+<span class="mi">1</span> + (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>).*<span class="mi">2</span>.
    <span class="bp">by</span> <span class="nb">apply</span>: dsum_alphaL_alpha.
  applyl F9.
  <span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>).
  <span class="nb">rewrite</span> -leq_double <span class="kr">in</span> F8; applyr F8.
  <span class="nb">have</span> F10 := dsum_alpha3_S n.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> -(leq_add2r <span class="mi">6</span>).
  changel (<span class="mi">12</span> * (Œ±_[<span class="mi">1</span>] n.+<span class="mi">1</span>) + <span class="mi">6</span> * (S_[<span class="mi">1</span>] n) + <span class="mi">6</span> * (S_[<span class="mi">3</span>] n.+<span class="mi">1</span>).+<span class="mi">1</span>).
  <span class="nb">rewrite</span> -F10.
  <span class="nb">rewrite</span> -leq_double.
  <span class="nb">have</span> F11 := leq_dsum_alpha_2l_1 n.+<span class="mi">2</span>.
  <span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>) <span class="kr">in</span> F11.
  <span class="nb">have</span> F12 := leq_dsum_alpha_2l_1 n.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>) <span class="kr">in</span> F12.
  applyr F11; applyr F12; gsimpl.
  <span class="nb">have</span> F13 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">2</span>.
  <span class="nb">have</span> F14 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">have</span> F15 := dsum_alphaL_S <span class="mi">1</span> n.
  <span class="nb">rewrite</span> !(F13, F14, F15); gsimpl.
  <span class="nb">have</span> F16 := increasing_alphaL <span class="mi">1</span> n.+<span class="mi">1</span>.
  <span class="nb">rewrite</span> -[<span class="mi">15</span>]/(<span class="mi">7</span> + <span class="mi">8</span>) mulnDl [X <span class="kr">in</span> _ &lt;= X]addnAC [X <span class="kr">in</span> _ &lt;= X]addnC leq_add //.
    <span class="bp">by</span> <span class="nb">rewrite</span> leq_mul2l.
  <span class="nb">case</span>: (n) =&gt; [|[|[|[|n1]]]]; <span class="nb">rewrite</span> <span class="nl">?alpha_small</span> //.
  <span class="nb">have</span> F17 : <span class="mi">3</span> * Œ±_[<span class="mi">1</span>] n1.+<span class="mi">1</span>.+<span class="mi">4</span> &lt;= <span class="mi">4</span> * Œ±_[<span class="mi">1</span>] n1.+<span class="mi">4</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> alpha_4_3.
  <span class="nb">rewrite</span> -[_ &lt;= _]orFb  -(leq_mul2l <span class="mi">8</span>) mulnA <span class="kr">in</span> F17.
  <span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>) mulnA.
  <span class="bp">by</span> <span class="nb">apply</span>: leq_trans F17 _; gsimpl.
<span class="nb">have</span> cE2 : c = <span class="mi">2</span> <span class="bp">by</span> <span class="nb">case</span>: (c) c_gt1 c_lt3 =&gt; [|[|[|]]].
<span class="nb">rewrite</span> cE2 (maxn_idPl _) // add1n -[<span class="mi">2</span> * <span class="mi">2</span>]/<span class="mi">4</span> -[(<span class="mi">3</span> * <span class="mi">2</span>).-<span class="mi">2</span>]/<span class="mi">4</span> -[<span class="mi">2</span> + <span class="mi">4</span>]/<span class="mi">6</span>.
<span class="nb">rewrite</span> [<span class="kr">in</span> X <span class="kr">in</span> _ &lt;= X]mul2n -addnn.
<span class="nb">have</span> F1 := dsum_alphaL_S <span class="mi">5</span> n; <span class="nb">rewrite</span> {<span class="mi">1</span>}F1.
<span class="nb">have</span> F2 := dsum_alpha3_S n.+<span class="mi">2</span>.
<span class="nb">rewrite</span> -<span class="mi">2</span>!ltnS mul2n -![<span class="kr">in</span> X <span class="kr">in</span> X &lt;= _]addSn -doubleS -{}F2.
<span class="nb">have</span> F3 := leq_S5 n.
<span class="nb">have</span> F4 := leq_S5 n.+<span class="mi">1</span>.
<span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>); gsimpl.
applyr F3; applyr F4.
<span class="nb">have</span> F5 := leq_S4 n.+<span class="mi">1</span>; applyr F5.
<span class="nb">have</span> F6 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">2</span>.
<span class="nb">have</span> F7 := dsum_alphaL_S <span class="mi">1</span> n.+<span class="mi">1</span>.
<span class="nb">have</span> F8 := dsum_alphaL_S <span class="mi">1</span> n.
<span class="nb">rewrite</span> !(F6, F7, F8); gsimpl.
<span class="nb">have</span> F10 := alphaL_1_2 n.+<span class="mi">1</span>.
<span class="nb">rewrite</span> -[_ &lt;= _]orFb -(leq_mul2l <span class="mi">4</span>) <span class="kr">in</span> F10.
applyl F10; gsimpl.
<span class="nb">case</span>: (n) =&gt; [|[|[|[|n1]]]]; <span class="nb">rewrite</span> <span class="nl">?alpha_small</span> //.
<span class="nb">have</span> F9 : <span class="mi">3</span> * Œ±_[<span class="mi">1</span>] n1.+<span class="mi">1</span>.+<span class="mi">4</span> &lt;= <span class="mi">4</span> * Œ±_[<span class="mi">1</span>] n1.+<span class="mi">4</span>.
  <span class="bp">by</span> <span class="nb">rewrite</span> alpha_4_3.
<span class="nb">rewrite</span> -[_ &lt;= _]orFb  -(leq_mul2l <span class="mi">4</span>) <span class="kr">in</span> F9.
<span class="nb">rewrite</span> -[_ &lt;= _](leq_mul2l <span class="mi">3</span>).
<span class="bp">by</span> <span class="nb">rewrite</span> add1n; applyl F9; gsimpl.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">Case3</span>.

<span class="kn">Lemma</span> <span class="nf">main</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> <span class="nv">n</span> <span class="nv">l</span> (<span class="nv">u</span> : {ffun &#39;I_l.+<span class="mi">1</span> -&gt; configuration <span class="mi">4</span> n}) :
   p1 != p2 -&gt; p1 != p3 -&gt; p2 != p3 -&gt; 
   p1 != p0 -&gt; p2 != p0 -&gt; p3 != p0 -&gt;
  (<span class="kr">forall</span> <span class="nv">k</span> : &#39;I_l.+<span class="mi">1</span>, <span class="mi">0</span> &lt; k &lt; l -&gt; 
                       codom (u k) \subset [:: p2; a[p1, p3] k]) -&gt;
  (S_[l] n).*<span class="mi">2</span> &lt;=  \sum_(i &lt; l) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove + 
                    \sum_(k &lt; n) (u ord0 k != p1) * Œ≤_[n, l] k +  
                    \sum_(k &lt; n) (u ord_max k != a[p1, p3] l) * Œ≤_[n, l] k.
<span class="kn">Proof</span>.
<span class="nb">elim</span>: n l p1 p2 p3 u =&gt; [|[|n] IH] l p1 p2 p3 
                u p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0 cH.
- <span class="bp">by</span> <span class="nb">rewrite</span> /dsum_alphaL /conv /= dsum_alpha_0 muln0.
- <span class="nb">rewrite</span> /dsum_alphaL /conv /= dsum_alpha_1 dsum_alpha_0 
          muln0 addn0 add0n muln1.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X + _]big_ord_recl big_ord0  /= addn0.
  <span class="nb">rewrite</span> [X <span class="kr">in</span> _ &lt;= _ + X]big_ord_recl big_ord0  /= addn0.
  <span class="nb">have</span> d0fE (c1 c2 : configuration <span class="mi">4</span> <span class="mi">1</span>) : 
    c1 != `c[p0] -&gt; c2 != `c[p0] -&gt; `d[c1, c2]_smove = (c1 != c2).*<span class="mi">2</span>.
    <span class="nb">move</span>=&gt; c1Dp0 c2Dp0.
    <span class="nb">case</span>: (gpath_connect (shanoi_connect c1 c2)) 
              =&gt; [] [/gpath_dist H |a [|b p]].
    - <span class="bp">by</span> <span class="nb">rewrite</span> H; <span class="nb">move</span>/eqP: H; <span class="nb">rewrite</span> gdist_eq0 =&gt; -&gt;.
    - <span class="nb">case</span>/gpathP; <span class="nb">rewrite</span> /= andbT =&gt; /moveP[z].
      <span class="nb">rewrite</span> [z]disk1_all =&gt; [] [zH _ _ _] aE.
      <span class="nb">case</span>/andP: zH =&gt; _; <span class="nb">rewrite</span> aE.
      <span class="nb">move</span>: c1Dp0 c2Dp0; <span class="nb">rewrite</span> !configuration1_eq !Ival_eq /= !ffunE /=.
      <span class="bp">by</span> <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: val.
    <span class="nb">move</span>=&gt; /gpath_dist; <span class="nb">case</span>: eqP =&gt; [&lt;-|/eqP c1Dc2]; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> gdist0.
    <span class="nb">move</span>=&gt; H; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqn_leq {<span class="mi">2</span>}H /= andbT.
    <span class="nb">have</span> pH : path smove c1 [::`c[p0]; c2].
      <span class="nb">rewrite</span> /=; <span class="nb">apply</span>/and3P; <span class="nb">split</span> =&gt; //.
        <span class="nb">apply</span>/moveP; <span class="kr">exists</span> <span class="nv">ord0</span>; <span class="nb">split</span> =&gt; //=.
        - <span class="nb">rewrite</span> !ffunE; <span class="nb">apply</span>/andP; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> muln0.
          <span class="bp">by</span> <span class="nb">move</span>: c1Dp0; <span class="nb">rewrite</span> configuration1_eq ffunE.
        - <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> [i]disk1_all.
        - <span class="bp">by</span> <span class="nb">apply</span>/on_topP =&gt; j; <span class="nb">rewrite</span> [j]disk1_all.
        <span class="bp">by</span> <span class="nb">apply</span>/on_topP =&gt; j; <span class="nb">rewrite</span> [j]disk1_all.
      <span class="nb">apply</span>/moveP; <span class="kr">exists</span> <span class="nv">ord0</span>; <span class="nb">split</span> =&gt; //=.
      - <span class="nb">rewrite</span> !ffunE; <span class="nb">apply</span>/andP; <span class="nb">split</span>=&gt; //.
        <span class="bp">by</span> <span class="nb">move</span>: c2Dp0; <span class="nb">rewrite</span> configuration1_eq ffunE eq_sym.
      - <span class="bp">by</span> <span class="nb">move</span>=&gt; i; <span class="nb">rewrite</span> [i]disk1_all.
      - <span class="bp">by</span> <span class="nb">apply</span>/on_topP =&gt; j; <span class="nb">rewrite</span> [j]disk1_all.
      <span class="bp">by</span> <span class="nb">apply</span>/on_topP =&gt; j; <span class="nb">rewrite</span> [j]disk1_all.
    <span class="nb">rewrite</span> -[<span class="mi">1</span>.*<span class="mi">2</span>]/(size [:: `c[p0]; c2]).
    <span class="bp">by</span> <span class="nb">apply</span>: gdist_path_le pH _.
  <span class="nb">case</span>: l u cH =&gt; [|l] u cH; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> (minn_idPr _).
  <span class="nb">case</span>: l u cH =&gt; [|l] u cH.
    <span class="nb">rewrite</span> (minn_idPr _) //.
    <span class="nb">rewrite</span> big_ord_recl big_ord0 addn0.
    <span class="nb">rewrite</span> inord_eq0 // (_ : inord <span class="mi">1</span> = ord_max); <span class="nb">last first</span>.
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    <span class="nb">rewrite</span> /beta !(apegS, apeg0) /= alphaL1E -[_ <span class="mi">0</span>]/<span class="mi">1</span>; 
        <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: eqP; <span class="nb">rewrite</span> /= <span class="nl">?addn0</span>;
        <span class="kp">try</span> <span class="bp">by</span> <span class="nb">move</span>=&gt; *; <span class="nb">rewrite</span> leq_addl.
    <span class="nb">move</span>=&gt; u1E u0E.
    <span class="nb">rewrite</span> d0fE //.
    - <span class="bp">by</span> <span class="nb">rewrite</span> configuration1_eq u1E u0E p1Dp3.
    - <span class="bp">by</span> <span class="nb">rewrite</span> configuration1_eq ffunE u0E.
    <span class="bp">by</span> <span class="nb">rewrite</span> configuration1_eq ffunE u1E.
  <span class="nb">rewrite</span> (minn_idPl _) // -[_.*<span class="mi">2</span>]/<span class="mi">4</span>.
  <span class="nb">rewrite</span> big_ord_recl big_ord_recr /=.
  <span class="nb">rewrite</span> -!addnA addnC -!addnA (leq_trans _ (leq_addl _ _)) //.
  <span class="nb">rewrite</span> !apegS /beta /= alphaL_0 (minn_idPl _) /bump /= <span class="nl">?add1n</span> //.
  <span class="nb">rewrite</span> addnCA addnC !addnA -addnA -[<span class="mi">4</span>]/(<span class="mi">2</span> + <span class="mi">2</span>).
  <span class="nb">apply</span>: leq_add.
    <span class="nb">case</span>: eqP =&gt; /= [umE|umD]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leq_addl.
    <span class="nb">rewrite</span> addn0 d0fE.
    - <span class="nb">case</span>: eqP =&gt; // H.
      <span class="nb">have</span> /cH :  <span class="mi">0</span> &lt; (inord l.+<span class="mi">1</span> : &#39;I_l.+<span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK /=.
      <span class="nb">move</span>=&gt; /subsetP/(_ _ (codom_f _ sdisk)).
      <span class="nb">rewrite</span> H (_ : inord l.+<span class="mi">2</span> = ord_max).
        <span class="nb">rewrite</span> umE inordK // apegS //= !inE.
        <span class="nb">rewrite</span> (apeg_eqC _ _ _) // (negPf (apeg_neq _ _ _)) //=.
          <span class="bp">by</span> <span class="nb">rewrite</span> (negPf p1Dp3).
        <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
    - <span class="nb">rewrite</span> configuration1_eq ffunE.
      <span class="nb">case</span>: (_ =P _) =&gt; // H.
      <span class="nb">have</span> /cH :  <span class="mi">0</span> &lt; (inord l.+<span class="mi">1</span> : &#39;I_l.+<span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK /=.
      <span class="nb">move</span>=&gt; /subsetP/(_ _ (codom_f _ sdisk)).
      <span class="bp">by</span> <span class="nb">rewrite</span> H !inE eq_sym (negPf p2Dp0) /= eq_sym (negPf (apeg_neq _ _ _)).
    <span class="nb">rewrite</span> configuration1_eq ffunE.
    <span class="nb">rewrite</span> (_ : inord l.+<span class="mi">2</span> = ord_max).
      <span class="bp">by</span> <span class="nb">rewrite</span> umE apeg_neq.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">case</span>: eqP =&gt; /= [u0E|u0D]; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> leq_addl.
  <span class="nb">rewrite</span> addn0 d0fE.
  - <span class="nb">case</span>: eqP =&gt; // H.
    <span class="nb">have</span> /cH :  <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK /=.
    <span class="nb">move</span>=&gt; /subsetP/(_ _ (codom_f _ sdisk)).
    <span class="nb">rewrite</span> -H inord_eq0 // u0E inordK //= !(apegS, apeg0).
    <span class="bp">by</span> <span class="nb">rewrite</span> !inE (negPf p1Dp2) (negPf p1Dp3).
  - <span class="bp">by</span> <span class="nb">rewrite</span> configuration1_eq ffunE inord_eq0 // u0E.
  <span class="nb">rewrite</span> configuration1_eq ffunE.
  <span class="nb">case</span>: eqP =&gt; // H.
  <span class="nb">have</span> /cH :  <span class="mi">0</span> &lt; (inord <span class="mi">1</span> : &#39;I_l.+<span class="mi">3</span>) &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> inordK /=.
  <span class="nb">move</span>=&gt; /subsetP/(_ _ (codom_f _ sdisk)).
  <span class="bp">by</span> <span class="nb">rewrite</span> H !inE eq_sym (negPf p2Dp0) /= eq_sym (negPf (apeg_neq _ _ _)).
<span class="nb">case</span>: l u cH =&gt; [|l] u cH; <span class="kp">first</span> <span class="bp">by</span> <span class="nb">rewrite</span> S0E.
<span class="nb">rewrite</span> apegS.
<span class="nb">pose</span> u&#39; : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">1</span>} :=
     [ffun i : &#39;I_l.+<span class="mi">2</span> =&gt; ‚Üì[u i]].
<span class="nb">have</span> H (k : &#39;I_l.+<span class="mi">2</span>) : 
  <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u&#39; k) \subset [:: p2; a[p1, p3] k].
  <span class="bp">by</span> <span class="nb">move</span>=&gt; k1; <span class="nb">rewrite</span> ffunE; <span class="nb">apply</span>/codom_liftr/cH. 
<span class="nb">pose</span> K := (u ord0 ord_max != p1) + 
          (u ord_max ord_max != a[p3, p1] l).
<span class="nb">have</span> [HK|] := boolP ((K == <span class="mi">2</span>) || ((K == <span class="mi">1</span>) &amp;&amp; (l == <span class="mi">0</span>))).
  <span class="nb">rewrite</span> dsum_alphaL_S doubleD.
  <span class="nb">have</span> IH&#39; := IH _ p1 p2 p3 u&#39;
              p1Dp2 p1Dp3 p2Dp3 p1Dp0 p2Dp0 p3Dp0 H.
  <span class="nb">rewrite</span> apegS <span class="kr">in</span> IH&#39;.
  <span class="nb">rewrite</span> ![\sum_(_ &lt; _.+<span class="mi">2</span>) _]big_ord_recr /=.
  <span class="nb">set</span> u1 := \sum_ (_ &lt; _) _; <span class="nb">set</span> u2 := \sum_ (_ &lt; _) _; <span class="nb">set</span> u3 := \sum_ (_ &lt; _) _.
  <span class="nb">rewrite</span> -!addnA [_ + (u3 + _)]addnCA <span class="mi">2</span>!addnA.
  <span class="nb">apply</span>: leq_add.
    <span class="nb">apply</span>: leq_trans IH&#39; _.
    <span class="nb">apply</span>: leq_add; <span class="nb">last first</span>.
      <span class="nb">apply</span>: leq_sum =&gt; i _.
      <span class="nb">apply</span>: leq_mul.
        <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
        <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE; <span class="nb">congr</span> (u _ _ != _); <span class="nb">apply</span>/val_eqP.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}/beta eqn_leq [_ &lt;= i]leqNgt ltn_ord !andbF /=.
    <span class="nb">apply</span>: geq_beta.
    <span class="nb">apply</span>: leq_add; <span class="nb">last first</span>.
      <span class="nb">apply</span>: leq_sum =&gt; i _.
      <span class="nb">apply</span>: leq_mul.
        <span class="nb">rewrite</span> leq_eqVlt; <span class="nb">apply</span>/orP; <span class="nb">left</span>; <span class="nb">apply</span>/eqP.
        <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE; <span class="nb">congr</span> (u _ _ != _); <span class="nb">apply</span>/val_eqP.
      <span class="nb">rewrite</span> {<span class="mi">2</span>}/beta eqn_leq [_ &lt;= i]leqNgt ltn_ord !andbF /=.
      <span class="nb">apply</span>: geq_beta.
    <span class="nb">apply</span>: leq_sum =&gt; i _.
    <span class="nb">rewrite</span> !ffunE.
    <span class="bp">by</span> <span class="nb">apply</span>/gdist_cunlift/shanoi_connect.
  <span class="nb">rewrite</span> -mulnDl -/K.
  <span class="nb">case</span>/orP: HK =&gt; [/eqP-&gt;|/andP[/eqP-&gt; /eqP-&gt;]].
    <span class="bp">by</span> <span class="nb">rewrite</span> mul2n leq_double leq_beta.
  <span class="bp">by</span> <span class="nb">rewrite</span> mul1n /beta /= /alphaL /delta !S1E.
<span class="nb">rewrite</span> negb_or negb_and.
<span class="nb">have</span>: K &lt;= <span class="mi">2</span> <span class="bp">by</span> <span class="nb">rewrite</span> /K; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: (_ != _).
<span class="nb">case</span>: ltngtP; <span class="nb">rewrite</span> // ltnS.
<span class="nb">case</span>: ltngtP =&gt; //= KE _ _ l_gt0; <span class="nb">last first</span>.
  <span class="nb">move</span>: KE; <span class="nb">rewrite</span> /K.
  (<span class="nb">case</span>: eqP =&gt; [KH1|/eqP KH1] /=; <span class="nb">case</span>: eqP) =&gt; // [/eqP KH2|KH2] _.
    <span class="bp">by</span> <span class="nb">apply</span>: (@case1 _ IH) cH KH1 KH2 l_gt0.
  <span class="nb">pose</span> u1 : {ffun &#39;I_l.+<span class="mi">2</span> -&gt; configuration <span class="mi">4</span> n.+<span class="mi">2</span>} := 
     [ffun i : &#39;I_l.+<span class="mi">2</span> =&gt; u (inord (l.+<span class="mi">1</span> - i))].
  <span class="nb">have</span> -&gt; : \sum_(i &lt; l.+<span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove =
            \sum_(i &lt; l.+<span class="mi">1</span>) `d[u1 (inord i), u1 (inord i.+<span class="mi">1</span>)]_smove.
    <span class="nb">have</span> F : injective (<span class="kr">fun</span> <span class="nv">i</span> : &#39;I_l.+<span class="mi">1</span> =&gt; (inord (l - i) : &#39;I_l.+<span class="mi">1</span>)).
      <span class="nb">move</span>=&gt; i j /val_eqP.
      <span class="nb">have</span> lBiLl (i1 : &#39;I_l.+<span class="mi">1</span>) : l - i1 &lt; l.+<span class="mi">1</span>.
        <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR <span class="nl">?leq_addl</span> // -ltnS.
      <span class="nb">rewrite</span> /= !inordK // =&gt; /eqP liE; <span class="nb">apply</span>/val_eqP =&gt; /=.
      <span class="nb">rewrite</span> -(subKn (_ : i &lt;= l)); <span class="nb">last</span> <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS.
      <span class="bp">by</span> <span class="nb">rewrite</span> liE subKn // -ltnS.
    <span class="nb">rewrite</span> (reindex_inj F) /=.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">rewrite</span> !ffunE.
    <span class="nb">have</span> iLl2 : i &lt; l.+<span class="mi">2</span> <span class="bp">by</span> <span class="nb">apply</span>: leq_trans (ltn_ord _) _.
    <span class="nb">have</span> lBiLl : l - i &lt; l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR <span class="nl">?leq_addl</span> // -ltnS.
    <span class="nb">have</span> iLl : i &lt;= l <span class="bp">by</span> <span class="nb">rewrite</span> -ltnS.
    <span class="nb">rewrite</span> gdistC; <span class="nb">last</span> <span class="bp">by</span> <span class="nb">apply</span>/move_sym/ssym.
    <span class="nb">congr</span> (`d[u _,u _]_smove).
      <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK <span class="nl">?subSn</span>.
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= !inordK // <span class="nl">?subSS</span> ltnS // ltnW.
  <span class="nb">pose</span> p1&#39; := a[p3, p1] l.
  <span class="nb">pose</span> p3&#39; := a[p1, p3] l.
  <span class="nb">have</span> -&gt; : \sum_(k &lt; n.+<span class="mi">2</span>) (u ord0 k != p1) * Œ≤_[n.+<span class="mi">2</span>, l.+<span class="mi">1</span>] k =
            \sum_(k &lt; n.+<span class="mi">2</span>) (u1 ord_max k != a[p1&#39;, p3&#39;] l.+<span class="mi">1</span>) * 
                            Œ≤_[n.+<span class="mi">2</span>, l.+<span class="mi">1</span>] k.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> (_ * _).
    <span class="nb">rewrite</span> ffunE subnn.
    <span class="bp">by</span> <span class="nb">rewrite</span> inord_eq0 // -apegD addSn addnn apegS apeg_double.
  <span class="nb">have</span> -&gt; : \sum_(k &lt; n.+<span class="mi">2</span>) 
              (u ord_max k != a[p3, p1] l) * Œ≤_[n.+<span class="mi">2</span>, l.+<span class="mi">1</span>] k =
            \sum_(k &lt; n.+<span class="mi">2</span>) (u1 ord0 k != p1&#39;) * Œ≤_[n.+<span class="mi">2</span>, l.+<span class="mi">1</span>] k.
    <span class="nb">apply</span>: eq_bigr =&gt; i _; <span class="nb">congr</span> (_ * _).
    <span class="nb">rewrite</span> ffunE subn0.
    <span class="nb">suff</span> -&gt; : inord l.+<span class="mi">1</span> = ord_max :&gt; &#39;I_l.+<span class="mi">2</span> <span class="bp">by</span> []. 
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="nb">have</span> cH1 (k : &#39;I_l.+<span class="mi">2</span>) : 
     <span class="mi">0</span> &lt; k &lt; l.+<span class="mi">1</span> -&gt; codom (u1 k) \subset [:: p2; a[p1&#39;, p3&#39;] k].
    <span class="nb">move</span>=&gt; /andP[kH1 kH2]; <span class="nb">rewrite</span> ffunE.
    <span class="nb">have</span> F1 : k &lt;= l.+<span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span>: ltnW.
    <span class="nb">have</span> F2 : l.+<span class="mi">1</span> - k &lt; l.+<span class="mi">2</span>.
      <span class="bp">by</span> <span class="nb">rewrite</span> ltn_subLR // addnS ltnS leq_addl.
    <span class="nb">have</span> -&gt; :  a[p1&#39;, p3&#39;] k = a[p1, p3] (inord (l.+<span class="mi">1</span> - k) : &#39;I_l.+<span class="mi">2</span>).
      <span class="nb">rewrite</span> -apegD inordK // [RHS]apegO oddB //.
      <span class="bp">by</span> <span class="nb">rewrite</span> -oddD -apegO addSn apegS addnC.
    <span class="nb">apply</span>: cH; <span class="nb">rewrite</span> inordK // subn_gt0 // ltn_subLR // kH2 //=.
    <span class="bp">by</span> <span class="nb">rewrite</span> addnS ltnS -{<span class="mi">1</span>}[l.+<span class="mi">1</span>]add1n leq_add2r.
  <span class="nb">rewrite</span> -addnA [X <span class="kr">in</span> _ &lt;= _ + X]addnC addnA apegS.
  <span class="nb">apply</span>: (@case1 _ IH) cH1 _  _ _ =&gt; //.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_eqC // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="bp">by</span> <span class="nb">rewrite</span> apeg_neq // eq_sym.
  - <span class="nb">rewrite</span> ffunE subn0.
    <span class="nb">suff</span> -&gt; : inord l.+<span class="mi">1</span> = ord_max :&gt; &#39;I_l.+<span class="mi">2</span> <span class="bp">by</span> [].
    <span class="bp">by</span> <span class="nb">apply</span>/val_eqP; <span class="nb">rewrite</span> /= inordK.
  <span class="bp">by</span> <span class="nb">rewrite</span> ffunE subnn inord_eq0 // -apegD addnn apeg_double.
<span class="nb">move</span>: KE; <span class="nb">rewrite</span> /K; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">case</span>: eqP =&gt; //=.
<span class="nb">move</span> =&gt; uME u0E _.
<span class="bp">by</span> <span class="nb">apply</span>: (case3 IH _ _ _ _ _ _ cH).
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">main_cor</span> <span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">n</span> :
  p1 != p0 -&gt; p2 != p0 -&gt; p1 != p2 -&gt;  
  (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> &lt;= `d[`c[p1, n],`c[p2, n]]_smove.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p1Dp0 p2Dp0 p1Dp2.
<span class="nb">rewrite</span> eq_sym <span class="kr">in</span> p2Dp0.
<span class="nb">have</span> [p3 [[p3Dp2 p3Dp0 p3Dp1] _]] := peg4comp3 p1Dp0 p1Dp2 p2Dp0.
<span class="nb">rewrite</span> eq_sym <span class="kr">in</span> p2Dp0.
<span class="nb">pose</span> u := [ffun i : &#39;I_2 =&gt; <span class="kr">if</span> i == <span class="mi">0</span> :&gt; nat <span class="kr">then</span>
                             `c[p1, n] <span class="kr">else</span> `c[p2, n]].
<span class="nb">suff</span> :
  (S_[<span class="mi">1</span>] n).*<span class="mi">2</span> &lt;=
  \sum_(i &lt; <span class="mi">1</span>) `d[u (inord i), u (inord i.+<span class="mi">1</span>)]_smove +
  \sum_(k &lt; n) (u ord0 k != p1) * Œ≤_[n, <span class="mi">1</span>] k +
  \sum_(k &lt; n) (u ord_max k != p2) * Œ≤_[n, <span class="mi">1</span>] k.
  <span class="nb">rewrite</span> big_ord_recr big_ord0 !ffunE /= inord_eq0 //= add0n.
  <span class="nb">rewrite</span> inordK //=.
  <span class="nb">rewrite</span> (eq_bigr (<span class="kr">fun</span> <span class="nv">i</span> : &#39;I_n =&gt; <span class="mi">0</span>)) =&gt; [|i _]; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE eqxx.
  <span class="nb">rewrite</span> -(big_mkord xpredT (<span class="kr">fun</span>=&gt; <span class="mi">0</span>)) sum_nat_const_nat muln0.
  <span class="nb">rewrite</span> (eq_bigr (<span class="kr">fun</span> <span class="nv">i</span> : &#39;I_n =&gt; <span class="mi">0</span>)) =&gt; [|i _]; <span class="nb">last first</span>.
    <span class="bp">by</span> <span class="nb">rewrite</span> !ffunE eqxx.
  <span class="nb">rewrite</span> -(big_mkord xpredT (<span class="kr">fun</span>=&gt; <span class="mi">0</span>)) sum_nat_const_nat muln0.
  <span class="bp">by</span> <span class="nb">rewrite</span> !addn0.
<span class="nb">apply</span>: (@main p1 p3 p2) =&gt; //.
  <span class="bp">by</span> <span class="nb">rewrite</span> eq_sym.
<span class="bp">by</span> <span class="nb">case</span>=&gt; [] [].
<span class="kn">Qed</span>.

<span class="kn">Lemma</span> <span class="nf">gdist_shanoi4</span> (<span class="nv">n</span> : nat) (<span class="nv">p1</span> <span class="nv">p2</span> : peg <span class="mi">4</span>) : 
  p1 != p2 -&gt; p1 != p0 -&gt; p2 != p0 -&gt; 
  `d[`c[p1, n], `c[p2, n]]_smove = (S_[<span class="mi">1</span>] n).*<span class="mi">2</span>.
<span class="kn">Proof</span>.
<span class="nb">move</span>=&gt; p1Dp2 p1Dp0 p2Dp0; <span class="nb">apply</span>/eqP; <span class="nb">rewrite</span> eqn_leq.
<span class="bp">by</span> <span class="nb">rewrite</span> leq_shanoi4 // main_cor.
<span class="kn">Qed</span>.

<span class="kn">End</span> <span class="nf">sHanoi4</span>.</span></span></pre></article></body></html>